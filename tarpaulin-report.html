<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","stippi","projects","code-assistant","src","agent","agent.rs"],"content":"use crate::llm::{\n    ContentBlock, LLMProvider, LLMRequest, Message, MessageContent, MessageRole, StreamingCallback,\n};\nuse crate::persistence::StatePersistence;\nuse crate::tools::{\n    parse_tool_json, parse_tool_xml, AgentToolHandler, ReplayToolHandler, ToolExecutor,\n    TOOL_TAG_PREFIX,\n};\nuse crate::types::*;\nuse crate::ui::{UIMessage, UserInterface};\nuse crate::utils::CommandExecutor;\nuse anyhow::Result;\nuse std::sync::Arc;\nuse tracing::debug;\n\nconst SYSTEM_MESSAGE: \u0026str = include_str!(\"../../resources/system_message.md\");\nconst SYSTEM_MESSAGE_TOOLS: \u0026str = include_str!(\"../../resources/system_message_tools.md\");\n\npub enum ToolMode {\n    Native,\n    Xml,\n}\n\npub struct Agent {\n    working_memory: WorkingMemory,\n    llm_provider: Box\u003cdyn LLMProvider\u003e,\n    tool_mode: ToolMode,\n    explorer: Box\u003cdyn CodeExplorer\u003e,\n    command_executor: Box\u003cdyn CommandExecutor\u003e,\n    ui: Arc\u003cBox\u003cdyn UserInterface\u003e\u003e,\n    state_persistence: Box\u003cdyn StatePersistence\u003e,\n}\n\nimpl Agent {\n    pub fn new(\n        llm_provider: Box\u003cdyn LLMProvider\u003e,\n        tool_mode: ToolMode,\n        explorer: Box\u003cdyn CodeExplorer\u003e,\n        command_executor: Box\u003cdyn CommandExecutor\u003e,\n        ui: Box\u003cdyn UserInterface\u003e,\n        state_persistence: Box\u003cdyn StatePersistence\u003e,\n    ) -\u003e Self {\n        Self {\n            working_memory: WorkingMemory::default(),\n            llm_provider,\n            tool_mode,\n            explorer,\n            ui: Arc::new(ui),\n            command_executor,\n            state_persistence,\n        }\n    }\n\n    async fn run_agent_loop(\u0026mut self) -\u003e Result\u003c()\u003e {\n        // Main agent loop\n        loop {\n            // Start with just the working memory message\n            let mut messages = self.prepare_messages();\n\n            // Keep trying until all actions succeed\n            let mut all_actions_succeeded = false;\n            while !all_actions_succeeded {\n                let (actions, assistant_msg) = self.get_next_actions(messages.clone()).await?;\n                messages.push(assistant_msg);\n\n                all_actions_succeeded = true; // Will be set to false if any action fails\n\n                for action in actions {\n                    let result = self.execute_action(\u0026action).await?;\n\n                    if !result.result.is_success() {\n                        all_actions_succeeded = false;\n                        // Add error message to conversation\n                        messages.push(Message {\n                            role: MessageRole::User,\n                            content: MessageContent::Text(format!(\n                                \"Error executing action: {}\\n{}\",\n                                result.reasoning,\n                                result.result.format_message()\n                            )),\n                        });\n                        break; // Stop processing remaining actions\n                    }\n\n                    self.working_memory.action_history.push(result);\n\n                    // Save state after each successful action\n                    self.state_persistence.save_state(\n                        self.working_memory.current_task.clone(),\n                        self.working_memory.action_history.clone(),\n                    )?;\n\n                    // Check if this was a CompleteTask action\n                    if let Tool::CompleteTask { .. } = action.tool {\n                        // Clean up state file on successful completion\n                        self.state_persistence.cleanup()?;\n                        debug!(\"Task completed\");\n                        return Ok(());\n                    }\n                }\n            }\n        }\n    }\n\n    /// Start a new agent task\n    pub async fn start_with_task(\u0026mut self, task: String) -\u003e Result\u003c()\u003e {\n        debug!(\"Starting agent with task: {}\", task);\n        self.working_memory.current_task = task.clone();\n\n        self.ui\n            .display(UIMessage::Action(\n                \"Creating initial repository structure...\".to_string(),\n            ))\n            .await?;\n\n        self.working_memory.file_tree = Some(self.explorer.create_initial_tree(2)?);\n\n        // Save initial state\n        self.state_persistence\n            .save_state(task, self.working_memory.action_history.clone())?;\n\n        self.run_agent_loop().await\n    }\n\n    /// Continue from a saved state\n    pub async fn start_from_state(\u0026mut self) -\u003e Result\u003c()\u003e {\n        if let Some(state) = self.state_persistence.load_state()? {\n            debug!(\"Continuing task: {}\", state.task);\n\n            // Create fresh working memory for replay\n            let mut replay_memory = WorkingMemory::default();\n            replay_memory.current_task = state.task.clone();\n            replay_memory.file_tree = Some(self.explorer.create_initial_tree(2)?);\n\n            // Create replay executor\n            let mut replay_handler = ReplayToolHandler::new(replay_memory);\n\n            self.ui\n                .display(UIMessage::Action(format!(\n                    \"Continuing task: {}, replaying {} actions\",\n                    state.task,\n                    state.actions.len()\n                )))\n                .await?;\n\n            // Replay actions into replay memory\n            for original_action in state.actions {\n                debug!(\"Replaying action: {:?}\", original_action.tool);\n                let action = AgentAction {\n                    tool: original_action.tool.clone(),\n                    reasoning: original_action.reasoning.clone(),\n                };\n\n                if let Ok((_, result)) = ToolExecutor::execute(\n                    \u0026mut replay_handler,\n                    Some(\u0026mut self.explorer),\n                    \u0026self.command_executor,\n                    Some(\u0026self.ui),\n                    \u0026action.tool,\n                )\n                .await\n                {\n                    if result.is_success() {\n                        self.working_memory.action_history.push(ActionResult {\n                            tool: action.tool,\n                            result,\n                            reasoning: action.reasoning,\n                        });\n                    } else {\n                        // On failure use original result\n                        self.working_memory.action_history.push(original_action);\n                    }\n                } else {\n                    // On error use original result\n                    self.working_memory.action_history.push(original_action);\n                }\n            }\n\n            // Take the replayed memory\n            self.working_memory = replay_handler.into_memory();\n\n            self.run_agent_loop().await\n        } else {\n            anyhow::bail!(\"No saved state found\")\n        }\n    }\n\n    /// Get next actions from LLM\n    async fn get_next_actions(\n        \u0026self,\n        messages: Vec\u003cMessage\u003e,\n    ) -\u003e Result\u003c(Vec\u003cAgentAction\u003e, Message)\u003e {\n        let request = LLMRequest {\n            messages,\n            system_prompt: match self.tool_mode {\n                ToolMode::Native =\u003e SYSTEM_MESSAGE.to_string(),\n                ToolMode::Xml =\u003e SYSTEM_MESSAGE_TOOLS.to_string(),\n            },\n            tools: match self.tool_mode {\n                ToolMode::Native =\u003e Some(Tools::all()),\n                ToolMode::Xml =\u003e None,\n            },\n        };\n\n        for (i, message) in request.messages.iter().enumerate() {\n            if let MessageContent::Text(text) = \u0026message.content {\n                debug!(\"Message {}: Role={:?}\\n---\\n{}\\n---\", i, message.role, text);\n            }\n        }\n\n        let ui = Arc::clone(\u0026self.ui);\n        let streaming_callback: StreamingCallback = Box::new(move |text: \u0026str| {\n            ui.display_streaming(text)\n                .map_err(|e| anyhow::anyhow!(\"Failed to display streaming output: {}\", e))\n        });\n\n        let response = self\n            .llm_provider\n            .send_message(request, Some(\u0026streaming_callback))\n            .await?;\n\n        debug!(\"Raw LLM response:\");\n        for block in \u0026response.content {\n            match block {\n                ContentBlock::Text { text } =\u003e {\n                    debug!(\"---\\n{}\\n---\", text);\n                }\n                ContentBlock::ToolUse { name, input, .. } =\u003e {\n                    debug!(\"---\\ntool: {}, input: {}\\n---\", name, input);\n                }\n                _ =\u003e {}\n            }\n        }\n        debug!(\n            \"==== Token usage: Input: {}, Output: {}\",\n            response.usage.input_tokens, response.usage.output_tokens\n        );\n\n        let actions = parse_llm_response(\u0026response)?;\n        let assistant_msg = Message {\n            role: MessageRole::Assistant,\n            content: MessageContent::Structured(response.content),\n        };\n        Ok((actions, assistant_msg))\n    }\n\n    pub fn render_working_memory(\u0026self) -\u003e String {\n        let mut memory = format!(\"Task: {}\\n\\n\", self.working_memory.current_task);\n\n        // Add repository structure with proper indentation\n        memory.push_str(\"Repository structure:\\n\");\n        if let Some(tree) = \u0026self.working_memory.file_tree {\n            memory.push_str(\u0026tree.to_string());\n        } else {\n            memory.push_str(\"No file tree available\");\n        }\n        memory.push_str(\"\\n\\n\");\n\n        // Add loaded files with their contents\n        memory.push_str(\"Current Working Memory:\\n\");\n        memory.push_str(\"- Loaded files and their contents:\\n\");\n        for (path, content) in \u0026self.working_memory.loaded_files {\n            memory.push_str(\u0026format!(\"\\n-----{}:\\n{}\\n\", path.display(), content));\n        }\n\n        // Add file summaries\n        memory.push_str(\"\\n- File summaries:\\n\");\n        for (path, summary) in \u0026self.working_memory.file_summaries {\n            memory.push_str(\u0026format!(\"  {}: {}\\n\", path.display(), summary));\n        }\n\n        // Add action history\n        memory.push_str(\"\\nPrevious actions:\\n\");\n        for (i, action) in self.working_memory.action_history.iter().enumerate() {\n            memory.push_str(\u0026format!(\"\\n{}. Tool: {:?}\\n\", i + 1, action.tool));\n            memory.push_str(\u0026format!(\"   Reasoning: {}\\n\", action.reasoning));\n            memory.push_str(\u0026format!(\"   Result: {}\\n\", action.result.format_message()));\n        }\n\n        memory\n    }\n\n    /// Prepare messages for LLM request - currently returns a single user message\n    /// but kept as Vec\u003cMessage\u003e for flexibility to change the format later\n    fn prepare_messages(\u0026self) -\u003e Vec\u003cMessage\u003e {\n        vec![Message {\n            role: MessageRole::User,\n            content: MessageContent::Text(self.render_working_memory()),\n        }]\n    }\n\n    /// Executes an action and returns the result\n    async fn execute_action(\u0026mut self, action: \u0026AgentAction) -\u003e Result\u003cActionResult\u003e {\n        debug!(\"Executing action: {:?}\", action.tool);\n\n        // Display the agent's reasoning\n        self.ui\n            .display(UIMessage::Reasoning(action.reasoning.clone()))\n            .await?;\n\n        let mut handler = AgentToolHandler::new(\u0026mut self.working_memory);\n\n        // Execute the tool and get both the output and result\n        let (output, tool_result) = ToolExecutor::execute(\n            \u0026mut handler,\n            Some(\u0026mut self.explorer),\n            \u0026self.command_executor,\n            Some(\u0026self.ui),\n            \u0026action.tool,\n        )\n        .await?;\n\n        // Display any tool output to the user\n        if !output.is_empty() {\n            self.ui.display(UIMessage::Action(output)).await?;\n        }\n\n        Ok(ActionResult {\n            tool: action.tool.clone(),\n            result: tool_result,\n            reasoning: action.reasoning.clone(),\n        })\n    }\n}\n\npub(crate) fn parse_llm_response(response: \u0026crate::llm::LLMResponse) -\u003e Result\u003cVec\u003cAgentAction\u003e\u003e {\n    let mut actions = Vec::new();\n\n    let mut reasoning = String::new();\n\n    for block in \u0026response.content {\n        if let ContentBlock::Text { text } = block {\n            let mut current_pos = 0;\n\n            while let Some(tool_start) = text[current_pos..].find(\u0026format!(\"\u003c{}\", TOOL_TAG_PREFIX))\n            {\n                let abs_start = current_pos + tool_start;\n\n                // Add text before tool to reasoning\n                reasoning.push_str(text[current_pos..abs_start].trim());\n                if !reasoning.is_empty() {\n                    reasoning.push('\\n');\n                }\n\n                // Find the root tag name\n                let tag_name = text[abs_start..]\n                    .split('\u003e')\n                    .next()\n                    .and_then(|s| s.strip_prefix('\u003c'))\n                    .ok_or_else(|| anyhow::anyhow!(\"Invalid XML: missing tag name\"))?;\n\n                // Only process tags with our tool prefix\n                if let Some(tool_name) = tag_name.strip_prefix(TOOL_TAG_PREFIX) {\n                    // Find closing tag for the root element\n                    let closing_tag = format!(\"\u003c/{}{}\u003e\", TOOL_TAG_PREFIX, tool_name);\n                    if let Some(rel_end) = text[abs_start..].find(\u0026closing_tag) {\n                        let abs_end = abs_start + rel_end + closing_tag.len();\n                        let tool_content = \u0026text[abs_start..abs_end];\n                        debug!(\"Found tool content:\\n{}\", tool_content);\n\n                        // Parse and add the tool action\n                        let tool = parse_tool_xml(tool_content)?;\n                        actions.push(AgentAction {\n                            tool,\n                            reasoning: remove_thinking_tags(reasoning.trim()).to_owned(),\n                        });\n\n                        current_pos = abs_end;\n                        continue;\n                    }\n                }\n\n                // If we get here, either the tag didn't have our prefix or we didn't find the closing tag\n                // In both cases, treat it as regular text\n                reasoning.push_str(\u0026text[abs_start..abs_start + 1]);\n                current_pos = abs_start + 1;\n            }\n\n            // Add any remaining text to reasoning\n            if current_pos \u003c text.len() {\n                reasoning.push_str(text[current_pos..].trim());\n            }\n        }\n\n        if let ContentBlock::ToolUse { name, input, .. } = block {\n            let tool = parse_tool_json(name, input)?;\n            actions.push(AgentAction {\n                tool,\n                reasoning: remove_thinking_tags(reasoning.trim()).to_owned(),\n            });\n            reasoning = String::new();\n        }\n    }\n\n    Ok(actions)\n}\n\nfn remove_thinking_tags(input: \u0026str) -\u003e \u0026str {\n    if input.starts_with(\"\u003cthinking\u003e\") \u0026\u0026 input.ends_with(\"\u003c/thinking\u003e\") {\n        \u0026input[10..input.len() - 11]\n    } else {\n        input\n    }\n}\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":8}},{"line":44,"address":[],"length":0,"stats":{"Line":8}},{"line":48,"address":[],"length":0,"stats":{"Line":8}},{"line":54,"address":[],"length":0,"stats":{"Line":16}},{"line":58,"address":[],"length":0,"stats":{"Line":18}},{"line":61,"address":[],"length":0,"stats":{"Line":18}},{"line":62,"address":[],"length":0,"stats":{"Line":32}},{"line":63,"address":[],"length":0,"stats":{"Line":44}},{"line":64,"address":[],"length":0,"stats":{"Line":22}},{"line":66,"address":[],"length":0,"stats":{"Line":22}},{"line":68,"address":[],"length":0,"stats":{"Line":54}},{"line":69,"address":[],"length":0,"stats":{"Line":22}},{"line":71,"address":[],"length":0,"stats":{"Line":22}},{"line":72,"address":[],"length":0,"stats":{"Line":4}},{"line":74,"address":[],"length":0,"stats":{"Line":4}},{"line":75,"address":[],"length":0,"stats":{"Line":4}},{"line":76,"address":[],"length":0,"stats":{"Line":4}},{"line":77,"address":[],"length":0,"stats":{"Line":4}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":4}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":18}},{"line":88,"address":[],"length":0,"stats":{"Line":18}},{"line":89,"address":[],"length":0,"stats":{"Line":18}},{"line":90,"address":[],"length":0,"stats":{"Line":18}},{"line":94,"address":[],"length":0,"stats":{"Line":18}},{"line":96,"address":[],"length":0,"stats":{"Line":8}},{"line":97,"address":[],"length":0,"stats":{"Line":8}},{"line":98,"address":[],"length":0,"stats":{"Line":8}},{"line":106,"address":[],"length":0,"stats":{"Line":16}},{"line":107,"address":[],"length":0,"stats":{"Line":8}},{"line":108,"address":[],"length":0,"stats":{"Line":8}},{"line":110,"address":[],"length":0,"stats":{"Line":8}},{"line":111,"address":[],"length":0,"stats":{"Line":8}},{"line":112,"address":[],"length":0,"stats":{"Line":8}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":16}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":8}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":22}},{"line":195,"address":[],"length":0,"stats":{"Line":22}},{"line":199,"address":[],"length":0,"stats":{"Line":22}},{"line":205,"address":[],"length":0,"stats":{"Line":52}},{"line":206,"address":[],"length":0,"stats":{"Line":56}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":22}},{"line":212,"address":[],"length":0,"stats":{"Line":22}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":44}},{"line":218,"address":[],"length":0,"stats":{"Line":22}},{"line":219,"address":[],"length":0,"stats":{"Line":22}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":22}},{"line":223,"address":[],"length":0,"stats":{"Line":110}},{"line":225,"address":[],"length":0,"stats":{"Line":22}},{"line":226,"address":[],"length":0,"stats":{"Line":22}},{"line":228,"address":[],"length":0,"stats":{"Line":22}},{"line":229,"address":[],"length":0,"stats":{"Line":22}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":22}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":44}},{"line":242,"address":[],"length":0,"stats":{"Line":22}},{"line":244,"address":[],"length":0,"stats":{"Line":22}},{"line":247,"address":[],"length":0,"stats":{"Line":18}},{"line":248,"address":[],"length":0,"stats":{"Line":18}},{"line":251,"address":[],"length":0,"stats":{"Line":18}},{"line":252,"address":[],"length":0,"stats":{"Line":36}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":18}},{"line":260,"address":[],"length":0,"stats":{"Line":18}},{"line":261,"address":[],"length":0,"stats":{"Line":18}},{"line":262,"address":[],"length":0,"stats":{"Line":36}},{"line":263,"address":[],"length":0,"stats":{"Line":6}},{"line":267,"address":[],"length":0,"stats":{"Line":18}},{"line":268,"address":[],"length":0,"stats":{"Line":18}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":18}},{"line":274,"address":[],"length":0,"stats":{"Line":42}},{"line":275,"address":[],"length":0,"stats":{"Line":12}},{"line":276,"address":[],"length":0,"stats":{"Line":12}},{"line":277,"address":[],"length":0,"stats":{"Line":12}},{"line":280,"address":[],"length":0,"stats":{"Line":18}},{"line":285,"address":[],"length":0,"stats":{"Line":18}},{"line":286,"address":[],"length":0,"stats":{"Line":18}},{"line":287,"address":[],"length":0,"stats":{"Line":18}},{"line":288,"address":[],"length":0,"stats":{"Line":18}},{"line":293,"address":[],"length":0,"stats":{"Line":44}},{"line":294,"address":[],"length":0,"stats":{"Line":22}},{"line":297,"address":[],"length":0,"stats":{"Line":22}},{"line":298,"address":[],"length":0,"stats":{"Line":22}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":22}},{"line":305,"address":[],"length":0,"stats":{"Line":22}},{"line":306,"address":[],"length":0,"stats":{"Line":22}},{"line":307,"address":[],"length":0,"stats":{"Line":22}},{"line":308,"address":[],"length":0,"stats":{"Line":22}},{"line":309,"address":[],"length":0,"stats":{"Line":22}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":22}},{"line":315,"address":[],"length":0,"stats":{"Line":21}},{"line":318,"address":[],"length":0,"stats":{"Line":22}},{"line":319,"address":[],"length":0,"stats":{"Line":22}},{"line":320,"address":[],"length":0,"stats":{"Line":22}},{"line":321,"address":[],"length":0,"stats":{"Line":22}},{"line":326,"address":[],"length":0,"stats":{"Line":24}},{"line":327,"address":[],"length":0,"stats":{"Line":24}},{"line":329,"address":[],"length":0,"stats":{"Line":24}},{"line":331,"address":[],"length":0,"stats":{"Line":116}},{"line":332,"address":[],"length":0,"stats":{"Line":24}},{"line":335,"address":[],"length":0,"stats":{"Line":28}},{"line":341,"address":[],"length":0,"stats":{"Line":2}},{"line":342,"address":[],"length":0,"stats":{"Line":2}},{"line":346,"address":[],"length":0,"stats":{"Line":2}},{"line":349,"address":[],"length":0,"stats":{"Line":2}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":2}},{"line":356,"address":[],"length":0,"stats":{"Line":2}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":4}},{"line":363,"address":[],"length":0,"stats":{"Line":2}},{"line":364,"address":[],"length":0,"stats":{"Line":2}},{"line":365,"address":[],"length":0,"stats":{"Line":2}},{"line":368,"address":[],"length":0,"stats":{"Line":2}},{"line":369,"address":[],"length":0,"stats":{"Line":2}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":46}},{"line":381,"address":[],"length":0,"stats":{"Line":22}},{"line":385,"address":[],"length":0,"stats":{"Line":68}},{"line":386,"address":[],"length":0,"stats":{"Line":22}},{"line":387,"address":[],"length":0,"stats":{"Line":22}},{"line":388,"address":[],"length":0,"stats":{"Line":22}},{"line":389,"address":[],"length":0,"stats":{"Line":22}},{"line":391,"address":[],"length":0,"stats":{"Line":22}},{"line":395,"address":[],"length":0,"stats":{"Line":24}},{"line":398,"address":[],"length":0,"stats":{"Line":24}},{"line":399,"address":[],"length":0,"stats":{"Line":24}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":24}}],"covered":124,"coverable":174},{"path":["/","Users","stippi","projects","code-assistant","src","agent","mod.rs"],"content":"#[cfg(test)]\nmod tests;\n\nmod agent;\n\npub use agent::Agent;\npub use agent::ToolMode;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","stippi","projects","code-assistant","src","agent","tests.rs"],"content":"use super::*;\nuse crate::agent::agent::parse_llm_response;\nuse crate::llm::{types::*, LLMProvider, LLMRequest, StreamingCallback};\nuse crate::persistence::MockStatePersistence;\nuse crate::types::*;\nuse crate::ui::{UIError, UIMessage, UserInterface};\nuse crate::utils::{CommandExecutor, CommandOutput};\nuse agent::ToolMode;\nuse anyhow::Result;\nuse async_trait::async_trait;\nuse regex::RegexBuilder;\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::sync::{Arc, Mutex};\n\n// Mock LLM Provider\n#[derive(Default, Clone)]\nstruct MockLLMProvider {\n    requests: Arc\u003cMutex\u003cVec\u003cLLMRequest\u003e\u003e\u003e,\n    responses: Arc\u003cMutex\u003cVec\u003cResult\u003cLLMResponse, anyhow::Error\u003e\u003e\u003e\u003e,\n}\n\nimpl MockLLMProvider {\n    fn new(mut responses: Vec\u003cResult\u003cLLMResponse, anyhow::Error\u003e\u003e) -\u003e Self {\n        // Add CompleteTask response at the beginning if the first response is ok\n        if responses.first().map_or(false, |r| r.is_ok()) {\n            responses.insert(\n                0,\n                Ok(create_test_response(\n                    Tool::CompleteTask {\n                        message: \"Task completed successfully\".to_string(),\n                    },\n                    \"Completing task after successful execution\",\n                )),\n            );\n        }\n\n        Self {\n            requests: Arc::new(Mutex::new(Vec::new())),\n            responses: Arc::new(Mutex::new(responses)),\n        }\n    }\n\n    pub fn print_requests(\u0026self) {\n        let requests = self.requests.lock().unwrap();\n        println!(\"\\nTotal number of requests: {}\", requests.len());\n        for (i, request) in requests.iter().enumerate() {\n            println!(\"\\nRequest {}:\", i);\n            for (j, message) in request.messages.iter().enumerate() {\n                println!(\"  Message {}:\", j);\n                if let MessageContent::Text(content) = \u0026message.content {\n                    println!(\"    {}\", content.replace('\\n', \"\\n    \"));\n                }\n            }\n        }\n    }\n\n    // // Helper method for tests that need specific completion handling\n    // fn new_with_custom_completion(\n    //     mut responses: Vec\u003cResult\u003cLLMResponse, anyhow::Error\u003e\u003e,\n    //     completion_message: Option\u003cString\u003e,\n    // ) -\u003e Self {\n    //     if let Some(msg) = completion_message {\n    //         responses.push(Ok(create_test_response(\n    //             Tool::CompleteTask { message: msg },\n    //             \"Custom completion message\",\n    //         )));\n    //     }\n\n    //     Self {\n    //         requests: Arc::new(Mutex::new(Vec::new())),\n    //         responses: Arc::new(Mutex::new(responses)),\n    //     }\n    // }\n}\n\n#[async_trait]\nimpl LLMProvider for MockLLMProvider {\n    async fn send_message(\n        \u0026self,\n        request: LLMRequest,\n        _streaming_callback: Option\u003c\u0026StreamingCallback\u003e,\n    ) -\u003e Result\u003cLLMResponse, anyhow::Error\u003e {\n        self.requests.lock().unwrap().push(request);\n        self.responses\n            .lock()\n            .unwrap()\n            .pop()\n            .unwrap_or(Err(anyhow::anyhow!(\"No more mock responses\")))\n    }\n}\n\n// Mock CommandExecutor\n#[derive(Clone)]\nstruct MockCommandExecutor {\n    responses: Arc\u003cMutex\u003cVec\u003cResult\u003cCommandOutput, anyhow::Error\u003e\u003e\u003e\u003e,\n    calls: Arc\u003cAtomicUsize\u003e,\n    captured_commands: Arc\u003cMutex\u003cVec\u003c(String, Option\u003cPathBuf\u003e)\u003e\u003e\u003e,\n}\n\nimpl MockCommandExecutor {\n    fn new(responses: Vec\u003cResult\u003cCommandOutput, anyhow::Error\u003e\u003e) -\u003e Self {\n        Self {\n            responses: Arc::new(Mutex::new(responses)),\n            calls: Arc::new(AtomicUsize::new(0)),\n            captured_commands: Arc::new(Mutex::new(Vec::new())),\n        }\n    }\n\n    fn get_captured_commands(\u0026self) -\u003e Vec\u003c(String, Option\u003cPathBuf\u003e)\u003e {\n        self.captured_commands.lock().unwrap().clone()\n    }\n}\n\n#[async_trait::async_trait]\nimpl CommandExecutor for MockCommandExecutor {\n    async fn execute(\n        \u0026self,\n        command_line: \u0026str,\n        working_dir: Option\u003c\u0026PathBuf\u003e,\n    ) -\u003e Result\u003cCommandOutput\u003e {\n        self.calls.fetch_add(1, Ordering::Relaxed);\n        self.captured_commands\n            .lock()\n            .unwrap()\n            .push((command_line.to_string(), working_dir.cloned()));\n\n        self.responses\n            .lock()\n            .unwrap()\n            .pop()\n            .unwrap_or(Err(anyhow::anyhow!(\"No more mock responses\")))\n    }\n}\n\n// Mock UI\n#[derive(Default, Clone)]\nstruct MockUI {\n    messages: Arc\u003cMutex\u003cVec\u003cUIMessage\u003e\u003e\u003e,\n    streaming: Arc\u003cMutex\u003cVec\u003cString\u003e\u003e\u003e,\n    responses: Arc\u003cMutex\u003cVec\u003cResult\u003cString, UIError\u003e\u003e\u003e\u003e,\n}\n\nimpl MockUI {\n    fn new(responses: Vec\u003cResult\u003cString, UIError\u003e\u003e) -\u003e Self {\n        Self {\n            messages: Arc::new(Mutex::new(Vec::new())),\n            streaming: Arc::new(Mutex::new(Vec::new())),\n            responses: Arc::new(Mutex::new(responses)),\n        }\n    }\n\n    fn get_messages(\u0026self) -\u003e Vec\u003cUIMessage\u003e {\n        self.messages.lock().unwrap().clone()\n    }\n}\n\n#[async_trait]\nimpl UserInterface for MockUI {\n    async fn display(\u0026self, message: UIMessage) -\u003e Result\u003c(), UIError\u003e {\n        self.messages.lock().unwrap().push(message);\n        Ok(())\n    }\n\n    async fn get_input(\u0026self, _prompt: \u0026str) -\u003e Result\u003cString, UIError\u003e {\n        self.responses\n            .lock()\n            .unwrap()\n            .pop()\n            .unwrap_or(Err(UIError::IOError(std::io::Error::new(\n                std::io::ErrorKind::Other,\n                \"No more mock responses\",\n            ))))\n    }\n\n    fn display_streaming(\u0026self, text: \u0026str) -\u003e Result\u003c(), UIError\u003e {\n        self.streaming.lock().unwrap().push(text.to_string());\n        Ok(())\n    }\n}\n\n// Mock Explorer\n#[derive(Default)]\nstruct MockExplorer {\n    files: Arc\u003cMutex\u003cHashMap\u003cPathBuf, String\u003e\u003e\u003e,\n    file_tree: Arc\u003cMutex\u003cOption\u003cFileTreeEntry\u003e\u003e\u003e,\n}\n\nimpl MockExplorer {\n    pub fn new(files: HashMap\u003cPathBuf, String\u003e, file_tree: Option\u003cFileTreeEntry\u003e) -\u003e Self {\n        Self {\n            files: Arc::new(Mutex::new(files)),\n            file_tree: Arc::new(Mutex::new(file_tree)),\n        }\n    }\n}\n\nimpl CodeExplorer for MockExplorer {\n    fn root_dir(\u0026self) -\u003e PathBuf {\n        PathBuf::from(\"./root\")\n    }\n\n    fn read_file(\u0026self, path: \u0026PathBuf) -\u003e Result\u003cString, anyhow::Error\u003e {\n        self.files\n            .lock()\n            .unwrap()\n            .get(path)\n            .cloned()\n            .ok_or_else(|| anyhow::anyhow!(\"File not found: {}\", path.display()))\n    }\n\n    fn write_file(\u0026self, path: \u0026PathBuf, content: \u0026String) -\u003e Result\u003c()\u003e {\n        // Check parent directories\n        for component in path.parent().unwrap_or(path).components() {\n            let current = PathBuf::from(component.as_os_str());\n            if let Some(_) = self.files.lock().unwrap().get(\u0026current) {\n                // If any parent is a file (has content), that's an error\n                return Err(anyhow::anyhow!(\n                    \"Cannot create file: {} is a file\",\n                    current.display()\n                ));\n            }\n        }\n\n        let mut files = self.files.lock().unwrap();\n        files.insert(path.to_path_buf(), content.clone());\n        Ok(())\n    }\n\n    fn delete_file(\u0026self, path: \u0026PathBuf) -\u003e Result\u003c()\u003e {\n        let mut files = self.files.lock().unwrap();\n        files.remove(path);\n        Ok(())\n    }\n\n    fn create_initial_tree(\u0026mut self, _max_depth: usize) -\u003e Result\u003cFileTreeEntry, anyhow::Error\u003e {\n        self.file_tree\n            .lock()\n            .unwrap()\n            .clone()\n            .ok_or_else(|| anyhow::anyhow!(\"No file tree configured\"))\n    }\n\n    fn list_files(\n        \u0026mut self,\n        path: \u0026PathBuf,\n        _max_depth: Option\u003cusize\u003e,\n    ) -\u003e Result\u003cFileTreeEntry, anyhow::Error\u003e {\n        let file_tree = self.file_tree.lock().unwrap();\n        let root = file_tree\n            .as_ref()\n            .ok_or_else(|| anyhow::anyhow!(\"No file tree configured\"))?;\n\n        // Handle request for root\n        if path == \u0026PathBuf::from(\"./root\") {\n            return Ok(root.clone());\n        }\n\n        // Handle relative paths from root\n        if let Some(rel_path) = path.strip_prefix(\"./root/\").ok() {\n            let mut current = root;\n            for component in rel_path.components() {\n                if let Some(name) = component.as_os_str().to_str() {\n                    current = current\n                        .children\n                        .get(name)\n                        .ok_or_else(|| anyhow::anyhow!(\"Path not found: {}\", path.display()))?;\n                }\n            }\n            return Ok(current.clone());\n        }\n\n        // Handle paths without ./root prefix\n        let path_str = path\n            .to_str()\n            .ok_or_else(|| anyhow::anyhow!(\"Invalid path: {}\", path.display()))?;\n        let entry = root\n            .children\n            .get(path_str)\n            .ok_or_else(|| anyhow::anyhow!(\"Path not found: {}\", path.display()))?;\n\n        Ok(entry.clone())\n    }\n\n    fn apply_replacements(\u0026self, path: \u0026Path, replacements: \u0026[FileReplacement]) -\u003e Result\u003cString\u003e {\n        let mut files = self.files.lock().unwrap();\n\n        let content = files\n            .get(path)\n            .ok_or_else(|| anyhow::anyhow!(\"File not found: {}\", path.display()))?\n            .clone();\n\n        let updated_content = crate::utils::apply_replacements(\u0026content, replacements)?;\n\n        // Update the stored content\n        files.insert(path.to_path_buf(), updated_content.clone());\n\n        Ok(updated_content)\n    }\n\n    fn search(\n        \u0026self,\n        path: \u0026Path,\n        options: SearchOptions,\n    ) -\u003e Result\u003cVec\u003cSearchResult\u003e, anyhow::Error\u003e {\n        let files = self.files.lock().unwrap();\n        let max_results = options.max_results.unwrap_or(usize::MAX);\n        let mut results = Vec::new();\n\n        // Create regex based on search mode\n        let regex = match options.mode {\n            SearchMode::Exact =\u003e {\n                // For exact search, escape regex special characters and optionally add word boundaries\n                let pattern = if options.whole_words {\n                    format!(r\"\\b{}\\b\", regex::escape(\u0026options.query))\n                } else {\n                    regex::escape(\u0026options.query)\n                };\n                RegexBuilder::new(\u0026pattern)\n                    .case_insensitive(!options.case_sensitive)\n                    .build()?\n            }\n            SearchMode::Regex =\u003e {\n                // For regex search, optionally add word boundaries to user's pattern\n                let pattern = if options.whole_words {\n                    format!(r\"\\b{}\\b\", options.query)\n                } else {\n                    options.query.clone()\n                };\n                RegexBuilder::new(\u0026pattern)\n                    .case_insensitive(!options.case_sensitive)\n                    .build()?\n            }\n        };\n\n        for (file_path, content) in files.iter() {\n            // Only search files under the specified path\n            if !file_path.starts_with(path) {\n                continue;\n            }\n\n            for (line_idx, line) in content.lines().enumerate() {\n                let matches: Vec\u003c_\u003e = regex.find_iter(line).collect();\n                if !matches.is_empty() {\n                    let context_lines = 2;\n                    let start_line = line_idx.saturating_sub(context_lines);\n                    let section_end = (line_idx + context_lines + 1).min(content.lines().count());\n\n                    let mut section_lines = Vec::new();\n                    for i in start_line..section_end {\n                        section_lines.push(content.lines().nth(i).unwrap().to_string());\n                    }\n\n                    results.push(SearchResult {\n                        file: file_path.clone(),\n                        start_line,\n                        line_content: section_lines,\n                        match_lines: vec![line_idx - start_line],\n                        match_ranges: vec![matches.iter().map(|m| (m.start(), m.end())).collect()],\n                    });\n\n                    if results.len() \u003e= max_results {\n                        return Ok(results);\n                    }\n                }\n            }\n        }\n\n        Ok(results)\n    }\n}\n\n// Helper function to create a test response\nfn create_test_response(tool: Tool, reasoning: \u0026str) -\u003e LLMResponse {\n    let tool_name = match \u0026tool {\n        Tool::ListProjects { .. } =\u003e \"list_projects\",\n        Tool::OpenProject { .. } =\u003e \"open_project\",\n        Tool::SearchFiles { .. } =\u003e \"search_files\",\n        Tool::ExecuteCommand { .. } =\u003e \"execute_command\",\n        Tool::ListFiles { .. } =\u003e \"list_files\",\n        Tool::ReadFiles { .. } =\u003e \"read_files\",\n        Tool::WriteFile { .. } =\u003e \"write_file\",\n        Tool::ReplaceInFile { .. } =\u003e \"replace_in_file\",\n        Tool::DeleteFiles { .. } =\u003e \"delete_files\",\n        Tool::Summarize { .. } =\u003e \"summarize\",\n        Tool::AskUser { .. } =\u003e \"ask_user\",\n        Tool::MessageUser { .. } =\u003e \"message_user\",\n        Tool::CompleteTask { .. } =\u003e \"complete_task\",\n    };\n    let tool_input = match \u0026tool {\n        Tool::ListProjects {} =\u003e serde_json::json!({}),\n        Tool::OpenProject { name } =\u003e serde_json::json!({\n            \"name\": name\n        }),\n        Tool::SearchFiles {\n            query,\n            path,\n            case_sensitive,\n            whole_words,\n            regex_mode,\n            max_results,\n        } =\u003e serde_json::json!({\n            \"query\": query,\n            \"path\": path,\n            \"case_sensitive\": case_sensitive,\n            \"whole_words\": whole_words,\n            \"regex_mode\": regex_mode,\n            \"max_results\": max_results\n        }),\n        Tool::ExecuteCommand {\n            command_line,\n            working_dir,\n        } =\u003e serde_json::json!({\n            \"command_line\": command_line,\n            \"working_dir\": working_dir\n        }),\n        Tool::ListFiles { paths, max_depth } =\u003e {\n            let mut map = serde_json::Map::new();\n            map.insert(\"paths\".to_string(), serde_json::json!(paths));\n            if let Some(depth) = max_depth {\n                map.insert(\"max_depth\".to_string(), serde_json::json!(depth));\n            }\n            serde_json::Value::Object(map)\n        }\n        Tool::ReadFiles { paths } =\u003e serde_json::json!({\n            \"paths\": paths\n        }),\n        Tool::WriteFile { path, content } =\u003e serde_json::json!({\n            \"path\": path,\n            \"content\": content\n        }),\n        Tool::ReplaceInFile { path, replacements } =\u003e serde_json::json!({\n            \"path\": path,\n            \"replacements\": replacements\n        }),\n        Tool::DeleteFiles { paths } =\u003e serde_json::json!({\n            \"paths\": paths\n        }),\n        Tool::Summarize { files } =\u003e serde_json::json!({\n            \"files\": files.iter().map(|(path, summary)| {\n                serde_json::json!({\n                    \"path\": path,\n                    \"summary\": summary\n                })\n            }).collect::\u003cVec\u003c_\u003e\u003e()\n        }),\n        Tool::AskUser { question } =\u003e serde_json::json!({\n            \"question\": question\n        }),\n        Tool::MessageUser { message } =\u003e serde_json::json!({\n            \"message\": message\n        }),\n        Tool::CompleteTask { message } =\u003e serde_json::json!({\n            \"message\": message\n        }),\n    };\n\n    LLMResponse {\n        content: vec![\n            ContentBlock::Text {\n                text: reasoning.to_string(),\n            },\n            ContentBlock::ToolUse {\n                id: \"some-tool-id\".to_string(),\n                name: tool_name.to_string(),\n                input: tool_input,\n            },\n        ],\n        usage: Usage {\n            input_tokens: 0,\n            output_tokens: 0,\n        },\n    }\n}\n\nfn create_explorer_mock() -\u003e MockExplorer {\n    let mut files = HashMap::new();\n    files.insert(\n        PathBuf::from(\"./root/test.txt\"),\n        \"line 1\\nline 2\\nline 3\\n\".to_string(),\n    );\n\n    // Add src directory to tree\n    let mut root_children = HashMap::new();\n    root_children.insert(\n        \"src\".to_string(),\n        FileTreeEntry {\n            name: \"src\".to_string(),\n            entry_type: FileSystemEntryType::Directory,\n            children: HashMap::new(),\n            is_expanded: true,\n        },\n    );\n\n    let file_tree = Some(FileTreeEntry {\n        name: \"./root\".to_string(),\n        entry_type: FileSystemEntryType::Directory,\n        children: root_children,\n        is_expanded: true,\n    });\n\n    MockExplorer::new(files, file_tree)\n}\n\nfn create_command_executor_mock() -\u003e MockCommandExecutor {\n    MockCommandExecutor::new(vec![])\n}\n\n#[test]\nfn test_mock_explorer_search() -\u003e Result\u003c(), anyhow::Error\u003e {\n    let mut files = HashMap::new();\n    files.insert(\n        PathBuf::from(\"./root/test1.txt\"),\n        \"line 1\\nline 2\\nline 3\\n\".to_string(),\n    );\n    files.insert(\n        PathBuf::from(\"./root/test2.txt\"),\n        \"another line\\nmatching line\\n\".to_string(),\n    );\n    files.insert(\n        PathBuf::from(\"./root/subdir/test3.txt\"),\n        \"subdir line\\nmatching line\\n\".to_string(),\n    );\n\n    let explorer = MockExplorer::new(files, None);\n\n    // Test basic search\n    let results = explorer.search(\n        \u0026PathBuf::from(\"./root\"),\n        SearchOptions {\n            query: \"matching\".to_string(),\n            ..Default::default()\n        },\n    )?;\n    assert_eq!(results.len(), 2);\n    assert!(results.iter().any(|r| r.file.ends_with(\"test2.txt\")));\n    assert!(results.iter().any(|r| r.file.ends_with(\"test3.txt\")));\n\n    // Test case-sensitive search\n    let results = explorer.search(\n        \u0026PathBuf::from(\"./root\"),\n        SearchOptions {\n            query: \"LINE\".to_string(),\n            case_sensitive: true,\n            ..Default::default()\n        },\n    )?;\n    assert_eq!(results.len(), 0); // Should find nothing with case-sensitive search\n\n    // Test case-insensitive search\n    let results = explorer.search(\n        \u0026PathBuf::from(\"./root\"),\n        SearchOptions {\n            query: \"LINE\".to_string(),\n            case_sensitive: false,\n            ..Default::default()\n        },\n    )?;\n    assert!(results.len() \u003e 0); // Should find matches\n\n    // Test whole word search\n    let results = explorer.search(\n        \u0026PathBuf::from(\"./root\"),\n        SearchOptions {\n            query: \"line\".to_string(),\n            whole_words: true,\n            ..Default::default()\n        },\n    )?;\n    // When searching for whole words, matches should not be part of other words\n    assert!(results.iter().all(|r| {\n        r.line_content.iter().all(|line| {\n            // Check that \"line\" is not part of another word\n            !line.contains(\u0026\"inline\".to_string())\n                \u0026\u0026 !line.contains(\u0026\"pipeline\".to_string())\n                \u0026\u0026 !line.contains(\u0026\"airline\".to_string())\n        })\n    }));\n\n    // Test regex mode\n    let results = explorer.search(\n        \u0026PathBuf::from(\"./root\"),\n        SearchOptions {\n            query: r\"line \\d\".to_string(),\n            mode: SearchMode::Regex,\n            ..Default::default()\n        },\n    )?;\n    assert!(results.iter().any(|r| r\n        .line_content\n        .iter()\n        .any(|line| line.contains(\u0026\"line 1\".to_string()))));\n\n    // Test regex search\n    let results = explorer.search(\n        \u0026PathBuf::from(\"./root\"),\n        SearchOptions {\n            query: r\"line \\d+\".to_string(), // Match \"line\" followed by numbers\n            mode: SearchMode::Regex,\n            ..Default::default()\n        },\n    )?;\n    assert!(results.iter().any(|r| r\n        .line_content\n        .iter()\n        .any(|line| line.contains(\u0026\"line 1\".to_string()))));\n\n    // Test with max_results\n    let results = explorer.search(\n        \u0026PathBuf::from(\"./root\"),\n        SearchOptions {\n            query: \"line\".to_string(),\n            max_results: Some(2),\n            ..Default::default()\n        },\n    )?;\n    assert_eq!(results.len(), 2);\n\n    // Test search in subdirectory\n    let results = explorer.search(\n        \u0026PathBuf::from(\"./root/subdir\"),\n        SearchOptions {\n            query: \"subdir\".to_string(),\n            ..Default::default()\n        },\n    )?;\n    assert_eq!(results.len(), 1);\n    assert!(results[0].file.ends_with(\"test3.txt\"));\n\n    // Test search with no matches\n    let results = explorer.search(\n        \u0026PathBuf::from(\"./root\"),\n        SearchOptions {\n            query: \"nonexistent\".to_string(),\n            ..Default::default()\n        },\n    )?;\n    assert_eq!(results.len(), 0);\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_agent_start_with_message() -\u003e Result\u003c(), anyhow::Error\u003e {\n    // Prepare test data\n    let test_message = \"Test message for user\";\n    let test_reasoning = \"Dummy reason\";\n    let tool = Tool::MessageUser {\n        message: test_message.to_string(),\n    };\n\n    let mock_llm = MockLLMProvider::new(vec![Ok(create_test_response(tool, test_reasoning))]);\n\n    let mock_ui = MockUI::default();\n\n    let mut agent = Agent::new(\n        Box::new(mock_llm),\n        ToolMode::Native,\n        Box::new(create_explorer_mock()),\n        Box::new(create_command_executor_mock()),\n        Box::new(mock_ui.clone()),\n        Box::new(MockStatePersistence::new()),\n    );\n\n    // Run the agent\n    agent.start_with_task(\"Test task\".to_string()).await?;\n\n    // Verify the message was displayed\n    let messages = mock_ui.get_messages();\n    assert!(!messages.is_empty());\n\n    // First message is about creating repository structure\n    if let UIMessage::Reasoning(msg) = \u0026messages[1] {\n        assert!(msg.contains(test_reasoning));\n    } else {\n        panic!(\"Expected UIMessage::Reasoning\");\n    }\n\n    if let UIMessage::Action(msg) = \u0026messages[2] {\n        assert!(msg.contains(test_message));\n    } else {\n        panic!(\"Expected UIMessage::Action\");\n    }\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_agent_ask_user() -\u003e Result\u003c(), anyhow::Error\u003e {\n    // Prepare test data\n    let test_question = \"Test question?\";\n    let test_answer = \"Test answer\";\n\n    let mock_llm = MockLLMProvider::new(vec![Ok(create_test_response(\n        Tool::AskUser {\n            question: test_question.to_string(),\n        },\n        \"Need to ask user a question\",\n    ))]);\n\n    let mock_ui = MockUI::new(vec![Ok(test_answer.to_string())]);\n\n    let mut agent = Agent::new(\n        Box::new(mock_llm),\n        ToolMode::Native,\n        Box::new(create_explorer_mock()),\n        Box::new(create_command_executor_mock()),\n        Box::new(mock_ui.clone()),\n        Box::new(MockStatePersistence::new()),\n    );\n\n    // Run the agent\n    agent.start_with_task(\"Test task\".to_string()).await?;\n\n    // Verify the question was asked\n    let messages = mock_ui.get_messages();\n    assert!(messages.iter().any(|msg| match msg {\n        UIMessage::Question(q) =\u003e q == test_question,\n        _ =\u003e false,\n    }));\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_agent_read_files() -\u003e Result\u003c(), anyhow::Error\u003e {\n    // Test success case\n    let mock_llm = MockLLMProvider::new(vec![\n        // Responses in reverse order\n        Ok(create_test_response(\n            Tool::MessageUser {\n                message: (String::from(\"Done\")),\n            },\n            \"Dummy reason\",\n        )),\n        Ok(create_test_response(\n            Tool::ReadFiles {\n                paths: vec![PathBuf::from(\"test.txt\")],\n            },\n            \"Reading test file\",\n        )),\n    ]);\n    // Obtain a reference to the mock_llm before handing ownership to the agent\n    let mock_llm_ref = mock_llm.clone();\n\n    let mut agent = Agent::new(\n        Box::new(mock_llm),\n        ToolMode::Native,\n        Box::new(create_explorer_mock()),\n        Box::new(create_command_executor_mock()),\n        Box::new(MockUI::default()),\n        Box::new(MockStatePersistence::new()),\n    );\n\n    // Run the agent\n    agent.start_with_task(\"Test task\".to_string()).await?;\n\n    // Verify the file is displayed in the working memory of the second request\n    let locked_requests = mock_llm_ref.requests.lock().unwrap();\n    let second_request = \u0026locked_requests[1];\n\n    if let MessageContent::Text(content) = \u0026second_request.messages[0].content {\n        assert!(\n            content.contains(\n                \"Loaded files and their contents:\\n\\n-----test.txt:\\nline 1\\nline 2\\nline 3\\n\"\n            ),\n            \"File content not found in working memory message:\\n{}\",\n            content\n        );\n    } else {\n        panic!(\"Expected text content in message\");\n    }\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_execute_command() -\u003e Result\u003c()\u003e {\n    let test_output = CommandOutput {\n        success: true,\n        stdout: \"command output\".to_string(),\n        stderr: \"\".to_string(),\n    };\n\n    let mock_command_executor = MockCommandExecutor::new(vec![Ok(test_output)]);\n    let mock_command_executor_ref = mock_command_executor.clone();\n\n    let mock_llm = MockLLMProvider::new(vec![Ok(create_test_response(\n        Tool::ExecuteCommand {\n            command_line: \"test command\".to_string(),\n            working_dir: None,\n        },\n        \"Testing command execution\",\n    ))]);\n\n    let mut agent = Agent::new(\n        Box::new(mock_llm),\n        ToolMode::Native,\n        Box::new(create_explorer_mock()),\n        Box::new(mock_command_executor),\n        Box::new(MockUI::default()),\n        Box::new(MockStatePersistence::new()),\n    );\n\n    // Run the agent\n    agent.start_with_task(\"Test task\".to_string()).await?;\n\n    // Verify number of calls and command parameters\n    assert_eq!(mock_command_executor_ref.calls.load(Ordering::Relaxed), 1);\n\n    let captured_commands = mock_command_executor_ref.get_captured_commands();\n    assert_eq!(captured_commands.len(), 1);\n    assert_eq!(captured_commands[0].0, \"test command\");\n    assert_eq!(\n        captured_commands[0].1.as_ref().map(|p| p.to_str().unwrap()),\n        Some(\"./root\")\n    );\n\n    Ok(())\n}\n\n#[test]\nfn test_flexible_xml_parsing() -\u003e Result\u003c()\u003e {\n    let response = LLMResponse {\n        content: vec![ContentBlock::Text {\n            text: r#\"I will search for TODO comments in the code.\n\n\u003ctool:search_files\u003e\n\u003cparam:query\u003eTODO \u0026 FIXME \u003chtml\u003e\u003c/param:query\u003e\n\u003cparam:path\u003esrc/\u003c/param:path\u003e\n\u003cparam:case_sensitive\u003etrue\u003c/param:case_sensitive\u003e\n\u003cparam:max_results\u003e\n    50\n\u003c/param:max_results\u003e\n\u003c/tool:search_files\u003e\"#\n                .to_string(),\n        }],\n        usage: Usage {\n            input_tokens: 0,\n            output_tokens: 0,\n        },\n    };\n\n    let actions = parse_llm_response(\u0026response)?;\n    assert_eq!(actions.len(), 1);\n    assert!(actions[0].reasoning.contains(\"search for TODO comments\"));\n\n    if let Tool::SearchFiles {\n        query, max_results, ..\n    } = \u0026actions[0].tool\n    {\n        assert_eq!(query, \"TODO \u0026 FIXME \u003chtml\u003e\"); // Notice the \u0026 character is allowed and also tags\n        assert_eq!(*max_results, Some(50));\n    } else {\n        panic!(\"Expected Search tool\");\n    }\n\n    Ok(())\n}\n\n#[test]\nfn test_replacement_xml_parsing() -\u003e Result\u003c()\u003e {\n    let response = LLMResponse {\n        content: vec![ContentBlock::Text {\n            text: r#\"I will fix the code formatting.\n\n\u003ctool:replace_in_file\u003e\n\u003cparam:path\u003esrc/main.rs\u003c/param:path\u003e\n\u003cparam:diff\u003e\n\u003c\u003c\u003c\u003c\u003c\u003c\u003c SEARCH\nfunction test(){\n  console.log(\"messy\");\n}\n=======\nfunction test() {\n    console.log(\"clean\");\n}\n\u003e\u003e\u003e\u003e\u003e\u003e\u003e REPLACE\n\n\u003c\u003c\u003c\u003c\u003c\u003c\u003c SEARCH\nconst x=42\n=======\nconst x = 42;\n\u003e\u003e\u003e\u003e\u003e\u003e\u003e REPLACE\n\u003c/param:diff\u003e\n\u003c/tool:replace_in_file\u003e\"#\n                .to_string(),\n        }],\n        usage: Usage {\n            input_tokens: 0,\n            output_tokens: 0,\n        },\n    };\n\n    let actions = parse_llm_response(\u0026response)?;\n    assert_eq!(actions.len(), 1);\n    assert!(actions[0].reasoning.contains(\"fix the code formatting\"));\n\n    if let Tool::ReplaceInFile { path, replacements } = \u0026actions[0].tool {\n        assert_eq!(path, \u0026PathBuf::from(\"src/main.rs\"));\n        assert_eq!(replacements.len(), 2);\n        assert_eq!(\n            replacements[0].search,\n            \"function test(){\\n  console.log(\\\"messy\\\");\\n}\"\n        );\n        assert_eq!(\n            replacements[0].replace,\n            \"function test() {\\n    console.log(\\\"clean\\\");\\n}\"\n        );\n        assert_eq!(replacements[1].search, \"const x=42\");\n        assert_eq!(replacements[1].replace, \"const x = 42;\");\n    } else {\n        panic!(\"Expected ReplaceInFile tool\");\n    }\n\n    Ok(())\n}\n\n#[test]\nfn test_apply_replacements() -\u003e Result\u003c(), anyhow::Error\u003e {\n    let mut files = HashMap::new();\n    files.insert(\n        PathBuf::from(\"./root/test.txt\"),\n        \"Hello World\\nThis is a test\\nGoodbye\".to_string(),\n    );\n\n    let explorer = MockExplorer::new(files, None);\n\n    let replacements = vec![\n        FileReplacement {\n            search: \"Hello World\".to_string(),\n            replace: \"Hi there\".to_string(),\n        },\n        FileReplacement {\n            search: \"Goodbye\".to_string(),\n            replace: \"See you\".to_string(),\n        },\n    ];\n\n    let result = explorer.apply_replacements(\u0026PathBuf::from(\"./root/test.txt\"), \u0026replacements)?;\n\n    assert_eq!(result, \"Hi there\\nThis is a test\\nSee you\");\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_replace_in_file_error_handling() -\u003e Result\u003c()\u003e {\n    // Setup a scenario where a file replacement fails first (wrong search string),\n    // then succeeds with corrected search string\n    let initial_content = \"function test() {\\n    console.log(\\\"test\\\");\\n}\\n\";\n\n    // First a read action to get the file into working memory\n    let mock_llm = MockLLMProvider::new(vec![\n        Ok(create_test_response(\n            Tool::ReplaceInFile {\n                path: PathBuf::from(\"test.rs\"),\n                replacements: vec![FileReplacement {\n                    search: \"function test()\".to_string(), // correct\n                    replace: \"fn test()\".to_string(),\n                }],\n            },\n            \"Trying with correct search string\",\n        )),\n        Ok(create_test_response(\n            Tool::ReplaceInFile {\n                path: PathBuf::from(\"test.rs\"),\n                replacements: vec![FileReplacement {\n                    search: \"wrong search\".to_string(), // will fail\n                    replace: \"fn test()\".to_string(),\n                }],\n            },\n            \"Initial attempt to replace\",\n        )),\n        Ok(create_test_response(\n            Tool::ReadFiles {\n                paths: vec![PathBuf::from(\"test.rs\")],\n            },\n            \"Reading test file\",\n        )),\n    ]);\n    let mock_llm_ref = mock_llm.clone();\n\n    // File exists and has content\n    let mock_explorer = MockExplorer::new(\n        HashMap::from([(PathBuf::from(\"./root/test.rs\"), initial_content.to_string())]),\n        Some(FileTreeEntry {\n            name: \"./root\".to_string(),\n            entry_type: FileSystemEntryType::Directory,\n            children: HashMap::new(),\n            is_expanded: true,\n        }),\n    );\n\n    let mut agent = Agent::new(\n        Box::new(mock_llm),\n        ToolMode::Native,\n        Box::new(mock_explorer),\n        Box::new(create_command_executor_mock()),\n        Box::new(MockUI::default()),\n        Box::new(MockStatePersistence::new()),\n    );\n\n    // Run the agent\n    agent\n        .start_with_task(\"Convert JavaScript function to Rust\".to_string())\n        .await?;\n\n    // Check that error was communicated to LLM\n    let requests = mock_llm_ref.requests.lock().unwrap();\n\n    // Should see four requests:\n    // 1. Initial ReadFiles\n    // 2. Failed ReplaceInFile\n    // 3. Corrected ReplaceInFile\n    // 4. CompleteTask\n    assert_eq!(requests.len(), 4);\n\n    // The error message should be a user message in the third request\n    let error_request = \u0026requests[2];\n    assert_eq!(error_request.messages.len(), 3); // Working Memory + Tool Response + Error\n    if let MessageContent::Text(content) = \u0026error_request.messages[2].content {\n        assert!(\n            content.contains(\"Could not find search content\"),\n            \"Expected error message about missing search content, got:\\n{}\",\n            content\n        );\n    } else {\n        panic!(\"Expected error message to be text content\");\n    }\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_list_files_error_handling() -\u003e Result\u003c()\u003e {\n    let mock_llm = MockLLMProvider::new(vec![\n        Ok(create_test_response(\n            Tool::ListFiles {\n                paths: vec![PathBuf::from(\"src\")],\n                max_depth: None,\n            },\n            \"Listing files with correct path\",\n        )),\n        Ok(create_test_response(\n            Tool::ListFiles {\n                paths: vec![PathBuf::from(\"nonexistent\")],\n                max_depth: None,\n            },\n            \"Initial attempt to list files\",\n        )),\n    ]);\n    let mock_llm_ref = mock_llm.clone();\n\n    let mut agent = Agent::new(\n        Box::new(mock_llm),\n        ToolMode::Native,\n        Box::new(create_explorer_mock()),\n        Box::new(create_command_executor_mock()),\n        Box::new(MockUI::default()),\n        Box::new(MockStatePersistence::new()),\n    );\n\n    agent\n        .start_with_task(\"List project files\".to_string())\n        .await?;\n\n    let requests = mock_llm_ref.requests.lock().unwrap();\n\n    // Should see three requests:\n    // 1. Failed ListFiles\n    // 2. Corrected ListFiles\n    // 3. CompleteTask\n    assert_eq!(requests.len(), 3);\n\n    // The error message should be a user message in the second request\n    let error_request = \u0026requests[1];\n    assert_eq!(error_request.messages.len(), 3); // Working Memory + Tool Response + Error\n    if let MessageContent::Text(content) = \u0026error_request.messages[2].content {\n        println!(\"{}\", content);\n        assert!(content.contains(\"Error executing action\"));\n        assert!(content.contains(\"Path not found\"));\n    }\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_read_files_error_handling() -\u003e Result\u003c()\u003e {\n    let mock_llm = MockLLMProvider::new(vec![\n        Ok(create_test_response(\n            Tool::ReadFiles {\n                paths: vec![PathBuf::from(\"test.txt\")],\n            },\n            \"Reading existing file\",\n        )),\n        Ok(create_test_response(\n            Tool::ReadFiles {\n                paths: vec![PathBuf::from(\"nonexistent.txt\")],\n            },\n            \"Attempting to read non-existent file\",\n        )),\n    ]);\n    let mock_llm_ref = mock_llm.clone();\n\n    let mut agent = Agent::new(\n        Box::new(mock_llm),\n        ToolMode::Native,\n        Box::new(create_explorer_mock()),\n        Box::new(create_command_executor_mock()),\n        Box::new(MockUI::default()),\n        Box::new(MockStatePersistence::new()),\n    );\n\n    agent\n        .start_with_task(\"Read file contents\".to_string())\n        .await?;\n\n    let requests = mock_llm_ref.requests.lock().unwrap();\n\n    // Should see three requests:\n    // 1. Failed ReadFiles\n    // 2. Corrected ReadFiles\n    // 3. CompleteTask\n    assert_eq!(requests.len(), 3);\n\n    // The error message should be a user message in the second request\n    let error_request = \u0026requests[1];\n    assert_eq!(error_request.messages.len(), 3); // Working Memory + Tool Response + Error\n    if let MessageContent::Text(content) = \u0026error_request.messages[2].content {\n        assert!(content.contains(\"Error executing action\"));\n        assert!(content.contains(\"File not found\"));\n    }\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_write_file_error_handling() -\u003e Result\u003c()\u003e {\n    let mock_llm = MockLLMProvider::new(vec![\n        Ok(create_test_response(\n            Tool::WriteFile {\n                path: PathBuf::from(\"test.txt\"),\n                content: \"valid content\".to_string(),\n            },\n            \"Writing to valid path\",\n        )),\n        Ok(create_test_response(\n            Tool::WriteFile {\n                path: PathBuf::from(\"/invalid/path/test.txt\"),\n                content: \"test content\".to_string(),\n            },\n            \"Attempting to write to invalid absolute path\",\n        )),\n    ]);\n    let mock_llm_ref = mock_llm.clone();\n\n    let mut agent = Agent::new(\n        Box::new(mock_llm),\n        ToolMode::Native,\n        Box::new(create_explorer_mock()),\n        Box::new(create_command_executor_mock()),\n        Box::new(MockUI::default()),\n        Box::new(MockStatePersistence::new()),\n    );\n\n    agent\n        .start_with_task(\"Write file contents\".to_string())\n        .await?;\n\n    let requests = mock_llm_ref.requests.lock().unwrap();\n\n    // Should see three requests:\n    // 1. Failed WriteFile\n    // 2. Corrected WriteFile\n    // 3. CompleteTask\n    assert_eq!(requests.len(), 3);\n\n    // The error message should be a user message in the second request\n    let error_request = \u0026requests[1];\n    assert_eq!(error_request.messages.len(), 3); // Working Memory + Tool Response + Error\n    if let MessageContent::Text(content) = \u0026error_request.messages[2].content {\n        assert!(content.contains(\"Error executing action\"));\n        assert!(content.contains(\"absolute path\"));\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","stippi","projects","code-assistant","src","config.rs"],"content":"use crate::types::Project;\nuse anyhow::Result;\nuse std::collections::HashMap;\nuse std::path::PathBuf;\n\npub fn get_config_path() -\u003e Result\u003cPathBuf\u003e {\n    let home =\n        dirs::home_dir().ok_or_else(|| anyhow::anyhow!(\"Could not determine home directory\"))?;\n    Ok(home.join(\".code-assistant\").join(\"projects.json\"))\n}\n\npub fn load_projects() -\u003e Result\u003cHashMap\u003cString, Project\u003e\u003e {\n    let config_path = get_config_path()?;\n    if !config_path.exists() {\n        return Ok(HashMap::new());\n    }\n    let content = std::fs::read_to_string(config_path)?;\n    Ok(serde_json::from_str(\u0026content)?)\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","Users","stippi","projects","code-assistant","src","explorer.rs"],"content":"use crate::types::{\n    CodeExplorer, FileReplacement, FileSystemEntryType, FileTreeEntry, SearchMode, SearchOptions,\n    SearchResult,\n};\nuse anyhow::Result;\nuse ignore::WalkBuilder;\nuse regex::RegexBuilder;\nuse std::collections::{HashMap, HashSet};\n// Removed unused imports\nuse std::path::{Path, PathBuf};\nuse tracing::debug;\n\n/// Handles file system operations for code exploration\npub struct Explorer {\n    root_dir: PathBuf,\n    // Track which paths were explicitly listed\n    expanded_paths: HashSet\u003cPathBuf\u003e,\n}\n\nimpl FileTreeEntry {\n    /// Converts the file tree to a readable string representation\n    pub fn to_string(\u0026self) -\u003e String {\n        self.to_string_with_indent(0, \"\")\n    }\n\n    fn to_string_with_indent(\u0026self, level: usize, prefix: \u0026str) -\u003e String {\n        let mut result = String::new();\n\n        // Root level doesn't get a prefix\n        if level == 0 {\n            result.push_str(\u0026format!(\"{}/\\n\", self.name));\n        } else {\n            result.push_str(prefix);\n            result.push_str(\u0026self.name);\n\n            match self.entry_type {\n                FileSystemEntryType::Directory =\u003e {\n                    result.push('/');\n                    // Add [...] for unexpanded directories that aren't empty\n                    if !self.is_expanded {\n                        result.push_str(\" [...]\");\n                    }\n                }\n                FileSystemEntryType::File =\u003e {}\n            }\n            result.push('\\n');\n        }\n\n        // Only show children if this directory is expanded\n        if matches!(self.entry_type, FileSystemEntryType::Directory) \u0026\u0026 self.is_expanded {\n            // Sort children: directories first, then files, both alphabetically\n            let mut sorted_children: Vec\u003c_\u003e = self.children.values().collect();\n            sorted_children.sort_by_key(|entry| {\n                (\n                    matches!(entry.entry_type, FileSystemEntryType::File),\n                    \u0026entry.name,\n                )\n            });\n\n            // Add children\n            let child_count = sorted_children.len();\n            for (i, child) in sorted_children.iter().enumerate() {\n                let is_last = i == child_count - 1;\n\n                // Construct the prefix for this child\n                let child_prefix = if level == 0 {\n                    if is_last {\n                        format!(\"└─ \")\n                    } else {\n                        format!(\"├─ \")\n                    }\n                } else {\n                    if is_last {\n                        format!(\"{}└─ \", prefix.replace(\"├─ \", \"│  \").replace(\"└─ \", \"   \"))\n                    } else {\n                        format!(\"{}├─ \", prefix.replace(\"├─ \", \"│  \").replace(\"└─ \", \"   \"))\n                    }\n                };\n\n                result.push_str(\u0026child.to_string_with_indent(level + 1, \u0026child_prefix));\n            }\n        }\n\n        result\n    }\n}\n\nimpl Explorer {\n    /// Creates a new Explorer instance\n    ///\n    /// # Arguments\n    /// * `root_dir` - The root directory to explore\n    pub fn new(root_dir: PathBuf) -\u003e Self {\n        Self {\n            root_dir,\n            expanded_paths: HashSet::new(),\n        }\n    }\n\n    fn expand_directory(\n        \u0026mut self,\n        path: \u0026Path,\n        entry: \u0026mut FileTreeEntry,\n        current_depth: usize,\n        max_depth: usize,\n    ) -\u003e Result\u003c()\u003e {\n        // Expand if either:\n        // - Within max_depth during initial load\n        // - The path was explicitly listed before\n        let should_expand = current_depth \u003c max_depth || self.expanded_paths.contains(path);\n\n        if !should_expand {\n            entry.is_expanded = false;\n            return Ok(());\n        }\n\n        let default_ignore = [\n            \"target\",\n            \"node_modules\",\n            \"build\",\n            \"dist\",\n            \".git\",\n            \".idea\",\n            \".vscode\",\n            \"*.pyc\",\n            \"*.pyo\",\n            \"*.class\",\n            \".DS_Store\",\n            \"Thumbs.db\",\n        ];\n\n        let walker = WalkBuilder::new(path)\n            .max_depth(Some(1)) // Only immediate children\n            .hidden(false)\n            .git_ignore(true)\n            .filter_entry(move |e| {\n                let file_name = e.file_name().to_string_lossy();\n                !default_ignore\n                    .iter()\n                    .any(|pattern| match glob::Pattern::new(pattern) {\n                        Ok(pat) =\u003e pat.matches(\u0026file_name),\n                        Err(_) =\u003e file_name.contains(pattern),\n                    })\n            })\n            .build();\n\n        for result in walker {\n            let dir_entry = result?;\n            let entry_path = dir_entry.path();\n\n            // Skip the directory itself\n            if entry_path == path {\n                continue;\n            }\n\n            let name = entry_path\n                .file_name()\n                .and_then(|n| n.to_str())\n                .unwrap_or(\"\")\n                .to_string();\n\n            let is_dir = entry_path.is_dir();\n            let mut child_entry = FileTreeEntry {\n                name,\n                entry_type: if is_dir {\n                    FileSystemEntryType::Directory\n                } else {\n                    FileSystemEntryType::File\n                },\n                children: HashMap::new(),\n                is_expanded: false,\n            };\n\n            if is_dir {\n                self.expand_directory(entry_path, \u0026mut child_entry, current_depth + 1, max_depth)?;\n            }\n\n            entry.children.insert(child_entry.name.clone(), child_entry);\n        }\n\n        entry.is_expanded = true;\n        Ok(())\n    }\n}\n\nimpl CodeExplorer for Explorer {\n    fn root_dir(\u0026self) -\u003e PathBuf {\n        self.root_dir.clone()\n    }\n\n    fn create_initial_tree(\u0026mut self, max_depth: usize) -\u003e Result\u003cFileTreeEntry\u003e {\n        let mut root = FileTreeEntry {\n            name: self\n                .root_dir\n                .file_name()\n                .and_then(|n| n.to_str())\n                .unwrap_or(\"root\")\n                .to_string(),\n            entry_type: FileSystemEntryType::Directory,\n            children: HashMap::new(),\n            is_expanded: true, // Root is always expanded\n        };\n\n        let root_dir = \u0026self.root_dir.clone();\n        self.expand_directory(\u0026root_dir, \u0026mut root, 0, max_depth)?;\n        Ok(root)\n    }\n\n    fn read_file(\u0026self, path: \u0026PathBuf) -\u003e Result\u003cString\u003e {\n        debug!(\"Reading file: {}\", path.display());\n        Ok(std::fs::read_to_string(path)?)\n    }\n\n    fn write_file(\u0026self, path: \u0026PathBuf, content: \u0026String) -\u003e Result\u003c()\u003e {\n        debug!(\"Writing file: {}\", path.display());\n        // Ensure the parent directory exists\n        if let Some(parent) = path.parent() {\n            std::fs::create_dir_all(parent)?;\n        }\n        Ok(std::fs::write(path, content)?)\n    }\n\n    fn delete_file(\u0026self, path: \u0026PathBuf) -\u003e Result\u003c()\u003e {\n        std::fs::remove_file(path)?;\n        Ok(())\n    }\n\n    fn list_files(\u0026mut self, path: \u0026PathBuf, max_depth: Option\u003cusize\u003e) -\u003e Result\u003cFileTreeEntry\u003e {\n        // Remember that this path was explicitly listed\n        self.expanded_paths.insert(path.clone());\n\n        let mut entry = FileTreeEntry {\n            name: path\n                .file_name()\n                .and_then(|n| n.to_str())\n                .unwrap_or(\"\")\n                .to_string(),\n            entry_type: if path.is_dir() {\n                FileSystemEntryType::Directory\n            } else {\n                FileSystemEntryType::File\n            },\n            children: HashMap::new(),\n            is_expanded: true,\n        };\n\n        if path.is_dir() {\n            self.expand_directory(\n                path.as_path(),\n                \u0026mut entry,\n                0,\n                max_depth.unwrap_or(usize::MAX),\n            )?;\n        }\n\n        Ok(entry)\n    }\n\n    fn apply_replacements(\u0026self, path: \u0026Path, replacements: \u0026[FileReplacement]) -\u003e Result\u003cString\u003e {\n        let content = std::fs::read_to_string(path)?;\n        let updated_content = crate::utils::apply_replacements(\u0026content, replacements)?;\n        std::fs::write(path, \u0026updated_content)?;\n        Ok(updated_content)\n    }\n\n    fn search(\u0026self, path: \u0026Path, options: SearchOptions) -\u003e Result\u003cVec\u003cSearchResult\u003e\u003e {\n        let mut results = Vec::new();\n        let max_results = options.max_results.unwrap_or(usize::MAX);\n        let context_lines = 2; // Lines of context before and after\n\n        // Prepare regex for different search modes\n        let regex = match options.mode {\n            SearchMode::Exact =\u003e {\n                let pattern = if options.whole_words {\n                    format!(r\"\\b{}\\b\", regex::escape(\u0026options.query))\n                } else {\n                    regex::escape(\u0026options.query)\n                };\n                RegexBuilder::new(\u0026pattern)\n                    .case_insensitive(!options.case_sensitive)\n                    .build()?\n            }\n            SearchMode::Regex =\u003e {\n                let pattern = if options.whole_words {\n                    format!(r\"\\b{}\\b\", options.query)\n                } else {\n                    options.query.clone()\n                };\n                RegexBuilder::new(\u0026pattern)\n                    .case_insensitive(!options.case_sensitive)\n                    .build()?\n            }\n        };\n\n        let walker = WalkBuilder::new(path)\n            .hidden(false)\n            .git_ignore(true)\n            .build();\n\n        for entry in walker {\n            let entry = entry?;\n            let path = entry.path();\n\n            // Skip directories and non-text files\n            if path.is_dir() || !is_text_file(path) {\n                continue;\n            }\n\n            // Read entire file at once for context lines\n            let content = std::fs::read_to_string(path)?;\n            let lines: Vec\u003c_\u003e = content.lines().collect();\n            let mut current_section: Option\u003cSearchResult\u003e = None;\n\n            for (line_idx, line) in lines.iter().enumerate() {\n                let matches: Vec\u003c_\u003e = regex.find_iter(line).collect();\n                \n                if !matches.is_empty() {\n                    let match_ranges: Vec\u003c_\u003e = matches.iter().map(|m| (m.start(), m.end())).collect();\n                    let section_start = line_idx.saturating_sub(context_lines);\n                    let section_end = (line_idx + context_lines + 1).min(lines.len());\n                    \n                    match \u0026mut current_section {\n                        // Extend section if close enough to previous match\n                        Some(section) if line_idx \u003c= section.start_line + section.line_content.len() + context_lines =\u003e {\n                            while section.line_content.len() \u003c section_end - section.start_line {\n                                section.line_content.push(\n                                    lines[section.start_line + section.line_content.len()].to_string()\n                                );\n                            }\n                            section.match_lines.push(line_idx - section.start_line);\n                            section.match_ranges.push(match_ranges);\n                        }\n                        _ =\u003e {\n                            // Start new section\n                            if let Some(section) = current_section.take() {\n                                results.push(section);\n                                if results.len() \u003e= max_results {\n                                    return Ok(results);\n                                }\n                            }\n                            \n                            let mut section_lines = Vec::new();\n                            for i in section_start..section_end {\n                                section_lines.push(lines[i].to_string());\n                            }\n                            \n                            current_section = Some(SearchResult {\n                                file: path.to_path_buf(),\n                                start_line: section_start,\n                                line_content: section_lines,\n                                match_lines: vec![line_idx - section_start],\n                                match_ranges: vec![match_ranges],\n                            });\n                        }\n                    }\n                }\n            }\n            \n            // Add final section if we have one\n            if let Some(section) = current_section {\n                results.push(section);\n                if results.len() \u003e= max_results {\n                    return Ok(results);\n                }\n            }\n        }\n\n        Ok(results)\n    }\n}\n\n/// Helper function to determine if a file is likely to be a text file\nfn is_text_file(path: \u0026Path) -\u003e bool {\n    let text_extensions = [\n        \"txt\",\n        \"md\",\n        \"rs\",\n        \"js\",\n        \"py\",\n        \"java\",\n        \"c\",\n        \"cpp\",\n        \"h\",\n        \"hpp\",\n        \"css\",\n        \"html\",\n        \"xml\",\n        \"json\",\n        \"yaml\",\n        \"yml\",\n        \"toml\",\n        \"sh\",\n        \"bash\",\n        \"zsh\",\n        \"fish\",\n        \"conf\",\n        \"cfg\",\n        \"ini\",\n        \"properties\",\n        \"env\",\n    ];\n\n    path.extension()\n        .and_then(|ext| ext.to_str())\n        .map(|ext| text_extensions.contains(\u0026ext.to_lowercase().as_str()))\n        .unwrap_or(false)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use anyhow::Result;\n    use std::fs;\n    use tempfile::TempDir;\n\n    // Helper function to setup temporary test environment\n    fn setup_test_directory() -\u003e Result\u003c(TempDir, Explorer)\u003e {\n        let temp_dir = TempDir::new()?;\n        let explorer = Explorer::new(temp_dir.path().to_path_buf());\n        Ok((temp_dir, explorer))\n    }\n\n    // Helper function to create a test file with content\n    fn create_test_file(dir: \u0026Path, name: \u0026str, content: \u0026str) -\u003e Result\u003cPathBuf\u003e {\n        let file_path = dir.join(name);\n        fs::write(\u0026file_path, content)?;\n        Ok(file_path)\n    }\n\n    #[test]\n    fn test_read_file() -\u003e Result\u003c()\u003e {\n        let (temp_dir, explorer) = setup_test_directory()?;\n        let test_content = \"Hello, World!\";\n        let file_path = create_test_file(temp_dir.path(), \"test.txt\", test_content)?;\n\n        let result = explorer.read_file(\u0026file_path)?;\n        assert_eq!(result, test_content);\n        Ok(())\n    }\n\n    #[test]\n    fn test_apply_replacements() -\u003e Result\u003c()\u003e {\n        let temp_dir = TempDir::new()?;\n        let test_file = temp_dir.path().join(\"test.txt\");\n        std::fs::write(\u0026test_file, \"line 1\\nline 2\\nline 3\")?;\n\n        let explorer = Explorer::new(temp_dir.path().to_path_buf());\n\n        let replacements = vec![\n            FileReplacement {\n                search: \"line 1\\n\".to_string(),\n                replace: \"new line 1\\n\".to_string(),\n            },\n            FileReplacement {\n                search: \"line 3\".to_string(),\n                replace: \"new line 3\".to_string(),\n            },\n        ];\n\n        // Apply replacements and verify content\n        let result = explorer.apply_replacements(\u0026test_file, \u0026replacements)?;\n        assert_eq!(result, \"new line 1\\nline 2\\nnew line 3\");\n\n        // Verify file was actually modified\n        let content = std::fs::read_to_string(\u0026test_file)?;\n        assert_eq!(content, \"new line 1\\nline 2\\nnew line 3\");\n\n        // Test error case with ambiguous search\n        let result = explorer.apply_replacements(\n            \u0026test_file,\n            \u0026[FileReplacement {\n                search: \"line\".to_string(),\n                replace: \"test\".to_string(),\n            }],\n        );\n        assert!(result.is_err());\n        assert!(result\n            .unwrap_err()\n            .to_string()\n            .contains(\"Found 3 occurrences\"));\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_search() -\u003e Result\u003c()\u003e {\n        let (temp_dir, explorer) = setup_test_directory()?;\n\n        // Create test files with content\n        create_test_file(\n            temp_dir.path(),\n            \"file1.txt\",\n            \"This is line 1\\nThis is line 2\\nThis is line 3\",\n        )?;\n        create_test_file(\n            temp_dir.path(),\n            \"file2.txt\",\n            \"Another file line 1\\nAnother file line 2\",\n        )?;\n\n        // Create a subdirectory with a file\n        fs::create_dir(temp_dir.path().join(\"subdir\"))?;\n        create_test_file(\n            \u0026temp_dir.path().join(\"subdir\"),\n            \"file3.txt\",\n            \"Subdir line 1\\nSubdir line 2\",\n        )?;\n\n        // Test searching with different queries\n        let results = explorer.search(\n            temp_dir.path(),\n            SearchOptions {\n                query: \"line 2\".to_string(),\n                ..Default::default()\n            },\n        )?;\n        assert_eq!(results.len(), 3);\n        assert!(results\n            .iter()\n            .any(|r| r.line_content.iter().any(|l| l.contains(\"This is line 2\"))));\n        assert!(results\n            .iter()\n            .any(|r| r.line_content.iter().any(|l| l.contains(\"Another file line 2\"))));\n        assert!(results\n            .iter()\n            .any(|r| r.line_content.iter().any(|l| l.contains(\"Subdir line 2\"))));\n\n        // Test with max_results\n        let results = explorer.search(\n            temp_dir.path(),\n            SearchOptions {\n                query: \"line\".to_string(),\n                max_results: Some(2),\n                ..Default::default()\n            },\n        )?;\n        assert_eq!(results.len(), 2);\n\n        // Test with non-matching query\n        let results = explorer.search(\n            temp_dir.path(),\n            SearchOptions {\n                query: \"nonexistent\".to_string(),\n                ..Default::default()\n            },\n        )?;\n        assert_eq!(results.len(), 0);\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_create_initial_tree() -\u003e Result\u003c()\u003e {\n        let (temp_dir, mut explorer) = setup_test_directory()?;\n\n        // Create a simple file system structure\n        fs::create_dir(temp_dir.path().join(\"dir1\"))?;\n        fs::create_dir(temp_dir.path().join(\"dir2\"))?;\n        create_test_file(temp_dir.path(), \"file1.txt\", \"content\")?;\n        create_test_file(\u0026temp_dir.path().join(\"dir1\"), \"file2.txt\", \"content\")?;\n\n        let tree = explorer.create_initial_tree(2)?;\n\n        // Assert basic structure\n        assert!(tree.is_expanded);\n        assert_eq!(tree.entry_type, FileSystemEntryType::Directory);\n\n        // Assert the children\n        let children_names: Vec\u003cString\u003e = tree.children.keys().cloned().collect();\n        assert!(children_names.contains(\u0026\"dir1\".to_string()));\n        assert!(children_names.contains(\u0026\"dir2\".to_string()));\n        assert!(children_names.contains(\u0026\"file1.txt\".to_string()));\n\n        // Assert dir1\n        let dir1 = tree.children.get(\"dir1\").unwrap();\n        assert_eq!(dir1.entry_type, FileSystemEntryType::Directory);\n        assert!(dir1.is_expanded);\n        assert!(dir1.children.contains_key(\"file2.txt\"));\n\n        Ok(())\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":18}},{"line":23,"address":[],"length":0,"stats":{"Line":18}},{"line":26,"address":[],"length":0,"stats":{"Line":33}},{"line":27,"address":[],"length":0,"stats":{"Line":33}},{"line":30,"address":[],"length":0,"stats":{"Line":51}},{"line":31,"address":[],"length":0,"stats":{"Line":18}},{"line":33,"address":[],"length":0,"stats":{"Line":15}},{"line":34,"address":[],"length":0,"stats":{"Line":15}},{"line":36,"address":[],"length":0,"stats":{"Line":15}},{"line":38,"address":[],"length":0,"stats":{"Line":15}},{"line":40,"address":[],"length":0,"stats":{"Line":15}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":15}},{"line":50,"address":[],"length":0,"stats":{"Line":66}},{"line":52,"address":[],"length":0,"stats":{"Line":33}},{"line":53,"address":[],"length":0,"stats":{"Line":33}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":15}},{"line":63,"address":[],"length":0,"stats":{"Line":15}},{"line":66,"address":[],"length":0,"stats":{"Line":30}},{"line":67,"address":[],"length":0,"stats":{"Line":15}},{"line":68,"address":[],"length":0,"stats":{"Line":15}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":33}},{"line":93,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":4}},{"line":100,"address":[],"length":0,"stats":{"Line":3}},{"line":110,"address":[],"length":0,"stats":{"Line":6}},{"line":112,"address":[],"length":0,"stats":{"Line":3}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":3}},{"line":118,"address":[],"length":0,"stats":{"Line":3}},{"line":119,"address":[],"length":0,"stats":{"Line":3}},{"line":120,"address":[],"length":0,"stats":{"Line":3}},{"line":121,"address":[],"length":0,"stats":{"Line":3}},{"line":122,"address":[],"length":0,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":3}},{"line":124,"address":[],"length":0,"stats":{"Line":3}},{"line":125,"address":[],"length":0,"stats":{"Line":3}},{"line":126,"address":[],"length":0,"stats":{"Line":3}},{"line":127,"address":[],"length":0,"stats":{"Line":3}},{"line":128,"address":[],"length":0,"stats":{"Line":3}},{"line":129,"address":[],"length":0,"stats":{"Line":3}},{"line":132,"address":[],"length":0,"stats":{"Line":3}},{"line":133,"address":[],"length":0,"stats":{"Line":3}},{"line":136,"address":[],"length":0,"stats":{"Line":7}},{"line":137,"address":[],"length":0,"stats":{"Line":4}},{"line":138,"address":[],"length":0,"stats":{"Line":4}},{"line":139,"address":[],"length":0,"stats":{"Line":4}},{"line":140,"address":[],"length":0,"stats":{"Line":52}},{"line":141,"address":[],"length":0,"stats":{"Line":48}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":17}},{"line":148,"address":[],"length":0,"stats":{"Line":7}},{"line":153,"address":[],"length":0,"stats":{"Line":3}},{"line":156,"address":[],"length":0,"stats":{"Line":4}},{"line":158,"address":[],"length":0,"stats":{"Line":8}},{"line":175,"address":[],"length":0,"stats":{"Line":2}},{"line":178,"address":[],"length":0,"stats":{"Line":4}},{"line":181,"address":[],"length":0,"stats":{"Line":3}},{"line":182,"address":[],"length":0,"stats":{"Line":3}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":1}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":1}},{"line":204,"address":[],"length":0,"stats":{"Line":1}},{"line":205,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":1}},{"line":209,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":1}},{"line":211,"address":[],"length":0,"stats":{"Line":1}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":2}},{"line":260,"address":[],"length":0,"stats":{"Line":4}},{"line":261,"address":[],"length":0,"stats":{"Line":2}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":1}},{"line":266,"address":[],"length":0,"stats":{"Line":3}},{"line":267,"address":[],"length":0,"stats":{"Line":3}},{"line":268,"address":[],"length":0,"stats":{"Line":3}},{"line":269,"address":[],"length":0,"stats":{"Line":3}},{"line":272,"address":[],"length":0,"stats":{"Line":6}},{"line":274,"address":[],"length":0,"stats":{"Line":3}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":3}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":28}},{"line":301,"address":[],"length":0,"stats":{"Line":13}},{"line":305,"address":[],"length":0,"stats":{"Line":8}},{"line":306,"address":[],"length":0,"stats":{"Line":5}},{"line":310,"address":[],"length":0,"stats":{"Line":8}},{"line":314,"address":[],"length":0,"stats":{"Line":19}},{"line":315,"address":[],"length":0,"stats":{"Line":19}},{"line":317,"address":[],"length":0,"stats":{"Line":19}},{"line":318,"address":[],"length":0,"stats":{"Line":16}},{"line":322,"address":[],"length":0,"stats":{"Line":3}},{"line":324,"address":[],"length":0,"stats":{"Line":6}},{"line":325,"address":[],"length":0,"stats":{"Line":3}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":3}},{"line":331,"address":[],"length":0,"stats":{"Line":3}},{"line":335,"address":[],"length":0,"stats":{"Line":5}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":5}},{"line":343,"address":[],"length":0,"stats":{"Line":24}},{"line":344,"address":[],"length":0,"stats":{"Line":12}},{"line":347,"address":[],"length":0,"stats":{"Line":5}},{"line":348,"address":[],"length":0,"stats":{"Line":5}},{"line":349,"address":[],"length":0,"stats":{"Line":5}},{"line":350,"address":[],"length":0,"stats":{"Line":5}},{"line":351,"address":[],"length":0,"stats":{"Line":5}},{"line":352,"address":[],"length":0,"stats":{"Line":5}},{"line":360,"address":[],"length":0,"stats":{"Line":13}},{"line":363,"address":[],"length":0,"stats":{"Line":1}},{"line":368,"address":[],"length":0,"stats":{"Line":2}},{"line":373,"address":[],"length":0,"stats":{"Line":8}},{"line":374,"address":[],"length":0,"stats":{"Line":8}},{"line":375,"address":[],"length":0,"stats":{"Line":8}},{"line":376,"address":[],"length":0,"stats":{"Line":8}},{"line":377,"address":[],"length":0,"stats":{"Line":8}},{"line":378,"address":[],"length":0,"stats":{"Line":8}},{"line":379,"address":[],"length":0,"stats":{"Line":8}},{"line":380,"address":[],"length":0,"stats":{"Line":8}},{"line":381,"address":[],"length":0,"stats":{"Line":8}},{"line":382,"address":[],"length":0,"stats":{"Line":8}},{"line":383,"address":[],"length":0,"stats":{"Line":8}},{"line":384,"address":[],"length":0,"stats":{"Line":8}},{"line":385,"address":[],"length":0,"stats":{"Line":8}},{"line":386,"address":[],"length":0,"stats":{"Line":8}},{"line":387,"address":[],"length":0,"stats":{"Line":8}},{"line":388,"address":[],"length":0,"stats":{"Line":8}},{"line":389,"address":[],"length":0,"stats":{"Line":8}},{"line":390,"address":[],"length":0,"stats":{"Line":8}},{"line":391,"address":[],"length":0,"stats":{"Line":8}},{"line":392,"address":[],"length":0,"stats":{"Line":8}},{"line":393,"address":[],"length":0,"stats":{"Line":8}},{"line":394,"address":[],"length":0,"stats":{"Line":8}},{"line":395,"address":[],"length":0,"stats":{"Line":8}},{"line":396,"address":[],"length":0,"stats":{"Line":8}},{"line":397,"address":[],"length":0,"stats":{"Line":8}},{"line":398,"address":[],"length":0,"stats":{"Line":8}},{"line":399,"address":[],"length":0,"stats":{"Line":8}},{"line":400,"address":[],"length":0,"stats":{"Line":8}},{"line":403,"address":[],"length":0,"stats":{"Line":8}},{"line":404,"address":[],"length":0,"stats":{"Line":24}},{"line":405,"address":[],"length":0,"stats":{"Line":24}}],"covered":134,"coverable":176},{"path":["/","Users","stippi","projects","code-assistant","src","llm","anthropic.rs"],"content":"use crate::llm::{\n    types::*, ApiError, ApiErrorContext, LLMProvider, RateLimitHandler, StreamingCallback,\n};\nuse anyhow::Result;\nuse async_trait::async_trait;\nuse chrono::{DateTime, Utc};\nuse reqwest::{Client, Response, StatusCode};\nuse serde::{Deserialize, Serialize};\nuse std::str::{self};\nuse std::time::Duration;\nuse tokio::time::sleep;\nuse tracing::{debug, error, warn};\n\n/// Response structure for Anthropic error messages\n#[derive(Debug, Serialize, serde::Deserialize)]\nstruct AnthropicErrorResponse {\n    #[serde(rename = \"type\")]\n    error_type: String,\n    error: AnthropicErrorPayload,\n}\n\n#[derive(Debug, Serialize, serde::Deserialize)]\nstruct AnthropicErrorPayload {\n    #[serde(rename = \"type\")]\n    error_type: String,\n    message: String,\n}\n\n/// Rate limit information extracted from response headers\n#[derive(Debug)]\nstruct AnthropicRateLimitInfo {\n    requests_limit: Option\u003cu32\u003e,\n    requests_remaining: Option\u003cu32\u003e,\n    requests_reset: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    tokens_limit: Option\u003cu32\u003e,\n    tokens_remaining: Option\u003cu32\u003e,\n    tokens_reset: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    retry_after: Option\u003cDuration\u003e,\n}\n\nimpl RateLimitHandler for AnthropicRateLimitInfo {\n    /// Extract rate limit information from response headers\n    fn from_response(response: \u0026Response) -\u003e Self {\n        let headers = response.headers();\n\n        fn parse_header\u003cT: std::str::FromStr\u003e(\n            headers: \u0026reqwest::header::HeaderMap,\n            name: \u0026str,\n        ) -\u003e Option\u003cT\u003e {\n            headers\n                .get(name)\n                .and_then(|h| h.to_str().ok())\n                .and_then(|s| s.parse().ok())\n        }\n\n        fn parse_datetime(\n            headers: \u0026reqwest::header::HeaderMap,\n            name: \u0026str,\n        ) -\u003e Option\u003cDateTime\u003cUtc\u003e\u003e {\n            headers\n                .get(name)\n                .and_then(|h| h.to_str().ok())\n                .and_then(|s| DateTime::parse_from_rfc3339(s).ok())\n                .map(|dt| dt.into())\n        }\n\n        Self {\n            requests_limit: parse_header(headers, \"anthropic-ratelimit-requests-limit\"),\n            requests_remaining: parse_header(headers, \"anthropic-ratelimit-requests-remaining\"),\n            requests_reset: parse_datetime(headers, \"anthropic-ratelimit-requests-reset\"),\n            tokens_limit: parse_header(headers, \"anthropic-ratelimit-tokens-limit\"),\n            tokens_remaining: parse_header(headers, \"anthropic-ratelimit-tokens-remaining\"),\n            tokens_reset: parse_datetime(headers, \"anthropic-ratelimit-tokens-reset\"),\n            retry_after: parse_header::\u003cu64\u003e(headers, \"retry-after\").map(Duration::from_secs),\n        }\n    }\n\n    /// Calculate how long to wait before retrying based on rate limit information\n    fn get_retry_delay(\u0026self) -\u003e Duration {\n        // If we have a specific retry-after duration, use that\n        if let Some(retry_after) = self.retry_after {\n            return retry_after;\n        }\n\n        // Otherwise, calculate based on reset times\n        let now = Utc::now();\n        let mut shortest_wait = Duration::from_secs(60); // Default to 60 seconds if no information\n\n        // Check requests reset time\n        if let Some(reset_time) = self.requests_reset {\n            if reset_time \u003e now {\n                shortest_wait = shortest_wait.min(Duration::from_secs(\n                    (reset_time - now).num_seconds().max(0) as u64,\n                ));\n            }\n        }\n\n        // Check tokens reset time\n        if let Some(reset_time) = self.tokens_reset {\n            if reset_time \u003e now {\n                shortest_wait = shortest_wait.min(Duration::from_secs(\n                    (reset_time - now).num_seconds().max(0) as u64,\n                ));\n            }\n        }\n\n        // Add a small buffer to avoid hitting the limit exactly at reset time\n        shortest_wait + Duration::from_secs(1)\n    }\n\n    /// Log current rate limit status\n    fn log_status(\u0026self) {\n        debug!(\n            \"Rate limits - Requests: {}/{} (reset: {}), Tokens: {}/{} (reset: {})\",\n            self.requests_remaining\n                .map_or(\"?\".to_string(), |r| r.to_string()),\n            self.requests_limit\n                .map_or(\"?\".to_string(), |l| l.to_string()),\n            self.requests_reset\n                .map_or(\"unknown\".to_string(), |r| r.to_string()),\n            self.tokens_remaining\n                .map_or(\"?\".to_string(), |r| r.to_string()),\n            self.tokens_limit.map_or(\"?\".to_string(), |l| l.to_string()),\n            self.tokens_reset\n                .map_or(\"unknown\".to_string(), |r| r.to_string()),\n        );\n    }\n}\n\n/// Anthropic-specific request structure\n#[derive(Debug, Serialize)]\nstruct AnthropicRequest {\n    model: String,\n    messages: Vec\u003cMessage\u003e,\n    max_tokens: usize,\n    temperature: f32,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    system: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    tools: Option\u003cVec\u003cserde_json::Value\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    tool_choice: Option\u003cserde_json::Value\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    stream: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct StreamEventCommon {\n    index: usize,\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(tag = \"type\")]\nenum StreamEvent {\n    #[allow(dead_code)]\n    #[serde(rename = \"message_start\")]\n    MessageStart { message: MessageStart },\n    #[serde(rename = \"content_block_start\")]\n    ContentBlockStart {\n        #[serde(flatten)]\n        common: StreamEventCommon,\n        content_block: StreamContentBlock,\n    },\n    #[serde(rename = \"content_block_delta\")]\n    ContentBlockDelta {\n        #[serde(flatten)]\n        common: StreamEventCommon,\n        delta: ContentDelta,\n    },\n    #[serde(rename = \"content_block_stop\")]\n    ContentBlockStop {\n        #[serde(flatten)]\n        common: StreamEventCommon,\n    },\n    #[serde(rename = \"message_delta\")]\n    MessageDelta,\n    #[serde(rename = \"message_stop\")]\n    MessageStop,\n    #[serde(rename = \"ping\")]\n    Ping,\n}\n\n#[derive(Debug, Deserialize)]\nstruct MessageStart {\n    #[allow(dead_code)]\n    id: String,\n    #[allow(dead_code)]\n    #[serde(rename = \"type\")]\n    message_type: String,\n    #[allow(dead_code)]\n    role: String,\n    #[allow(dead_code)]\n    model: String,\n}\n\n#[derive(Debug, Deserialize)]\nstruct StreamContentBlock {\n    #[serde(rename = \"type\")]\n    block_type: String,\n    text: Option\u003cString\u003e,\n    // Fields for tool use blocks\n    id: Option\u003cString\u003e,\n    name: Option\u003cString\u003e,\n    input: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(tag = \"type\")]\nenum ContentDelta {\n    #[serde(rename = \"text_delta\")]\n    TextDelta { text: String },\n    #[serde(rename = \"input_json_delta\")]\n    InputJsonDelta { partial_json: String },\n}\n\npub struct AnthropicClient {\n    client: Client,\n    api_key: String,\n    base_url: String,\n    model: String,\n}\n\nimpl AnthropicClient {\n    pub fn new(api_key: String, model: String) -\u003e Self {\n        Self {\n            client: Client::new(),\n            api_key,\n            base_url: \"https://api.anthropic.com/v1\".to_string(),\n            model,\n        }\n    }\n\n    #[cfg(test)]\n    pub fn new_with_base_url(api_key: String, model: String, base_url: String) -\u003e Self {\n        Self {\n            client: Client::new(),\n            api_key,\n            base_url,\n            model,\n        }\n    }\n\n    fn get_url(\u0026self) -\u003e String {\n        format!(\"{}/messages\", self.base_url)\n    }\n\n    async fn send_with_retry(\n        \u0026self,\n        request: \u0026AnthropicRequest,\n        streaming_callback: Option\u003c\u0026StreamingCallback\u003e,\n        max_retries: u32,\n    ) -\u003e Result\u003cLLMResponse\u003e {\n        let mut attempts = 0;\n\n        loop {\n            match self.try_send_request(request, streaming_callback).await {\n                Ok((response, rate_limits)) =\u003e {\n                    // Log rate limit status on successful response\n                    rate_limits.log_status();\n                    return Ok(response);\n                }\n                Err(e) =\u003e {\n                    // Extract rate limit info if available in the error context\n                    let rate_limits = e\n                        .downcast_ref::\u003cApiErrorContext\u003cAnthropicRateLimitInfo\u003e\u003e()\n                        .and_then(|ctx| ctx.rate_limits.as_ref());\n\n                    match e.downcast_ref::\u003cApiError\u003e() {\n                        Some(ApiError::RateLimit(_)) =\u003e {\n                            if let Some(rate_limits) = rate_limits {\n                                if attempts \u003c max_retries {\n                                    attempts += 1;\n                                    let delay = rate_limits.get_retry_delay();\n                                    warn!(\n                                            \"Rate limit hit (attempt {}/{}), waiting {} seconds before retry\",\n                                            attempts,\n                                            max_retries,\n                                            delay.as_secs()\n                                        );\n                                    sleep(delay).await;\n                                    continue;\n                                }\n                            } else {\n                                // Fallback if no rate limit info available\n                                if attempts \u003c max_retries {\n                                    attempts += 1;\n                                    let delay = Duration::from_secs(2u64.pow(attempts - 1));\n                                    warn!(\n                                            \"Rate limit hit but no timing info available (attempt {}/{}), using exponential backoff: {} seconds\",\n                                            attempts,\n                                            max_retries,\n                                            delay.as_secs()\n                                        );\n                                    sleep(delay).await;\n                                    continue;\n                                }\n                            }\n                        }\n                        Some(ApiError::ServiceError(_)) =\u003e {\n                            if attempts \u003c max_retries {\n                                attempts += 1;\n                                let delay = Duration::from_secs(2u64.pow(attempts - 1));\n                                warn!(\n                                    \"Service error (attempt {}/{}), retrying in {} seconds\",\n                                    attempts,\n                                    max_retries,\n                                    delay.as_secs()\n                                );\n                                sleep(delay).await;\n                                continue;\n                            }\n                        }\n                        Some(ApiError::NetworkError(_)) =\u003e {\n                            if attempts \u003c max_retries {\n                                attempts += 1;\n                                let delay = Duration::from_secs(2u64.pow(attempts - 1));\n                                warn!(\n                                    \"Network error (attempt {}/{}), retrying in {} seconds\",\n                                    attempts,\n                                    max_retries,\n                                    delay.as_secs()\n                                );\n                                sleep(delay).await;\n                                continue;\n                            }\n                        }\n                        _ =\u003e {} // Don't retry other types of errors\n                    }\n                    return Err(e);\n                }\n            }\n        }\n    }\n\n    async fn try_send_request(\n        \u0026self,\n        request: \u0026AnthropicRequest,\n        streaming_callback: Option\u003c\u0026StreamingCallback\u003e,\n    ) -\u003e Result\u003c(LLMResponse, AnthropicRateLimitInfo)\u003e {\n        let accept_value = if let Some(_) = streaming_callback {\n            \"text/event-stream\"\n        } else {\n            \"application/json\"\n        };\n\n        let mut response = self\n            .client\n            .post(\u0026self.get_url())\n            .header(\"x-api-key\", \u0026self.api_key)\n            .header(\"anthropic-version\", \"2023-06-01\")\n            .header(\"accept\", accept_value)\n            .json(request)\n            .send()\n            .await\n            .map_err(|e| ApiError::NetworkError(e.to_string()))?;\n\n        // Log raw headers for debugging\n        debug!(\"Response headers: {:?}\", response.headers());\n\n        // Extract rate limit information from response headers\n        let rate_limits = AnthropicRateLimitInfo::from_response(\u0026response);\n\n        // Log parsed rate limits\n        debug!(\"Parsed rate limits: {:?}\", rate_limits);\n\n        let status = response.status();\n        if !status.is_success() {\n            let response_text = response\n                .text()\n                .await\n                .map_err(|e| ApiError::NetworkError(e.to_string()))?;\n\n            // Try to parse the error response\n            let error = if let Ok(error_response) =\n                serde_json::from_str::\u003cAnthropicErrorResponse\u003e(\u0026response_text)\n            {\n                match (status, error_response.error.error_type.as_str()) {\n                    (StatusCode::TOO_MANY_REQUESTS, _) | (_, \"rate_limit_error\") =\u003e {\n                        error!(\n                            \"Rate limit error detected: status={}, type={}, message={}\",\n                            status, error_response.error.error_type, error_response.error.message\n                        );\n                        ApiError::RateLimit(error_response.error.message)\n                    }\n                    (StatusCode::UNAUTHORIZED, _) =\u003e {\n                        ApiError::Authentication(error_response.error.message)\n                    }\n                    (StatusCode::BAD_REQUEST, _) =\u003e {\n                        ApiError::InvalidRequest(error_response.error.message)\n                    }\n                    (status, _) if status.is_server_error() =\u003e {\n                        ApiError::ServiceError(error_response.error.message)\n                    }\n                    _ =\u003e {\n                        error!(\n                            \"Unknown error detected: status={}, type={}, message={}\",\n                            status, error_response.error.error_type, error_response.error.message\n                        );\n                        ApiError::Unknown(error_response.error.message)\n                    }\n                }\n            } else {\n                ApiError::Unknown(format!(\"Status {}: {}\", status, response_text))\n            };\n\n            // Wrap the error with rate limit context\n            return Err(ApiErrorContext {\n                error,\n                rate_limits: Some(rate_limits),\n            }\n            .into());\n        }\n\n        if let Some(callback) = streaming_callback {\n            let mut blocks: Vec\u003cContentBlock\u003e = Vec::new();\n            let mut current_content = String::new();\n            let mut line_buffer = String::new();\n\n            fn process_chunk(\n                chunk: \u0026[u8],\n                line_buffer: \u0026mut String,\n                blocks: \u0026mut Vec\u003cContentBlock\u003e,\n                current_content: \u0026mut String,\n                callback: \u0026StreamingCallback,\n            ) -\u003e Result\u003c()\u003e {\n                let chunk_str = str::from_utf8(chunk)?;\n\n                for c in chunk_str.chars() {\n                    if c == '\\n' {\n                        if !line_buffer.is_empty() {\n                            process_sse_line(line_buffer, blocks, current_content, callback)?;\n                            line_buffer.clear();\n                        }\n                    } else {\n                        line_buffer.push(c);\n                    }\n                }\n                Ok(())\n            }\n\n            fn process_sse_line(\n                line: \u0026str,\n                blocks: \u0026mut Vec\u003cContentBlock\u003e,\n                current_content: \u0026mut String,\n                callback: \u0026StreamingCallback,\n            ) -\u003e Result\u003c()\u003e {\n                if let Some(data) = line.strip_prefix(\"data: \") {\n                    if let Ok(event) = serde_json::from_str::\u003cStreamEvent\u003e(data) {\n                        // Extract and check index for relevant events\n                        match \u0026event {\n                            StreamEvent::ContentBlockStart { common, .. } =\u003e {\n                                if common.index != blocks.len() {\n                                    return Err(anyhow::anyhow!(\n                                        \"Start index {} does not match expected block {}\",\n                                        common.index,\n                                        blocks.len()\n                                    ));\n                                }\n                            }\n                            StreamEvent::ContentBlockDelta { common, .. }\n                            | StreamEvent::ContentBlockStop { common } =\u003e {\n                                // Check if we have any blocks at all\n                                if blocks.is_empty() {\n                                    return Err(anyhow::anyhow!(\n                                        \"Received Delta/Stop but no blocks exist\"\n                                    ));\n                                }\n                                if common.index != blocks.len() - 1 {\n                                    return Err(anyhow::anyhow!(\n                                        \"Delta/Stop index {} does not match current block {}\",\n                                        common.index,\n                                        blocks.len() - 1\n                                    ));\n                                }\n                            }\n                            _ =\u003e return Ok(()), // Early return for events without index\n                        }\n\n                        match event {\n                            StreamEvent::ContentBlockStart { content_block, .. } =\u003e {\n                                current_content.clear();\n                                let block = match content_block.block_type.as_str() {\n                                    \"text\" =\u003e {\n                                        if let Some(text) = content_block.text {\n                                            current_content.push_str(\u0026text);\n                                        }\n                                        ContentBlock::Text {\n                                            text: String::new(),\n                                        }\n                                    }\n                                    \"tool_use\" =\u003e {\n                                        if let Some(input) = content_block.input {\n                                            current_content.push_str(\u0026input);\n                                        }\n                                        ContentBlock::ToolUse {\n                                            id: content_block.id.unwrap_or_default(),\n                                            name: content_block.name.unwrap_or_default(),\n                                            input: serde_json::Value::Null,\n                                        }\n                                    }\n                                    _ =\u003e ContentBlock::Text {\n                                        text: String::new(),\n                                    },\n                                };\n                                blocks.push(block);\n                            }\n                            StreamEvent::ContentBlockDelta { delta, .. } =\u003e {\n                                match \u0026delta {\n                                    ContentDelta::TextDelta { text: delta_text } =\u003e {\n                                        callback(delta_text)?;\n                                        current_content.push_str(delta_text);\n                                    }\n                                    ContentDelta::InputJsonDelta { partial_json } =\u003e {\n                                        // Accumulate JSON parts as string\n                                        current_content.push_str(partial_json);\n                                    }\n                                }\n                            }\n                            StreamEvent::ContentBlockStop { .. } =\u003e {\n                                match blocks.last_mut().unwrap() {\n                                    ContentBlock::Text { text } =\u003e {\n                                        *text = current_content.clone();\n                                    }\n                                    ContentBlock::ToolUse { input, .. } =\u003e {\n                                        if let Ok(json) = serde_json::from_str(current_content) {\n                                            *input = json;\n                                        }\n                                    }\n                                    _ =\u003e {}\n                                }\n                            }\n                            _ =\u003e {}\n                        }\n                    }\n                }\n                Ok(())\n            }\n\n            while let Some(chunk) = response.chunk().await? {\n                process_chunk(\n                    \u0026chunk,\n                    \u0026mut line_buffer,\n                    \u0026mut blocks,\n                    \u0026mut current_content,\n                    callback,\n                )?;\n            }\n\n            // Process any remaining data in the buffer\n            if !line_buffer.is_empty() {\n                process_sse_line(\u0026line_buffer, \u0026mut blocks, \u0026mut current_content, callback)?;\n            }\n\n            Ok((\n                LLMResponse {\n                    content: blocks,\n                    usage: Usage {\n                        input_tokens: 0,\n                        output_tokens: 0,\n                    },\n                },\n                rate_limits,\n            ))\n        } else {\n            let response_text = response\n                .text()\n                .await\n                .map_err(|e| ApiError::NetworkError(e.to_string()))?;\n\n            let llm_response = serde_json::from_str(\u0026response_text)\n                .map_err(|e| ApiError::Unknown(format!(\"Failed to parse response: {}\", e)))?;\n\n            Ok((llm_response, rate_limits))\n        }\n    }\n}\n\n#[async_trait]\nimpl LLMProvider for AnthropicClient {\n    async fn send_message(\n        \u0026self,\n        request: LLMRequest,\n        streaming_callback: Option\u003c\u0026StreamingCallback\u003e,\n    ) -\u003e Result\u003cLLMResponse\u003e {\n        let anthropic_request = AnthropicRequest {\n            model: self.model.clone(),\n            messages: request.messages,\n            max_tokens: 8192,\n            temperature: 0.7,\n            system: Some(request.system_prompt),\n            stream: streaming_callback.map(|_| true),\n            tool_choice: match \u0026request.tools {\n                Some(_) =\u003e Some(serde_json::json!({\n                    \"type\": \"any\",\n                })),\n                _ =\u003e None,\n            },\n            tools: request.tools.map(|tools| {\n                tools\n                    .into_iter()\n                    .map(|tool| {\n                        serde_json::json!({\n                            \"name\": tool.name,\n                            \"description\": tool.description,\n                            \"input_schema\": tool.parameters\n                        })\n                    })\n                    .collect()\n            }),\n        };\n\n        self.send_with_retry(\u0026anthropic_request, streaming_callback, 3)\n            .await\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":4}},{"line":44,"address":[],"length":0,"stats":{"Line":4}},{"line":46,"address":[],"length":0,"stats":{"Line":20}},{"line":50,"address":[],"length":0,"stats":{"Line":20}},{"line":51,"address":[],"length":0,"stats":{"Line":20}},{"line":52,"address":[],"length":0,"stats":{"Line":40}},{"line":53,"address":[],"length":0,"stats":{"Line":40}},{"line":56,"address":[],"length":0,"stats":{"Line":8}},{"line":60,"address":[],"length":0,"stats":{"Line":8}},{"line":61,"address":[],"length":0,"stats":{"Line":8}},{"line":62,"address":[],"length":0,"stats":{"Line":16}},{"line":63,"address":[],"length":0,"stats":{"Line":16}},{"line":64,"address":[],"length":0,"stats":{"Line":16}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":4}},{"line":70,"address":[],"length":0,"stats":{"Line":4}},{"line":71,"address":[],"length":0,"stats":{"Line":4}},{"line":72,"address":[],"length":0,"stats":{"Line":4}},{"line":73,"address":[],"length":0,"stats":{"Line":4}},{"line":74,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":4}},{"line":113,"address":[],"length":0,"stats":{"Line":4}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":2}},{"line":236,"address":[],"length":0,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":4}},{"line":244,"address":[],"length":0,"stats":{"Line":4}},{"line":247,"address":[],"length":0,"stats":{"Line":4}},{"line":253,"address":[],"length":0,"stats":{"Line":4}},{"line":256,"address":[],"length":0,"stats":{"Line":26}},{"line":257,"address":[],"length":0,"stats":{"Line":4}},{"line":259,"address":[],"length":0,"stats":{"Line":4}},{"line":260,"address":[],"length":0,"stats":{"Line":4}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":4}},{"line":340,"address":[],"length":0,"stats":{"Line":8}},{"line":341,"address":[],"length":0,"stats":{"Line":2}},{"line":343,"address":[],"length":0,"stats":{"Line":2}},{"line":346,"address":[],"length":0,"stats":{"Line":8}},{"line":347,"address":[],"length":0,"stats":{"Line":4}},{"line":348,"address":[],"length":0,"stats":{"Line":4}},{"line":349,"address":[],"length":0,"stats":{"Line":4}},{"line":351,"address":[],"length":0,"stats":{"Line":4}},{"line":352,"address":[],"length":0,"stats":{"Line":4}},{"line":354,"address":[],"length":0,"stats":{"Line":8}},{"line":355,"address":[],"length":0,"stats":{"Line":8}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":4}},{"line":364,"address":[],"length":0,"stats":{"Line":4}},{"line":366,"address":[],"length":0,"stats":{"Line":4}},{"line":367,"address":[],"length":0,"stats":{"Line":4}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":6}},{"line":419,"address":[],"length":0,"stats":{"Line":14}},{"line":426,"address":[],"length":0,"stats":{"Line":28}},{"line":428,"address":[],"length":0,"stats":{"Line":1793}},{"line":429,"address":[],"length":0,"stats":{"Line":1793}},{"line":430,"address":[],"length":0,"stats":{"Line":42}},{"line":431,"address":[],"length":0,"stats":{"Line":28}},{"line":432,"address":[],"length":0,"stats":{"Line":28}},{"line":435,"address":[],"length":0,"stats":{"Line":1751}},{"line":438,"address":[],"length":0,"stats":{"Line":14}},{"line":441,"address":[],"length":0,"stats":{"Line":28}},{"line":447,"address":[],"length":0,"stats":{"Line":42}},{"line":448,"address":[],"length":0,"stats":{"Line":14}},{"line":451,"address":[],"length":0,"stats":{"Line":2}},{"line":452,"address":[],"length":0,"stats":{"Line":2}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":4}},{"line":461,"address":[],"length":0,"stats":{"Line":2}},{"line":463,"address":[],"length":0,"stats":{"Line":6}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":6}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":6}},{"line":479,"address":[],"length":0,"stats":{"Line":8}},{"line":480,"address":[],"length":0,"stats":{"Line":2}},{"line":481,"address":[],"length":0,"stats":{"Line":2}},{"line":482,"address":[],"length":0,"stats":{"Line":2}},{"line":484,"address":[],"length":0,"stats":{"Line":3}},{"line":485,"address":[],"length":0,"stats":{"Line":1}},{"line":488,"address":[],"length":0,"stats":{"Line":1}},{"line":491,"address":[],"length":0,"stats":{"Line":1}},{"line":492,"address":[],"length":0,"stats":{"Line":1}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":1}},{"line":497,"address":[],"length":0,"stats":{"Line":1}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":4}},{"line":508,"address":[],"length":0,"stats":{"Line":4}},{"line":509,"address":[],"length":0,"stats":{"Line":2}},{"line":510,"address":[],"length":0,"stats":{"Line":2}},{"line":511,"address":[],"length":0,"stats":{"Line":2}},{"line":513,"address":[],"length":0,"stats":{"Line":2}},{"line":515,"address":[],"length":0,"stats":{"Line":2}},{"line":520,"address":[],"length":0,"stats":{"Line":2}},{"line":521,"address":[],"length":0,"stats":{"Line":1}},{"line":522,"address":[],"length":0,"stats":{"Line":1}},{"line":524,"address":[],"length":0,"stats":{"Line":1}},{"line":525,"address":[],"length":0,"stats":{"Line":2}},{"line":526,"address":[],"length":0,"stats":{"Line":1}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":22}},{"line":539,"address":[],"length":0,"stats":{"Line":44}},{"line":541,"address":[],"length":0,"stats":{"Line":14}},{"line":542,"address":[],"length":0,"stats":{"Line":14}},{"line":543,"address":[],"length":0,"stats":{"Line":14}},{"line":544,"address":[],"length":0,"stats":{"Line":14}},{"line":545,"address":[],"length":0,"stats":{"Line":14}},{"line":550,"address":[],"length":0,"stats":{"Line":2}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":2}},{"line":555,"address":[],"length":0,"stats":{"Line":2}},{"line":556,"address":[],"length":0,"stats":{"Line":2}},{"line":557,"address":[],"length":0,"stats":{"Line":2}},{"line":558,"address":[],"length":0,"stats":{"Line":2}},{"line":559,"address":[],"length":0,"stats":{"Line":2}},{"line":562,"address":[],"length":0,"stats":{"Line":2}},{"line":565,"address":[],"length":0,"stats":{"Line":4}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":4}},{"line":570,"address":[],"length":0,"stats":{"Line":2}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":2}},{"line":586,"address":[],"length":0,"stats":{"Line":4}},{"line":587,"address":[],"length":0,"stats":{"Line":4}},{"line":590,"address":[],"length":0,"stats":{"Line":4}},{"line":591,"address":[],"length":0,"stats":{"Line":10}},{"line":592,"address":[],"length":0,"stats":{"Line":4}},{"line":598,"address":[],"length":0,"stats":{"Line":6}},{"line":612,"address":[],"length":0,"stats":{"Line":4}},{"line":613,"address":[],"length":0,"stats":{"Line":22}}],"covered":119,"coverable":227},{"path":["/","Users","stippi","projects","code-assistant","src","llm","mod.rs"],"content":"#[cfg(test)]\nmod tests;\n\npub mod anthropic;\npub mod ollama;\npub mod openai;\npub mod types;\npub mod vertex;\n\npub use anthropic::AnthropicClient;\npub use ollama::OllamaClient;\npub use openai::OpenAIClient;\npub use types::*;\npub use vertex::VertexClient;\n\nuse anyhow::Result;\nuse async_trait::async_trait;\n\npub type StreamingCallback = Box\u003cdyn Fn(\u0026str) -\u003e Result\u003c()\u003e + Send + Sync\u003e;\n\n/// Trait for different LLM provider implementations\n#[async_trait]\npub trait LLMProvider {\n    /// Sends a request to the LLM service\n    async fn send_message(\n        \u0026self,\n        request: LLMRequest,\n        streaming_callback: Option\u003c\u0026StreamingCallback\u003e,\n    ) -\u003e Result\u003cLLMResponse\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","stippi","projects","code-assistant","src","llm","ollama.rs"],"content":"use crate::llm::{types::*, LLMProvider, StreamingCallback};\nuse anyhow::Result;\nuse async_trait::async_trait;\nuse reqwest::Client;\nuse serde::{Deserialize, Serialize};\nuse tracing::debug;\n\n#[derive(Debug, Serialize)]\nstruct OllamaRequest {\n    model: String,\n    messages: Vec\u003cOllamaMessage\u003e,\n    stream: bool,\n    options: OllamaOptions,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    tools: Option\u003cVec\u003cserde_json::Value\u003e\u003e,\n}\n\n#[derive(Debug, Serialize)]\nstruct OllamaOptions {\n    num_ctx: usize,\n}\n\n#[derive(Debug, Serialize)]\nstruct OllamaMessage {\n    role: String,\n    content: String,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OllamaResponse {\n    message: OllamaResponseMessage,\n    #[allow(dead_code)]\n    done_reason: Option\u003cString\u003e,\n    done: bool,\n    #[serde(default)]\n    prompt_eval_count: u32,\n    #[serde(default)]\n    eval_count: u32,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct OllamaToolCall {\n    function: OllamaFunction,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct OllamaFunction {\n    name: String,\n    arguments: serde_json::Value,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OllamaResponseMessage {\n    content: String,\n    tool_calls: Option\u003cVec\u003cOllamaToolCall\u003e\u003e,\n}\n\npub struct OllamaClient {\n    client: Client,\n    base_url: String,\n    model: String,\n    num_ctx: usize,\n}\n\nimpl OllamaClient {\n    pub fn new(model: String, num_ctx: usize) -\u003e Self {\n        Self {\n            client: Client::new(),\n            base_url: \"http://localhost:11434\".to_string(),\n            model,\n            num_ctx,\n        }\n    }\n\n    #[cfg(test)]\n    pub fn new_with_base_url(model: String, num_ctx: usize, base_url: String) -\u003e Self {\n        Self {\n            client: Client::new(),\n            base_url,\n            model,\n            num_ctx,\n        }\n    }\n\n    fn get_url(\u0026self) -\u003e String {\n        format!(\"{}/api/chat\", self.base_url)\n    }\n\n    fn convert_message(message: \u0026Message) -\u003e OllamaMessage {\n        OllamaMessage {\n            role: match message.role {\n                MessageRole::User =\u003e \"user\".to_string(),\n                MessageRole::Assistant =\u003e \"assistant\".to_string(),\n            },\n            content: match \u0026message.content {\n                MessageContent::Text(text) =\u003e text.clone(),\n                MessageContent::Structured(_) =\u003e \"[Structured content not supported]\".to_string(),\n            },\n        }\n    }\n\n    async fn try_send_request(\u0026self, request: \u0026OllamaRequest) -\u003e Result\u003cLLMResponse\u003e {\n        let response = self\n            .client\n            .post(\u0026self.get_url())\n            .json(request)\n            .send()\n            .await\n            .map_err(|e| anyhow::anyhow!(\"Network error: {}\", e))?;\n\n        // Store status code before consuming response\n        let status = response.status();\n\n        if !status.is_success() {\n            let error_text = response\n                .text()\n                .await\n                .unwrap_or_else(|_| \"Unknown error\".to_string());\n            return Err(anyhow::anyhow!(\n                \"Ollama request failed: Status {}, Error: {}\",\n                status,\n                error_text\n            ));\n        }\n\n        let ollama_response: OllamaResponse = response\n            .json()\n            .await\n            .map_err(|e| anyhow::anyhow!(\"Failed to parse Ollama response: {}\", e))?;\n\n        let mut content = Vec::new();\n\n        if !ollama_response.message.content.is_empty() {\n            content.push(ContentBlock::Text {\n                text: ollama_response.message.content,\n            });\n        }\n\n        if let Some(tool_calls) = ollama_response.message.tool_calls {\n            for (index, tool_call) in tool_calls.into_iter().enumerate() {\n                content.push(ContentBlock::ToolUse {\n                    id: format!(\"tool-{}\", index),\n                    name: tool_call.function.name,\n                    input: tool_call.function.arguments,\n                });\n            }\n        }\n\n        Ok(LLMResponse {\n            content,\n            usage: Usage {\n                input_tokens: ollama_response.prompt_eval_count,\n                output_tokens: ollama_response.eval_count,\n            },\n        })\n    }\n\n    async fn try_send_request_streaming(\n        \u0026self,\n        request: \u0026OllamaRequest,\n        streaming_callback: \u0026StreamingCallback,\n    ) -\u003e Result\u003cLLMResponse\u003e {\n        let response = self\n            .client\n            .post(\u0026self.get_url())\n            .json(request)\n            .send()\n            .await\n            .map_err(|e| anyhow::anyhow!(\"Network error: {}\", e))?;\n\n        // Store status code before consuming response\n        let status = response.status();\n        if !status.is_success() {\n            let error_text = response\n                .text()\n                .await\n                .unwrap_or_else(|_| \"Unknown error\".to_string());\n            return Err(anyhow::anyhow!(\n                \"Ollama request failed: Status {}, Error: {}\",\n                status,\n                error_text\n            ));\n        }\n\n        let mut response = response;\n        let mut line_buffer = String::new();\n        let mut accumulated_content = String::new();\n        let mut tool_calls = Vec::new();\n        let mut final_eval_counts = (0u32, 0u32); // (prompt_eval_count, eval_count)\n\n        while let Some(chunk) = response.chunk().await? {\n            for byte in chunk {\n                if byte == b'\\n' {\n                    if !line_buffer.is_empty() {\n                        if let Ok(chunk_response) =\n                            serde_json::from_str::\u003cOllamaResponse\u003e(\u0026line_buffer)\n                        {\n                            // Handle text content\n                            if !chunk_response.message.content.is_empty() {\n                                streaming_callback(\u0026chunk_response.message.content)?;\n                                accumulated_content.push_str(\u0026chunk_response.message.content);\n                            }\n\n                            // Handle tool calls - only collect complete tool calls from the response\n                            if let Some(chunk_tool_calls) = chunk_response.message.tool_calls {\n                                tool_calls.extend(chunk_tool_calls);\n                            }\n\n                            // Update eval counts from the final response\n                            if chunk_response.done {\n                                final_eval_counts =\n                                    (chunk_response.prompt_eval_count, chunk_response.eval_count);\n                            }\n                        }\n                        line_buffer.clear();\n                    }\n                } else {\n                    line_buffer.push(byte as char);\n                }\n            }\n        }\n\n        // Build final response\n        let mut content = Vec::new();\n\n        // Add accumulated text content if present\n        if !accumulated_content.is_empty() {\n            content.push(ContentBlock::Text {\n                text: accumulated_content,\n            });\n        }\n\n        // Add tool calls if present\n        for (index, tool_call) in tool_calls.into_iter().enumerate() {\n            content.push(ContentBlock::ToolUse {\n                id: format!(\"tool-{}\", index),\n                name: tool_call.function.name,\n                input: tool_call.function.arguments,\n            });\n        }\n\n        Ok(LLMResponse {\n            content,\n            usage: Usage {\n                input_tokens: final_eval_counts.0,\n                output_tokens: final_eval_counts.1,\n            },\n        })\n    }\n}\n\n#[async_trait]\nimpl LLMProvider for OllamaClient {\n    async fn send_message(\n        \u0026self,\n        request: LLMRequest,\n        streaming_callback: Option\u003c\u0026StreamingCallback\u003e,\n    ) -\u003e Result\u003cLLMResponse\u003e {\n        let mut messages: Vec\u003cOllamaMessage\u003e = Vec::new();\n\n        // Add system message\n        messages.push(OllamaMessage {\n            role: \"system\".to_string(),\n            content: request.system_prompt,\n        });\n\n        // Add conversation messages\n        messages.extend(request.messages.iter().map(Self::convert_message));\n\n        let mut ollama_request = OllamaRequest {\n            model: self.model.clone(),\n            messages,\n            stream: false,\n            options: OllamaOptions {\n                num_ctx: self.num_ctx,\n            },\n            tools: request.tools.map(|tools| {\n                tools\n                    .into_iter()\n                    .map(|tool| {\n                        serde_json::json!({\n                            \"type\": \"function\",\n                            \"function\": {\n                                \"name\": tool.name,\n                                \"description\": tool.description,\n                                \"parameters\": tool.parameters\n                            }\n                        })\n                    })\n                    .collect()\n            }),\n        };\n\n        debug!(\"Sending request to Ollama: {:?}\", ollama_request);\n\n        if let Some(callback) = streaming_callback {\n            ollama_request.stream = true;\n            self.try_send_request_streaming(\u0026ollama_request, callback)\n                .await\n        } else {\n            self.try_send_request(\u0026ollama_request).await\n        }\n    }\n}\n","traces":[{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":4}},{"line":86,"address":[],"length":0,"stats":{"Line":4}},{"line":89,"address":[],"length":0,"stats":{"Line":4}},{"line":91,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":102,"address":[],"length":0,"stats":{"Line":4}},{"line":103,"address":[],"length":0,"stats":{"Line":4}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":6}},{"line":109,"address":[],"length":0,"stats":{"Line":4}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":4}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":1}},{"line":140,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":142,"address":[],"length":0,"stats":{"Line":1}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":2}},{"line":151,"address":[],"length":0,"stats":{"Line":2}},{"line":152,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[],"length":0,"stats":{"Line":2}},{"line":158,"address":[],"length":0,"stats":{"Line":2}},{"line":163,"address":[],"length":0,"stats":{"Line":4}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":4}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":2}},{"line":186,"address":[],"length":0,"stats":{"Line":2}},{"line":187,"address":[],"length":0,"stats":{"Line":2}},{"line":188,"address":[],"length":0,"stats":{"Line":2}},{"line":189,"address":[],"length":0,"stats":{"Line":2}},{"line":191,"address":[],"length":0,"stats":{"Line":11}},{"line":192,"address":[],"length":0,"stats":{"Line":699}},{"line":194,"address":[],"length":0,"stats":{"Line":3}},{"line":195,"address":[],"length":0,"stats":{"Line":3}},{"line":196,"address":[],"length":0,"stats":{"Line":3}},{"line":200,"address":[],"length":0,"stats":{"Line":2}},{"line":201,"address":[],"length":0,"stats":{"Line":2}},{"line":205,"address":[],"length":0,"stats":{"Line":4}},{"line":210,"address":[],"length":0,"stats":{"Line":2}},{"line":211,"address":[],"length":0,"stats":{"Line":2}},{"line":212,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[],"length":0,"stats":{"Line":3}},{"line":218,"address":[],"length":0,"stats":{"Line":345}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":227,"address":[],"length":0,"stats":{"Line":3}},{"line":228,"address":[],"length":0,"stats":{"Line":1}},{"line":229,"address":[],"length":0,"stats":{"Line":1}},{"line":234,"address":[],"length":0,"stats":{"Line":4}},{"line":235,"address":[],"length":0,"stats":{"Line":1}},{"line":236,"address":[],"length":0,"stats":{"Line":1}},{"line":237,"address":[],"length":0,"stats":{"Line":1}},{"line":238,"address":[],"length":0,"stats":{"Line":1}},{"line":242,"address":[],"length":0,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":2}},{"line":244,"address":[],"length":0,"stats":{"Line":2}},{"line":245,"address":[],"length":0,"stats":{"Line":2}},{"line":246,"address":[],"length":0,"stats":{"Line":2}},{"line":259,"address":[],"length":0,"stats":{"Line":4}},{"line":262,"address":[],"length":0,"stats":{"Line":4}},{"line":263,"address":[],"length":0,"stats":{"Line":4}},{"line":264,"address":[],"length":0,"stats":{"Line":4}},{"line":268,"address":[],"length":0,"stats":{"Line":4}},{"line":271,"address":[],"length":0,"stats":{"Line":4}},{"line":274,"address":[],"length":0,"stats":{"Line":4}},{"line":277,"address":[],"length":0,"stats":{"Line":6}},{"line":294,"address":[],"length":0,"stats":{"Line":4}},{"line":296,"address":[],"length":0,"stats":{"Line":6}},{"line":299,"address":[],"length":0,"stats":{"Line":5}},{"line":301,"address":[],"length":0,"stats":{"Line":8}}],"covered":81,"coverable":99},{"path":["/","Users","stippi","projects","code-assistant","src","llm","openai.rs"],"content":"use crate::llm::{\n    types::*, ApiError, ApiErrorContext, LLMProvider, RateLimitHandler, StreamingCallback,\n};\nuse anyhow::Result;\nuse async_trait::async_trait;\nuse reqwest::{Client, Response, StatusCode};\nuse serde::{Deserialize, Serialize};\nuse std::time::Duration;\nuse tokio::time::sleep;\nuse tracing::{debug, warn};\n\n#[derive(Debug, Serialize, Clone)]\nstruct OpenAIRequest {\n    model: String,\n    messages: Vec\u003cOpenAIChatMessage\u003e,\n    temperature: f32,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    stream: Option\u003cbool\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    tools: Option\u003cVec\u003cserde_json::Value\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    tool_choice: Option\u003cserde_json::Value\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    stream_options: Option\u003cStreamOptions\u003e,\n}\n\n#[derive(Debug, Serialize, Clone)]\nstruct StreamOptions {\n    include_usage: bool,\n}\n\nimpl OpenAIRequest {\n    fn into_streaming(mut self) -\u003e Self {\n        self.stream = Some(true);\n        self.stream_options = Some(StreamOptions {\n            include_usage: true,\n        });\n        self\n    }\n\n    fn into_non_streaming(mut self) -\u003e Self {\n        self.stream = None;\n        self.stream_options = None;\n        self\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\nstruct OpenAIChatMessage {\n    role: String,\n    #[serde(default)]\n    content: String,\n    #[serde(default)]\n    tool_calls: Option\u003cVec\u003cOpenAIToolCall\u003e\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\nstruct OpenAIToolCall {\n    id: String,\n    #[serde(rename = \"type\")]\n    call_type: String,\n    function: OpenAIFunction,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\nstruct OpenAIFunction {\n    name: String,\n    arguments: String,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OpenAIResponse {\n    choices: Vec\u003cOpenAIChoice\u003e,\n    usage: OpenAIUsage,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OpenAIChoice {\n    message: OpenAIChatMessage,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OpenAIStreamResponse {\n    choices: Vec\u003cOpenAIStreamChoice\u003e,\n    #[serde(default)]\n    usage: Option\u003cOpenAIUsage\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OpenAIStreamChoice {\n    delta: OpenAIDelta,\n    #[serde(rename = \"finish_reason\")]\n    finish_reason: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OpenAIDelta {\n    #[serde(default)]\n    content: Option\u003cString\u003e,\n    #[allow(dead_code)]\n    #[serde(default)]\n    role: Option\u003cString\u003e,\n    #[serde(default)]\n    tool_calls: Option\u003cVec\u003cOpenAIToolCallDelta\u003e\u003e,\n}\n\n#[derive(Debug, Deserialize, Clone)]\nstruct OpenAIToolCallDelta {\n    #[allow(dead_code)]\n    #[serde(default)]\n    index: usize,\n    #[serde(default)]\n    id: Option\u003cString\u003e,\n    #[allow(dead_code)]\n    #[serde(rename = \"type\")]\n    #[serde(default)]\n    call_type: Option\u003cString\u003e,\n    #[serde(default)]\n    function: Option\u003cOpenAIFunctionDelta\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OpenAIUsage {\n    prompt_tokens: u32,\n    completion_tokens: u32,\n    #[allow(dead_code)]\n    total_tokens: u32,\n}\n\n#[derive(Debug, Deserialize, Clone)]\nstruct OpenAIFunctionDelta {\n    #[serde(default)]\n    name: Option\u003cString\u003e,\n    #[serde(default)]\n    arguments: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OpenAIErrorResponse {\n    error: OpenAIError,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OpenAIError {\n    message: String,\n    #[serde(rename = \"type\")]\n    code: Option\u003cString\u003e,\n}\n\n/// Rate limit information extracted from response headers\n#[derive(Debug)]\nstruct OpenAIRateLimitInfo {\n    requests_limit: Option\u003cu32\u003e,\n    requests_remaining: Option\u003cu32\u003e,\n    requests_reset: Option\u003cDuration\u003e,\n    tokens_limit: Option\u003cu32\u003e,\n    tokens_remaining: Option\u003cu32\u003e,\n    tokens_reset: Option\u003cDuration\u003e,\n}\n\nimpl RateLimitHandler for OpenAIRateLimitInfo {\n    fn from_response(response: \u0026Response) -\u003e Self {\n        let headers = response.headers();\n\n        fn parse_header\u003cT: std::str::FromStr\u003e(\n            headers: \u0026reqwest::header::HeaderMap,\n            name: \u0026str,\n        ) -\u003e Option\u003cT\u003e {\n            headers\n                .get(name)\n                .and_then(|h| h.to_str().ok())\n                .and_then(|s| s.parse().ok())\n        }\n\n        fn parse_duration(headers: \u0026reqwest::header::HeaderMap, name: \u0026str) -\u003e Option\u003cDuration\u003e {\n            headers\n                .get(name)\n                .and_then(|h| h.to_str().ok())\n                .and_then(|s| {\n                    // Parse OpenAI's duration format (e.g., \"1s\", \"6m0s\")\n                    let mut seconds = 0u64;\n                    let mut current_num = String::new();\n\n                    for c in s.chars() {\n                        match c {\n                            '0'..='9' =\u003e current_num.push(c),\n                            'm' =\u003e {\n                                if let Ok(mins) = current_num.parse::\u003cu64\u003e() {\n                                    seconds += mins * 60;\n                                }\n                                current_num.clear();\n                            }\n                            's' =\u003e {\n                                if let Ok(secs) = current_num.parse::\u003cu64\u003e() {\n                                    seconds += secs;\n                                }\n                                current_num.clear();\n                            }\n                            _ =\u003e current_num.clear(),\n                        }\n                    }\n                    Some(Duration::from_secs(seconds))\n                })\n        }\n\n        Self {\n            requests_limit: parse_header(headers, \"x-ratelimit-limit-requests\"),\n            requests_remaining: parse_header(headers, \"x-ratelimit-remaining-requests\"),\n            requests_reset: parse_duration(headers, \"x-ratelimit-reset-requests\"),\n            tokens_limit: parse_header(headers, \"x-ratelimit-limit-tokens\"),\n            tokens_remaining: parse_header(headers, \"x-ratelimit-remaining-tokens\"),\n            tokens_reset: parse_duration(headers, \"x-ratelimit-reset-tokens\"),\n        }\n    }\n\n    fn get_retry_delay(\u0026self) -\u003e Duration {\n        // Take the longer of the two reset times if both are present\n        let mut delay = Duration::from_secs(2); // Default fallback\n\n        if let Some(requests_reset) = self.requests_reset {\n            delay = delay.max(requests_reset);\n        }\n\n        if let Some(tokens_reset) = self.tokens_reset {\n            delay = delay.max(tokens_reset);\n        }\n\n        // Add a small buffer\n        delay + Duration::from_secs(1)\n    }\n\n    fn log_status(\u0026self) {\n        debug!(\n            \"OpenAI Rate limits - Requests: {}/{} (reset in: {}s), Tokens: {}/{} (reset in: {}s)\",\n            self.requests_remaining\n                .map_or(\"?\".to_string(), |r| r.to_string()),\n            self.requests_limit\n                .map_or(\"?\".to_string(), |l| l.to_string()),\n            self.requests_reset.map_or(0, |d| d.as_secs()),\n            self.tokens_remaining\n                .map_or(\"?\".to_string(), |r| r.to_string()),\n            self.tokens_limit.map_or(\"?\".to_string(), |l| l.to_string()),\n            self.tokens_reset.map_or(0, |d| d.as_secs()),\n        );\n    }\n}\n\npub struct OpenAIClient {\n    client: Client,\n    api_key: String,\n    base_url: String,\n    model: String,\n}\n\nimpl OpenAIClient {\n    pub fn new(api_key: String, model: String) -\u003e Self {\n        Self {\n            client: Client::new(),\n            api_key,\n            base_url: \"https://api.openai.com/v1\".to_string(),\n            model,\n        }\n    }\n\n    #[cfg(test)]\n    pub fn new_with_base_url(api_key: String, model: String, base_url: String) -\u003e Self {\n        Self {\n            client: Client::new(),\n            api_key,\n            base_url,\n            model,\n        }\n    }\n\n    fn get_url(\u0026self) -\u003e String {\n        format!(\"{}/chat/completions\", self.base_url)\n    }\n\n    fn convert_message(message: \u0026Message) -\u003e OpenAIChatMessage {\n        OpenAIChatMessage {\n            role: match message.role {\n                MessageRole::User =\u003e \"user\".to_string(),\n                MessageRole::Assistant =\u003e \"assistant\".to_string(),\n            },\n            content: match \u0026message.content {\n                MessageContent::Text(text) =\u003e text.clone(),\n                MessageContent::Structured(_) =\u003e {\n                    // For now, we'll just convert structured content to a simple text message\n                    // This could be enhanced to handle OpenAI's specific formats\n                    \"[Structured content not supported]\".to_string()\n                }\n            },\n            tool_calls: None,\n        }\n    }\n\n    async fn send_with_retry(\n        \u0026self,\n        request: \u0026OpenAIRequest,\n        streaming_callback: Option\u003c\u0026StreamingCallback\u003e,\n        max_retries: u32,\n    ) -\u003e Result\u003cLLMResponse\u003e {\n        let mut attempts = 0;\n\n        loop {\n            match if let Some(callback) = streaming_callback {\n                self.try_send_request_streaming(request, callback).await\n            } else {\n                self.try_send_request(request).await\n            } {\n                Ok((response, rate_limits)) =\u003e {\n                    rate_limits.log_status();\n                    return Ok(response);\n                }\n                Err(e) =\u003e {\n                    let rate_limits = e\n                        .downcast_ref::\u003cApiErrorContext\u003cOpenAIRateLimitInfo\u003e\u003e()\n                        .and_then(|ctx| ctx.rate_limits.as_ref());\n\n                    match e.downcast_ref::\u003cApiError\u003e() {\n                        Some(ApiError::RateLimit(_)) =\u003e {\n                            if let Some(rate_limits) = rate_limits {\n                                if attempts \u003c max_retries {\n                                    attempts += 1;\n                                    let delay = rate_limits.get_retry_delay();\n                                    warn!(\n                                        \"OpenAI rate limit hit (attempt {}/{}), waiting {} seconds before retry\",\n                                        attempts,\n                                        max_retries,\n                                        delay.as_secs()\n                                    );\n                                    sleep(delay).await;\n                                    continue;\n                                }\n                            }\n                        }\n                        Some(ApiError::ServiceError(_)) | Some(ApiError::NetworkError(_)) =\u003e {\n                            if attempts \u003c max_retries {\n                                attempts += 1;\n                                let delay = Duration::from_secs(2u64.pow(attempts - 1));\n                                warn!(\n                                    \"Error: {} (attempt {}/{}), retrying in {} seconds\",\n                                    e,\n                                    attempts,\n                                    max_retries,\n                                    delay.as_secs()\n                                );\n                                sleep(delay).await;\n                                continue;\n                            }\n                        }\n                        _ =\u003e {} // Don't retry other types of errors\n                    }\n                    return Err(e);\n                }\n            }\n        }\n    }\n\n    async fn check_response_error(response: Response) -\u003e Result\u003cResponse\u003e {\n        let status = response.status();\n        if status.is_success() {\n            debug!(\"Response status is success\");\n            return Ok(response);\n        }\n\n        let rate_limits = OpenAIRateLimitInfo::from_response(\u0026response);\n        let response_text = response\n            .text()\n            .await\n            .map_err(|e| ApiError::NetworkError(e.to_string()))?;\n\n        let error = if let Ok(error_response) =\n            serde_json::from_str::\u003cOpenAIErrorResponse\u003e(\u0026response_text)\n        {\n            match (status, error_response.error.code.as_deref()) {\n                (StatusCode::TOO_MANY_REQUESTS, _) =\u003e {\n                    ApiError::RateLimit(error_response.error.message)\n                }\n                (StatusCode::UNAUTHORIZED, _) =\u003e {\n                    ApiError::Authentication(error_response.error.message)\n                }\n                (StatusCode::BAD_REQUEST, _) =\u003e {\n                    ApiError::InvalidRequest(error_response.error.message)\n                }\n                (status, _) if status.is_server_error() =\u003e {\n                    ApiError::ServiceError(error_response.error.message)\n                }\n                _ =\u003e ApiError::Unknown(error_response.error.message),\n            }\n        } else {\n            ApiError::Unknown(format!(\"Status {}: {}\", status, response_text))\n        };\n\n        Err(ApiErrorContext {\n            error,\n            rate_limits: Some(rate_limits),\n        }\n        .into())\n    }\n\n    async fn try_send_request(\n        \u0026self,\n        request: \u0026OpenAIRequest,\n    ) -\u003e Result\u003c(LLMResponse, OpenAIRateLimitInfo)\u003e {\n        let request = request.clone().into_non_streaming();\n        let response = self\n            .client\n            .post(\u0026self.get_url())\n            .header(\"Authorization\", format!(\"Bearer {}\", self.api_key))\n            .header(\"Content-Type\", \"application/json\")\n            .json(\u0026request)\n            .send()\n            .await\n            .map_err(|e| ApiError::NetworkError(e.to_string()))?;\n\n        let response = Self::check_response_error(response).await?;\n        let rate_limits = OpenAIRateLimitInfo::from_response(\u0026response);\n\n        let response_text = response\n            .text()\n            .await\n            .map_err(|e| ApiError::NetworkError(e.to_string()))?;\n\n        // Parse the successful response\n        let openai_response: OpenAIResponse = serde_json::from_str(\u0026response_text)\n            .map_err(|e| ApiError::Unknown(format!(\"Failed to parse response: {}\", e)))?;\n\n        // Convert to our generic LLMResponse format\n        Ok((\n            LLMResponse {\n                content: {\n                    let mut blocks = Vec::new();\n\n                    // Add text content if present\n                    if !openai_response.choices[0].message.content.is_empty() {\n                        blocks.push(ContentBlock::Text {\n                            text: openai_response.choices[0].message.content.clone(),\n                        });\n                    }\n\n                    // Add tool calls if present\n                    if let Some(ref tool_calls) = openai_response.choices[0].message.tool_calls {\n                        for call in tool_calls {\n                            let input =\n                                serde_json::from_str(\u0026call.function.arguments).map_err(|e| {\n                                    ApiError::Unknown(format!(\n                                        \"Failed to parse tool arguments: {}\",\n                                        e\n                                    ))\n                                })?;\n                            blocks.push(ContentBlock::ToolUse {\n                                id: call.id.clone(),\n                                name: call.function.name.clone(),\n                                input,\n                            });\n                        }\n                    }\n\n                    blocks\n                },\n                usage: Usage {\n                    input_tokens: openai_response.usage.prompt_tokens,\n                    output_tokens: openai_response.usage.completion_tokens,\n                },\n            },\n            rate_limits,\n        ))\n    }\n\n    async fn try_send_request_streaming(\n        \u0026self,\n        request: \u0026OpenAIRequest,\n        streaming_callback: \u0026StreamingCallback,\n    ) -\u003e Result\u003c(LLMResponse, OpenAIRateLimitInfo)\u003e {\n        debug!(\"Sending streaming request\");\n        let request = request.clone().into_streaming();\n        let response = self\n            .client\n            .post(\u0026self.get_url())\n            .header(\"Authorization\", format!(\"Bearer {}\", self.api_key))\n            .header(\"Content-Type\", \"application/json\")\n            .json(\u0026request)\n            .send()\n            .await\n            .map_err(|e| ApiError::NetworkError(e.to_string()))?;\n\n        let mut response = Self::check_response_error(response).await?;\n\n        let mut accumulated_content: Option\u003cString\u003e = None;\n        let mut accumulated_tool_calls: Vec\u003cContentBlock\u003e = Vec::new();\n        let mut current_tool: Option\u003cOpenAIToolCallDelta\u003e = None;\n\n        let mut line_buffer = String::new();\n        let mut usage = None;\n\n        fn process_chunk(\n            chunk: \u0026[u8],\n            line_buffer: \u0026mut String,\n            accumulated_content: \u0026mut Option\u003cString\u003e,\n            current_tool: \u0026mut Option\u003cOpenAIToolCallDelta\u003e,\n            accumulated_tool_calls: \u0026mut Vec\u003cContentBlock\u003e,\n            callback: \u0026StreamingCallback,\n            usage: \u0026mut Option\u003cOpenAIUsage\u003e,\n        ) -\u003e Result\u003c()\u003e {\n            let chunk_str = std::str::from_utf8(chunk)?;\n\n            for c in chunk_str.chars() {\n                if c == '\\n' {\n                    if !line_buffer.is_empty() {\n                        process_sse_line(\n                            line_buffer,\n                            accumulated_content,\n                            current_tool,\n                            accumulated_tool_calls,\n                            callback,\n                            usage,\n                        )?;\n                        line_buffer.clear();\n                    }\n                } else {\n                    line_buffer.push(c);\n                }\n            }\n            Ok(())\n        }\n\n        fn process_sse_line(\n            line: \u0026str,\n            accumulated_content: \u0026mut Option\u003cString\u003e,\n            current_tool: \u0026mut Option\u003cOpenAIToolCallDelta\u003e,\n            accumulated_tool_calls: \u0026mut Vec\u003cContentBlock\u003e,\n            callback: \u0026StreamingCallback,\n            usage: \u0026mut Option\u003cOpenAIUsage\u003e,\n        ) -\u003e Result\u003c()\u003e {\n            if let Some(data) = line.strip_prefix(\"data: \") {\n                // Skip \"[DONE]\" message\n                if data == \"[DONE]\" {\n                    return Ok(());\n                }\n\n                if let Ok(chunk_response) = serde_json::from_str::\u003cOpenAIStreamResponse\u003e(data) {\n                    if let Some(delta) = chunk_response.choices.get(0) {\n                        // Handle content streaming\n                        if let Some(content) = \u0026delta.delta.content {\n                            callback(content)?;\n                            *accumulated_content = Some(\n                                accumulated_content\n                                    .as_ref()\n                                    .unwrap_or(\u0026String::new())\n                                    .clone()\n                                    + content,\n                            );\n                        }\n\n                        // Handle tool calls\n                        if let Some(tool_calls) = \u0026delta.delta.tool_calls {\n                            for tool_call in tool_calls {\n                                if let Some(function) = \u0026tool_call.function {\n                                    if tool_call.id.is_some() {\n                                        // New tool call\n                                        if let Some(prev_tool) = current_tool.take() {\n                                            accumulated_tool_calls\n                                                .push(OpenAIClient::build_tool_block(prev_tool)?);\n                                        }\n                                        *current_tool = Some(tool_call.clone());\n                                    } else if let Some(curr_tool) = current_tool {\n                                        // Update existing tool\n                                        if let Some(args) = \u0026function.arguments {\n                                            if let Some(ref mut curr_func) = curr_tool.function {\n                                                curr_func.arguments = Some(\n                                                    curr_func\n                                                        .arguments\n                                                        .as_ref()\n                                                        .unwrap_or(\u0026String::new())\n                                                        .clone()\n                                                        + args,\n                                                );\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        // Handle completion\n                        if delta.finish_reason.is_some() {\n                            if let Some(tool) = current_tool.take() {\n                                accumulated_tool_calls.push(OpenAIClient::build_tool_block(tool)?);\n                            }\n                        }\n                    }\n                    // Capture usage data from final chunk\n                    if let Some(chunk_usage) = chunk_response.usage {\n                        *usage = Some(chunk_usage);\n                    }\n                }\n            }\n            Ok(())\n        }\n\n        while let Some(chunk) = response.chunk().await? {\n            process_chunk(\n                \u0026chunk,\n                \u0026mut line_buffer,\n                \u0026mut accumulated_content,\n                \u0026mut current_tool,\n                \u0026mut accumulated_tool_calls,\n                streaming_callback,\n                \u0026mut usage,\n            )?;\n        }\n\n        // Process any remaining data in the buffer\n        if !line_buffer.is_empty() {\n            process_sse_line(\n                \u0026line_buffer,\n                \u0026mut accumulated_content,\n                \u0026mut current_tool,\n                \u0026mut accumulated_tool_calls,\n                streaming_callback,\n                \u0026mut usage,\n            )?;\n        }\n\n        let mut content = Vec::new();\n        if let Some(text) = accumulated_content {\n            content.push(ContentBlock::Text { text });\n        }\n        content.extend(accumulated_tool_calls);\n\n        Ok((\n            LLMResponse {\n                content,\n                usage: usage\n                    .map(|u| Usage {\n                        input_tokens: u.prompt_tokens,\n                        output_tokens: u.completion_tokens,\n                    })\n                    .unwrap_or(Usage {\n                        input_tokens: 0,\n                        output_tokens: 0,\n                    }),\n            },\n            OpenAIRateLimitInfo::from_response(\u0026response),\n        ))\n    }\n\n    fn build_tool_block(tool: OpenAIToolCallDelta) -\u003e Result\u003cContentBlock\u003e {\n        let function = tool\n            .function\n            .ok_or_else(|| anyhow::anyhow!(\"Tool call without function\"))?;\n        let name = function\n            .name\n            .ok_or_else(|| anyhow::anyhow!(\"Function without name\"))?;\n        let args = function.arguments.unwrap_or_default();\n\n        Ok(ContentBlock::ToolUse {\n            id: tool.id.unwrap_or_default(),\n            name,\n            input: serde_json::from_str(\u0026args)\n                .map_err(|e| anyhow::anyhow!(\"Invalid JSON in arguments: {}\", e))?,\n        })\n    }\n}\n\n#[async_trait]\nimpl LLMProvider for OpenAIClient {\n    async fn send_message(\n        \u0026self,\n        request: LLMRequest,\n        streaming_callback: Option\u003c\u0026StreamingCallback\u003e,\n    ) -\u003e Result\u003cLLMResponse\u003e {\n        let mut messages: Vec\u003cOpenAIChatMessage\u003e = Vec::new();\n\n        // Add system message\n        messages.push(OpenAIChatMessage {\n            role: \"system\".to_string(),\n            content: request.system_prompt,\n            tool_calls: None,\n        });\n\n        // Add conversation messages\n        messages.extend(request.messages.iter().map(Self::convert_message));\n\n        let openai_request = OpenAIRequest {\n            model: self.model.clone(),\n            messages,\n            temperature: 1.0,\n            stream: None,\n            stream_options: None,\n            tool_choice: match \u0026request.tools {\n                Some(_) =\u003e Some(serde_json::json!(\"required\")),\n                _ =\u003e None,\n            },\n            tools: request.tools.map(|tools| {\n                tools\n                    .into_iter()\n                    .map(|tool| {\n                        serde_json::json!({\n                            \"type\": \"function\",\n                            \"function\": {\n                                \"name\": tool.name,\n                                \"description\": tool.description,\n                                \"parameters\": tool.parameters\n                            }\n                        })\n                    })\n                    .collect()\n            }),\n        };\n\n        self.send_with_retry(\u0026openai_request, streaming_callback, 3)\n            .await\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":34,"address":[],"length":0,"stats":{"Line":2}},{"line":35,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":4}},{"line":163,"address":[],"length":0,"stats":{"Line":4}},{"line":165,"address":[],"length":0,"stats":{"Line":16}},{"line":169,"address":[],"length":0,"stats":{"Line":16}},{"line":170,"address":[],"length":0,"stats":{"Line":16}},{"line":171,"address":[],"length":0,"stats":{"Line":32}},{"line":172,"address":[],"length":0,"stats":{"Line":32}},{"line":175,"address":[],"length":0,"stats":{"Line":8}},{"line":176,"address":[],"length":0,"stats":{"Line":8}},{"line":177,"address":[],"length":0,"stats":{"Line":8}},{"line":178,"address":[],"length":0,"stats":{"Line":16}},{"line":179,"address":[],"length":0,"stats":{"Line":8}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":4}},{"line":208,"address":[],"length":0,"stats":{"Line":4}},{"line":209,"address":[],"length":0,"stats":{"Line":4}},{"line":210,"address":[],"length":0,"stats":{"Line":4}},{"line":211,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":4}},{"line":233,"address":[],"length":0,"stats":{"Line":4}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":2}},{"line":268,"address":[],"length":0,"stats":{"Line":2}},{"line":275,"address":[],"length":0,"stats":{"Line":4}},{"line":276,"address":[],"length":0,"stats":{"Line":4}},{"line":279,"address":[],"length":0,"stats":{"Line":4}},{"line":281,"address":[],"length":0,"stats":{"Line":4}},{"line":285,"address":[],"length":0,"stats":{"Line":4}},{"line":297,"address":[],"length":0,"stats":{"Line":4}},{"line":303,"address":[],"length":0,"stats":{"Line":4}},{"line":306,"address":[],"length":0,"stats":{"Line":6}},{"line":307,"address":[],"length":0,"stats":{"Line":14}},{"line":309,"address":[],"length":0,"stats":{"Line":8}},{"line":311,"address":[],"length":0,"stats":{"Line":4}},{"line":312,"address":[],"length":0,"stats":{"Line":4}},{"line":313,"address":[],"length":0,"stats":{"Line":4}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":8}},{"line":361,"address":[],"length":0,"stats":{"Line":4}},{"line":362,"address":[],"length":0,"stats":{"Line":4}},{"line":363,"address":[],"length":0,"stats":{"Line":4}},{"line":364,"address":[],"length":0,"stats":{"Line":4}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":2}},{"line":406,"address":[],"length":0,"stats":{"Line":2}},{"line":407,"address":[],"length":0,"stats":{"Line":4}},{"line":408,"address":[],"length":0,"stats":{"Line":2}},{"line":409,"address":[],"length":0,"stats":{"Line":2}},{"line":410,"address":[],"length":0,"stats":{"Line":2}},{"line":412,"address":[],"length":0,"stats":{"Line":2}},{"line":414,"address":[],"length":0,"stats":{"Line":6}},{"line":415,"address":[],"length":0,"stats":{"Line":4}},{"line":417,"address":[],"length":0,"stats":{"Line":2}},{"line":418,"address":[],"length":0,"stats":{"Line":2}},{"line":420,"address":[],"length":0,"stats":{"Line":4}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":4}},{"line":426,"address":[],"length":0,"stats":{"Line":2}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":1}},{"line":437,"address":[],"length":0,"stats":{"Line":1}},{"line":438,"address":[],"length":0,"stats":{"Line":1}},{"line":443,"address":[],"length":0,"stats":{"Line":1}},{"line":444,"address":[],"length":0,"stats":{"Line":3}},{"line":445,"address":[],"length":0,"stats":{"Line":1}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":1}},{"line":453,"address":[],"length":0,"stats":{"Line":1}},{"line":454,"address":[],"length":0,"stats":{"Line":1}},{"line":455,"address":[],"length":0,"stats":{"Line":1}},{"line":460,"address":[],"length":0,"stats":{"Line":2}},{"line":462,"address":[],"length":0,"stats":{"Line":2}},{"line":463,"address":[],"length":0,"stats":{"Line":2}},{"line":464,"address":[],"length":0,"stats":{"Line":2}},{"line":467,"address":[],"length":0,"stats":{"Line":2}},{"line":471,"address":[],"length":0,"stats":{"Line":2}},{"line":476,"address":[],"length":0,"stats":{"Line":2}},{"line":477,"address":[],"length":0,"stats":{"Line":2}},{"line":478,"address":[],"length":0,"stats":{"Line":2}},{"line":485,"address":[],"length":0,"stats":{"Line":2}},{"line":486,"address":[],"length":0,"stats":{"Line":4}},{"line":488,"address":[],"length":0,"stats":{"Line":2}},{"line":490,"address":[],"length":0,"stats":{"Line":2}},{"line":491,"address":[],"length":0,"stats":{"Line":2}},{"line":492,"address":[],"length":0,"stats":{"Line":2}},{"line":494,"address":[],"length":0,"stats":{"Line":2}},{"line":495,"address":[],"length":0,"stats":{"Line":2}},{"line":497,"address":[],"length":0,"stats":{"Line":12}},{"line":506,"address":[],"length":0,"stats":{"Line":24}},{"line":508,"address":[],"length":0,"stats":{"Line":1091}},{"line":509,"address":[],"length":0,"stats":{"Line":1091}},{"line":510,"address":[],"length":0,"stats":{"Line":24}},{"line":512,"address":[],"length":0,"stats":{"Line":12}},{"line":513,"address":[],"length":0,"stats":{"Line":12}},{"line":514,"address":[],"length":0,"stats":{"Line":12}},{"line":515,"address":[],"length":0,"stats":{"Line":12}},{"line":516,"address":[],"length":0,"stats":{"Line":12}},{"line":517,"address":[],"length":0,"stats":{"Line":12}},{"line":519,"address":[],"length":0,"stats":{"Line":12}},{"line":522,"address":[],"length":0,"stats":{"Line":1067}},{"line":525,"address":[],"length":0,"stats":{"Line":12}},{"line":528,"address":[],"length":0,"stats":{"Line":12}},{"line":536,"address":[],"length":0,"stats":{"Line":24}},{"line":539,"address":[],"length":0,"stats":{"Line":2}},{"line":542,"address":[],"length":0,"stats":{"Line":10}},{"line":543,"address":[],"length":0,"stats":{"Line":10}},{"line":545,"address":[],"length":0,"stats":{"Line":2}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":2}},{"line":548,"address":[],"length":0,"stats":{"Line":2}},{"line":549,"address":[],"length":0,"stats":{"Line":2}},{"line":550,"address":[],"length":0,"stats":{"Line":2}},{"line":551,"address":[],"length":0,"stats":{"Line":2}},{"line":552,"address":[],"length":0,"stats":{"Line":2}},{"line":557,"address":[],"length":0,"stats":{"Line":16}},{"line":558,"address":[],"length":0,"stats":{"Line":18}},{"line":559,"address":[],"length":0,"stats":{"Line":6}},{"line":562,"address":[],"length":0,"stats":{"Line":1}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":1}},{"line":567,"address":[],"length":0,"stats":{"Line":10}},{"line":569,"address":[],"length":0,"stats":{"Line":5}},{"line":570,"address":[],"length":0,"stats":{"Line":10}},{"line":571,"address":[],"length":0,"stats":{"Line":5}},{"line":572,"address":[],"length":0,"stats":{"Line":5}},{"line":573,"address":[],"length":0,"stats":{"Line":5}},{"line":574,"address":[],"length":0,"stats":{"Line":5}},{"line":575,"address":[],"length":0,"stats":{"Line":5}},{"line":576,"address":[],"length":0,"stats":{"Line":5}},{"line":577,"address":[],"length":0,"stats":{"Line":5}},{"line":587,"address":[],"length":0,"stats":{"Line":10}},{"line":588,"address":[],"length":0,"stats":{"Line":3}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":12}},{"line":595,"address":[],"length":0,"stats":{"Line":1}},{"line":599,"address":[],"length":0,"stats":{"Line":10}},{"line":602,"address":[],"length":0,"stats":{"Line":38}},{"line":604,"address":[],"length":0,"stats":{"Line":12}},{"line":605,"address":[],"length":0,"stats":{"Line":12}},{"line":606,"address":[],"length":0,"stats":{"Line":12}},{"line":607,"address":[],"length":0,"stats":{"Line":12}},{"line":608,"address":[],"length":0,"stats":{"Line":12}},{"line":609,"address":[],"length":0,"stats":{"Line":12}},{"line":610,"address":[],"length":0,"stats":{"Line":12}},{"line":615,"address":[],"length":0,"stats":{"Line":2}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":2}},{"line":627,"address":[],"length":0,"stats":{"Line":2}},{"line":628,"address":[],"length":0,"stats":{"Line":1}},{"line":630,"address":[],"length":0,"stats":{"Line":2}},{"line":632,"address":[],"length":0,"stats":{"Line":2}},{"line":633,"address":[],"length":0,"stats":{"Line":2}},{"line":634,"address":[],"length":0,"stats":{"Line":2}},{"line":635,"address":[],"length":0,"stats":{"Line":2}},{"line":636,"address":[],"length":0,"stats":{"Line":3}},{"line":637,"address":[],"length":0,"stats":{"Line":1}},{"line":638,"address":[],"length":0,"stats":{"Line":1}},{"line":649,"address":[],"length":0,"stats":{"Line":1}},{"line":650,"address":[],"length":0,"stats":{"Line":2}},{"line":651,"address":[],"length":0,"stats":{"Line":1}},{"line":652,"address":[],"length":0,"stats":{"Line":2}},{"line":653,"address":[],"length":0,"stats":{"Line":1}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":4}},{"line":677,"address":[],"length":0,"stats":{"Line":4}},{"line":678,"address":[],"length":0,"stats":{"Line":4}},{"line":679,"address":[],"length":0,"stats":{"Line":4}},{"line":680,"address":[],"length":0,"stats":{"Line":4}},{"line":684,"address":[],"length":0,"stats":{"Line":4}},{"line":687,"address":[],"length":0,"stats":{"Line":4}},{"line":692,"address":[],"length":0,"stats":{"Line":4}},{"line":696,"address":[],"length":0,"stats":{"Line":6}},{"line":713,"address":[],"length":0,"stats":{"Line":4}},{"line":714,"address":[],"length":0,"stats":{"Line":20}}],"covered":172,"coverable":257},{"path":["/","Users","stippi","projects","code-assistant","src","llm","tests.rs"],"content":"use super::*;\nuse crate::types::ToolDefinition;\nuse crate::{AnthropicClient, LLMProvider, OpenAIClient};\nuse anyhow::Result;\nuse axum::extract::Path;\nuse axum::{response::IntoResponse, routing::post, Router};\nuse bytes::Bytes;\nuse futures::stream;\nuse serde_json::json;\nuse std::net::SocketAddr;\nuse std::sync::Arc;\nuse std::sync::Mutex;\nuse tokio::net::TcpListener;\n\n// Test scenario definition\n#[derive(Clone)]\nstruct TestCase {\n    name: String,\n    request: LLMRequest,\n    expected_chunks: Vec\u003cString\u003e,\n    expected_response: LLMResponse,\n}\n\nimpl TestCase {\n    fn text_only() -\u003e Self {\n        Self {\n            name: \"Simple text response\".to_string(),\n            request: LLMRequest {\n                messages: vec![Message {\n                    role: MessageRole::User,\n                    content: MessageContent::Text(\"Hello\".to_string()),\n                }],\n                system_prompt: \"You are a helpful assistant.\".to_string(),\n                tools: None,\n            },\n            expected_chunks: vec![\"Hi!\".to_string(), \" How can I help you today?\".to_string()],\n            expected_response: LLMResponse {\n                content: vec![ContentBlock::Text {\n                    text: \"Hi! How can I help you today?\".to_string(),\n                }],\n                usage: Usage {\n                    input_tokens: 10,\n                    output_tokens: 8,\n                },\n            },\n        }\n    }\n\n    fn with_tool() -\u003e Self {\n        Self {\n            name: \"Function calling response\".to_string(),\n            request: LLMRequest {\n                messages: vec![Message {\n                    role: MessageRole::User,\n                    content: MessageContent::Text(\"What's the weather?\".to_string()),\n                }],\n                system_prompt: \"Use the weather tool.\".to_string(),\n                tools: Some(vec![ToolDefinition {\n                    name: \"get_weather\".to_string(),\n                    description: \"Get current weather\".to_string(),\n                    parameters: json!({\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"location\": {\n                                \"type\": \"string\",\n                                \"description\": \"Location\"\n                            }\n                        },\n                        \"required\": [\"location\"]\n                    }),\n                }]),\n            },\n            expected_chunks: vec![],\n            expected_response: LLMResponse {\n                content: vec![ContentBlock::ToolUse {\n                    id: \"tool-0\".to_string(),\n                    name: \"get_weather\".to_string(),\n                    input: json!({\"location\": \"current\"}),\n                }],\n                usage: Usage {\n                    input_tokens: 15,\n                    output_tokens: 12,\n                },\n            },\n        }\n    }\n}\n\n// Chunk collector for streaming tests\n#[derive(Clone)]\nstruct ChunkCollector {\n    chunks: Arc\u003cMutex\u003cVec\u003cString\u003e\u003e\u003e,\n}\n\nimpl ChunkCollector {\n    fn new() -\u003e Self {\n        Self {\n            chunks: Arc::new(Mutex::new(Vec::new())),\n        }\n    }\n\n    fn callback(\u0026self) -\u003e StreamingCallback {\n        let chunks = self.chunks.clone();\n        Box::new(move |chunk: \u0026str| {\n            chunks.lock().unwrap().push(chunk.to_string());\n            Ok(())\n        })\n    }\n\n    fn get_chunks(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.chunks.lock().unwrap().clone()\n    }\n}\n\n// Response generator trait for provider-specific implementations\ntrait MockResponseGenerator: Send + Sync {\n    // Generates complete response for non-streaming case\n    fn generate_response(\u0026self, case: \u0026TestCase) -\u003e String;\n    // Generates chunks for streaming case\n    fn generate_chunks(\u0026self, case: \u0026TestCase) -\u003e Vec\u003cVec\u003cu8\u003e\u003e;\n}\n\n// OpenAI implementation\n#[derive(Clone)]\nstruct OpenAIMockGenerator;\n\nimpl MockResponseGenerator for OpenAIMockGenerator {\n    fn generate_response(\u0026self, case: \u0026TestCase) -\u003e String {\n        match case.request.tools {\n            None =\u003e json!({\n                \"choices\": [{\n                    \"message\": {\n                        \"role\": \"assistant\",\n                        \"content\": \"Hi! How can I help you today?\"\n                    }\n                }],\n                \"usage\": {\n                    \"prompt_tokens\": 10,\n                    \"completion_tokens\": 8,\n                    \"total_tokens\": 18\n                }\n            }),\n            Some(_) =\u003e json!({\n                \"choices\": [{\n                    \"message\": {\n                        \"role\": \"assistant\",\n                        \"tool_calls\": [{\n                            \"id\": \"tool-0\",\n                            \"type\": \"function\",\n                            \"function\": {\n                                \"name\": \"get_weather\",\n                                \"arguments\": \"{\\\"location\\\":\\\"current\\\"}\"\n                            }\n                        }]\n                    }\n                }],\n                \"usage\": {\n                    \"prompt_tokens\": 15,\n                    \"completion_tokens\": 12,\n                    \"total_tokens\": 27\n                }\n            }),\n        }\n        .to_string()\n    }\n\n    fn generate_chunks(\u0026self, case: \u0026TestCase) -\u003e Vec\u003cVec\u003cu8\u003e\u003e {\n        match case.request.tools {\n            None =\u003e vec![\n                // Initial content\n                b\"data: {\\\"choices\\\":[{\\\"delta\\\":{\\\"content\\\":\\\"Hi!\\\"},\\\"finish_reason\\\":null}]}\\n\\n\".to_vec(),\n                // More content\n                b\"data: {\\\"choices\\\":[{\\\"delta\\\":{\\\"content\\\":\\\" How can I help you today?\\\"},\\\"finish_reason\\\":null}]}\\n\\n\".to_vec(),\n                // Final message with usage\n                b\"data: {\\\"choices\\\":[{\\\"delta\\\":{},\\\"finish_reason\\\":\\\"stop\\\"}],\\\"usage\\\":{\\\"prompt_tokens\\\":10,\\\"completion_tokens\\\":8,\\\"total_tokens\\\":18}}\\n\\n\".to_vec(),\n                b\"data: [DONE]\\n\\n\".to_vec(),\n            ],\n            Some(_) =\u003e vec![\n                // Initial delta with function declaration\n                format!(\n                    \"data: {{\\\"choices\\\":[{{\\\"index\\\":0,\\\"delta\\\":{{\\\"role\\\":\\\"assistant\\\",\\\"content\\\":null,\\\"tool_calls\\\":[{{\\\"index\\\":0,\\\"id\\\":\\\"tool-0\\\",\\\"type\\\":\\\"function\\\",\\\"function\\\":{{\\\"name\\\":\\\"get_weather\\\",\\\"arguments\\\":\\\"\\\"}}}}]}}}}]}}\\n\\n\"\n                ).into_bytes(),\n                // Arguments streaming in chunks\n                format!(\n                    \"data: {{\\\"choices\\\":[{{\\\"index\\\":0,\\\"delta\\\":{{\\\"tool_calls\\\":[{{\\\"index\\\":0,\\\"function\\\":{{\\\"arguments\\\":\\\"{{\\\\\\\"\\\"}}}}]}}}}]}}\\n\\n\"\n                ).into_bytes(),\n                format!(\n                    \"data: {{\\\"choices\\\":[{{\\\"index\\\":0,\\\"delta\\\":{{\\\"tool_calls\\\":[{{\\\"index\\\":0,\\\"function\\\":{{\\\"arguments\\\":\\\"location\\\\\\\"\\\"}}}}]}}}}]}}\\n\\n\"\n                ).into_bytes(),\n                format!(\n                    \"data: {{\\\"choices\\\":[{{\\\"index\\\":0,\\\"delta\\\":{{\\\"tool_calls\\\":[{{\\\"index\\\":0,\\\"function\\\":{{\\\"arguments\\\":\\\":\\\\\\\"\\\"}}}}]}}}}]}}\\n\\n\"\n                ).into_bytes(),\n                format!(\n                    \"data: {{\\\"choices\\\":[{{\\\"index\\\":0,\\\"delta\\\":{{\\\"tool_calls\\\":[{{\\\"index\\\":0,\\\"function\\\":{{\\\"arguments\\\":\\\"current\\\"}}}}]}}}}]}}\\n\\n\"\n                ).into_bytes(),\n                format!(\n                    \"data: {{\\\"choices\\\":[{{\\\"index\\\":0,\\\"delta\\\":{{\\\"tool_calls\\\":[{{\\\"index\\\":0,\\\"function\\\":{{\\\"arguments\\\":\\\"\\\\\\\"}}\\\"}}}}]}}}}]}}\\n\\n\"\n                ).into_bytes(),\n                // Empty delta with finish reason\n                format!(\n                    \"data: {{\\\"choices\\\":[{{\\\"index\\\":0,\\\"delta\\\":{{}},\\\"finish_reason\\\":\\\"tool_calls\\\"}}]}}\\n\\n\"\n                ).into_bytes(),\n                b\"data: [DONE]\\n\\n\".to_vec(),\n            ],\n        }\n    }\n}\n\n// Anthropic implementation\n#[derive(Clone)]\nstruct AnthropicMockGenerator;\n\nimpl MockResponseGenerator for AnthropicMockGenerator {\n    fn generate_response(\u0026self, case: \u0026TestCase) -\u003e String {\n        match case.request.tools {\n            None =\u003e json!({\n                \"content\": [{\n                    \"type\": \"text\",\n                    \"text\": \"Hi! How can I help you today?\"\n                }],\n                \"usage\": {\n                    \"input_tokens\": 10,\n                    \"output_tokens\": 8\n                }\n            }),\n            Some(_) =\u003e json!({\n                \"content\": [{\n                    \"type\": \"tool_use\",\n                    \"id\": \"tool-0\",\n                    \"name\": \"get_weather\",\n                    \"input\": {\"location\": \"current\"}\n                }],\n                \"usage\": {\n                    \"input_tokens\": 15,\n                    \"output_tokens\": 12\n                }\n            }),\n        }\n        .to_string()\n    }\n\n    fn generate_chunks(\u0026self, case: \u0026TestCase) -\u003e Vec\u003cVec\u003cu8\u003e\u003e {\n        match case.request.tools {\n            None =\u003e vec![\n                b\"event: message_start\\ndata: {\\\"type\\\":\\\"message_start\\\",\\\"message\\\":{\\\"id\\\":\\\"msg_1\\\",\\\"type\\\":\\\"message\\\",\\\"role\\\":\\\"assistant\\\",\\\"model\\\":\\\"claude-3\\\",\\\"content\\\":[],\\\"stop_reason\\\":null,\\\"stop_sequence\\\":null,\\\"usage\\\":{\\\"input_tokens\\\":10,\\\"output_tokens\\\":8}}}\\n\\n\".to_vec(),\n                b\"event: content_block_start\\ndata: {\\\"type\\\":\\\"content_block_start\\\",\\\"index\\\":0,\\\"content_block\\\":{\\\"type\\\":\\\"text\\\",\\\"text\\\":\\\"\\\"}}\\n\\n\".to_vec(),\n                b\"event: content_block_delta\\ndata: {\\\"type\\\":\\\"content_block_delta\\\",\\\"index\\\":0,\\\"delta\\\":{\\\"type\\\":\\\"text_delta\\\",\\\"text\\\":\\\"Hi!\\\"}}\\n\\n\".to_vec(),\n                b\"event: content_block_delta\\ndata: {\\\"type\\\":\\\"content_block_delta\\\",\\\"index\\\":0,\\\"delta\\\":{\\\"type\\\":\\\"text_delta\\\",\\\"text\\\":\\\" How can I help you today?\\\"}}\\n\\n\".to_vec(),\n                b\"event: content_block_stop\\ndata: {\\\"type\\\":\\\"content_block_stop\\\",\\\"index\\\":0}\\n\\n\".to_vec(),\n                b\"event: message_delta\\ndata: {\\\"type\\\":\\\"message_delta\\\",\\\"delta\\\":{\\\"stop_reason\\\":\\\"end_turn\\\",\\\"stop_sequence\\\":null},\\\"usage\\\":{\\\"output_tokens\\\":8}}\\n\\n\".to_vec(),\n                b\"event: message_stop\\ndata: {\\\"type\\\":\\\"message_stop\\\"}\\n\\n\".to_vec(),\n            ],\n            Some(_) =\u003e vec![\n                b\"event: message_start\\ndata: {\\\"type\\\":\\\"message_start\\\",\\\"message\\\":{\\\"id\\\":\\\"msg_1\\\",\\\"type\\\":\\\"message\\\",\\\"role\\\":\\\"assistant\\\",\\\"model\\\":\\\"claude-3\\\",\\\"content\\\":[],\\\"stop_reason\\\":null,\\\"stop_sequence\\\":null,\\\"usage\\\":{\\\"input_tokens\\\":15,\\\"output_tokens\\\":2}}}\\n\\n\".to_vec(),\n                b\"event: content_block_start\\ndata: {\\\"type\\\":\\\"content_block_start\\\",\\\"index\\\":0,\\\"content_block\\\":{\\\"type\\\":\\\"tool_use\\\",\\\"id\\\":\\\"tool-0\\\",\\\"name\\\":\\\"get_weather\\\"}}\\n\\n\".to_vec(),\n                b\"event: content_block_delta\\ndata: {\\\"type\\\":\\\"content_block_delta\\\",\\\"index\\\":0,\\\"delta\\\":{\\\"type\\\":\\\"input_json_delta\\\",\\\"partial_json\\\":\\\"{\\\\\\\"location\\\\\\\":\\\"}}\\n\\n\".to_vec(),\n                b\"event: content_block_delta\\ndata: {\\\"type\\\":\\\"content_block_delta\\\",\\\"index\\\":0,\\\"delta\\\":{\\\"type\\\":\\\"input_json_delta\\\",\\\"partial_json\\\":\\\"\\\\\\\"current\\\\\\\"}\\\"}}\\n\\n\".to_vec(),\n                b\"event: content_block_stop\\ndata: {\\\"type\\\":\\\"content_block_stop\\\",\\\"index\\\":0}\\n\\n\".to_vec(),\n                b\"event: message_delta\\ndata: {\\\"type\\\":\\\"message_delta\\\",\\\"delta\\\":{\\\"stop_reason\\\":\\\"tool_use\\\",\\\"stop_sequence\\\":null},\\\"usage\\\":{\\\"output_tokens\\\":12}}\\n\\n\".to_vec(),\n                b\"event: message_stop\\ndata: {\\\"type\\\":\\\"message_stop\\\"}\\n\\n\".to_vec(),\n            ],\n        }\n    }\n}\n\n// Vertex implementation\n#[derive(Clone)]\nstruct VertexMockGenerator;\n\nimpl MockResponseGenerator for VertexMockGenerator {\n    fn generate_response(\u0026self, case: \u0026TestCase) -\u003e String {\n        match case.request.tools {\n            None =\u003e json!({\n                \"candidates\": [{\n                    \"content\": {\n                        \"parts\": [{\n                            \"text\": \"Hi! How can I help you today?\"\n                        }],\n                        \"role\": \"model\"\n                    }\n                }],\n                \"usageMetadata\": {\n                    \"promptTokenCount\": 10,\n                    \"candidatesTokenCount\": 8,\n                    \"totalTokenCount\": 18\n                }\n            }),\n            Some(_) =\u003e json!({\n                \"candidates\": [{\n                    \"content\": {\n                        \"parts\": [{\n                            \"functionCall\": {\n                                \"name\": \"get_weather\",\n                                \"args\": {\"location\": \"current\"}\n                            }\n                        }],\n                        \"role\": \"model\"\n                    }\n                }],\n                \"usageMetadata\": {\n                    \"promptTokenCount\": 15,\n                    \"candidatesTokenCount\": 12,\n                    \"totalTokenCount\": 27\n                }\n            }),\n        }\n        .to_string()\n    }\n\n    fn generate_chunks(\u0026self, case: \u0026TestCase) -\u003e Vec\u003cVec\u003cu8\u003e\u003e {\n        match case.request.tools {\n            None =\u003e vec![\n                format!(\n                    \"data: {}\\n\\n\",\n                    json!({\n                        \"candidates\": [{\n                            \"content\": {\n                                \"parts\": [{\"text\": \"Hi!\"}],\n                                \"role\": \"model\"\n                            }\n                        }]\n                    })\n                )\n                .into_bytes(),\n                format!(\n                    \"data: {}\\n\\n\",\n                    json!({\n                        \"candidates\": [{\n                            \"content\": {\n                                \"parts\": [{\"text\": \" How can I help you today?\"}],\n                                \"role\": \"model\"\n                            }\n                        }],\n                        \"usageMetadata\": {\n                            \"promptTokenCount\": 10,\n                            \"candidatesTokenCount\": 8,\n                            \"totalTokenCount\": 18\n                        }\n                    })\n                )\n                .into_bytes(),\n            ],\n            Some(_) =\u003e vec![format!(\n                \"data: {}\\n\\n\",\n                json!({\n                    \"candidates\": [{\n                        \"content\": {\n                            \"parts\": [{\n                                \"functionCall\": {\n                                    \"name\": \"get_weather\",\n                                    \"args\": {\"location\": \"current\"}\n                                }\n                            }],\n                            \"role\": \"model\"\n                        }\n                    }],\n                    \"usageMetadata\": {\n                        \"promptTokenCount\": 15,\n                        \"candidatesTokenCount\": 12,\n                        \"totalTokenCount\": 27\n                    }\n                })\n            )\n            .into_bytes()],\n        }\n    }\n}\n\n// Ollama implementation\n#[derive(Clone)]\nstruct OllamaMockGenerator;\n\nimpl MockResponseGenerator for OllamaMockGenerator {\n    fn generate_response(\u0026self, case: \u0026TestCase) -\u003e String {\n        match case.request.tools {\n            None =\u003e json!({\n                \"message\": {\n                    \"content\": \"Hi! How can I help you today?\"\n                },\n                \"done\": true,\n                \"prompt_eval_count\": 10,\n                \"eval_count\": 8\n            }),\n            Some(_) =\u003e json!({\n                \"message\": {\n                    \"content\": \"\",\n                    \"tool_calls\": [{\n                        \"function\": {\n                            \"name\": \"get_weather\",\n                            \"arguments\": { \"location\": \"current\" }\n                        }\n                    }]\n                },\n                \"done\": true,\n                \"prompt_eval_count\": 15,\n                \"eval_count\": 12\n            }),\n        }\n        .to_string()\n    }\n\n    fn generate_chunks(\u0026self, case: \u0026TestCase) -\u003e Vec\u003cVec\u003cu8\u003e\u003e {\n        match case.request.tools {\n            None =\u003e vec![\n                format!(\n                    \"{}\\n\",\n                    json!({\n                        \"message\": {\n                            \"content\": \"Hi!\"\n                        },\n                        \"done\": false,\n                        \"prompt_eval_count\": 10,\n                        \"eval_count\": 4\n                    })\n                )\n                .into_bytes(),\n                format!(\n                    \"{}\\n\",\n                    json!({\n                        \"message\": {\n                            \"content\": \" How can I help you today?\"\n                        },\n                        \"done\": true,\n                        \"prompt_eval_count\": 10,\n                        \"eval_count\": 8\n                    })\n                )\n                .into_bytes(),\n            ],\n            Some(_) =\u003e vec![format!(\n                \"{}\\n\",\n                json!({\n                    \"message\": {\n                        \"content\": \"\",\n                        \"tool_calls\": [{\n                            \"function\": {\n                                \"name\": \"get_weather\",\n                                \"arguments\": { \"location\": \"current\" }\n                            }\n                        }]\n                    },\n                    \"done\": true,\n                    \"prompt_eval_count\": 15,\n                    \"eval_count\": 12\n                })\n            )\n            .into_bytes()],\n        }\n    }\n}\n\n// Helper to create a mock server\nasync fn create_mock_server(\n    test_case: TestCase,\n    generator: impl MockResponseGenerator + Clone + 'static,\n) -\u003e String {\n    let app = Router::new().route(\n        \"/*path\",\n        post(\n            move |Path(path): Path\u003cString\u003e, req: axum::extract::Json\u003cserde_json::Value\u003e| {\n                let generator = generator.clone();\n                let test_case = test_case.clone();\n                async move {\n                    let is_streaming = path.contains(\"stream\")\n                        || req.get(\"stream\").and_then(|v| v.as_bool()).unwrap_or(false);\n\n                    if is_streaming {\n                        let chunks = generator.generate_chunks(\u0026test_case);\n                        let stream = stream::iter(\n                            chunks\n                                .into_iter()\n                                .map(|chunk| Ok::\u003c_, std::io::Error\u003e(Bytes::from(chunk))),\n                        );\n\n                        axum::response::Response::builder()\n                            .status(axum::http::StatusCode::OK)\n                            .header(\"content-type\", \"text/event-stream\")\n                            .body(axum::body::Body::from_stream(stream))\n                            .unwrap()\n                    } else {\n                        (\n                            axum::http::StatusCode::OK,\n                            axum::Json(\n                                serde_json::from_str::\u003cserde_json::Value\u003e(\n                                    \u0026generator.generate_response(\u0026test_case),\n                                )\n                                .unwrap(),\n                            ),\n                        )\n                            .into_response()\n                    }\n                }\n            },\n        ),\n    );\n\n    let addr = SocketAddr::from(([127, 0, 0, 1], 0));\n    let listener = TcpListener::bind(addr).await.unwrap();\n    let server_addr = listener.local_addr().unwrap();\n\n    tokio::spawn(async move {\n        axum::serve(listener, app).await.unwrap();\n    });\n\n    format!(\"http://{}\", server_addr)\n}\n\n// Run all test cases for a given provider configuration\nasync fn run_provider_tests\u003cT: MockResponseGenerator + Clone + 'static\u003e(\n    provider_name: \u0026str,\n    create_client: impl Fn(\u0026str) -\u003e Box\u003cdyn LLMProvider\u003e,\n    generator: T,\n) -\u003e Result\u003c()\u003e {\n    let test_cases = vec![TestCase::text_only(), TestCase::with_tool()];\n\n    for case in test_cases {\n        println!(\"Running {} test case: {}\", provider_name, case.name);\n\n        let base_url = create_mock_server(case.clone(), generator.clone()).await;\n        let client = create_client(\u0026base_url);\n\n        // Test non-streaming\n        let response = client.send_message(case.request.clone(), None).await?;\n\n        assert_eq!(\n            response.content, case.expected_response.content,\n            \"Non-streaming content mismatch\"\n        );\n        assert_eq!(\n            response.usage, case.expected_response.usage,\n            \"Non-streaming usage mismatch\"\n        );\n\n        // Test streaming\n        let collector = ChunkCollector::new();\n        let callback = collector.callback();\n\n        let response = client\n            .send_message(case.request.clone(), Some(\u0026callback))\n            .await?;\n\n        assert_eq!(\n            response.content, case.expected_response.content,\n            \"Streaming content mismatch\"\n        );\n        assert_eq!(\n            collector.get_chunks(),\n            case.expected_chunks,\n            \"Streaming chunks mismatch\"\n        );\n    }\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_openai_provider() -\u003e Result\u003c()\u003e {\n    run_provider_tests(\n        \"OpenAI\",\n        |url| {\n            Box::new(OpenAIClient::new_with_base_url(\n                \"test-key\".to_string(),\n                \"gpt-4\".to_string(),\n                url.to_string(),\n            ))\n        },\n        OpenAIMockGenerator,\n    )\n    .await\n}\n\n#[tokio::test]\nasync fn test_anthropic_provider() -\u003e Result\u003c()\u003e {\n    run_provider_tests(\n        \"Anthropic\",\n        |url| {\n            Box::new(AnthropicClient::new_with_base_url(\n                \"test-key\".to_string(),\n                \"claude-3\".to_string(),\n                url.to_string(),\n            ))\n        },\n        AnthropicMockGenerator,\n    )\n    .await\n}\n\n#[tokio::test]\nasync fn test_vertex_provider() -\u003e Result\u003c()\u003e {\n    run_provider_tests(\n        \"Vertex\",\n        |url| {\n            Box::new(VertexClient::new_with_base_url(\n                \"test-key\".to_string(),\n                \"gemini-pro\".to_string(),\n                url.to_string(),\n            ))\n        },\n        VertexMockGenerator,\n    )\n    .await\n}\n\n#[tokio::test]\nasync fn test_ollama_provider() -\u003e Result\u003c()\u003e {\n    run_provider_tests(\n        \"Ollama\",\n        |url| {\n            Box::new(OllamaClient::new_with_base_url(\n                \"llama2\".to_string(),\n                4096,\n                url.to_string(),\n            ))\n        },\n        OllamaMockGenerator,\n    )\n    .await\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","stippi","projects","code-assistant","src","llm","types.rs"],"content":"use crate::types::ToolDefinition;\nuse reqwest::Response;\nuse serde::{Deserialize, Serialize};\nuse std::time::Duration;\n\n/// Tracks token usage for a request/response pair\n#[derive(Debug, Deserialize, PartialEq, Clone)]\npub struct Usage {\n    /// Number of tokens in the input (prompt)\n    pub input_tokens: u32,\n    /// Number of tokens in the output (completion)\n    pub output_tokens: u32,\n}\n\n/// Generic request structure that can be mapped to different providers\n#[derive(Debug, Clone)]\npub struct LLMRequest {\n    pub messages: Vec\u003cMessage\u003e,\n    pub system_prompt: String,\n    pub tools: Option\u003cVec\u003cToolDefinition\u003e\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Message {\n    pub role: MessageRole,\n    pub content: MessageContent,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\n#[serde(rename_all = \"lowercase\")]\npub enum MessageRole {\n    User,\n    Assistant,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\n#[serde(untagged)]\npub enum MessageContent {\n    Text(String),\n    Structured(Vec\u003cContentBlock\u003e),\n}\n\n#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]\n#[serde(tag = \"type\")]\npub enum ContentBlock {\n    #[serde(rename = \"text\")]\n    Text { text: String },\n    #[serde(rename = \"tool_use\")]\n    ToolUse {\n        id: String,\n        name: String,\n        input: serde_json::Value,\n    },\n    #[serde(rename = \"tool_result\")]\n    ToolResult {\n        tool_use_id: String,\n        content: String,\n    },\n}\n\n/// Generic response structure\n#[derive(Debug, Deserialize, Clone)]\npub struct LLMResponse {\n    pub content: Vec\u003cContentBlock\u003e,\n    pub usage: Usage,\n}\n\n/// Common error types for all LLM providers\n#[derive(Debug, thiserror::Error)]\npub enum ApiError {\n    #[error(\"Rate limit exceeded: {0}\")]\n    RateLimit(String),\n\n    #[error(\"Authentication failed: {0}\")]\n    Authentication(String),\n\n    #[error(\"Invalid request: {0}\")]\n    InvalidRequest(String),\n\n    #[error(\"Service error: {0}\")]\n    ServiceError(String),\n\n    #[error(\"Network error: {0}\")]\n    NetworkError(String),\n\n    #[error(\"Unknown error: {0}\")]\n    Unknown(String),\n}\n\n/// Context wrapper for API errors that includes rate limit information\n#[derive(Debug, thiserror::Error)]\n#[error(\"{error}\")]\npub struct ApiErrorContext\u003cT\u003e {\n    pub error: ApiError,\n    pub rate_limits: Option\u003cT\u003e,\n}\n\n/// Base trait for rate limit information\npub trait RateLimitHandler: Sized {\n    /// Create a new instance from response headers\n    fn from_response(response: \u0026Response) -\u003e Self;\n\n    /// Get the delay duration before the next retry\n    fn get_retry_delay(\u0026self) -\u003e Duration;\n\n    /// Log the current rate limit status\n    fn log_status(\u0026self);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","stippi","projects","code-assistant","src","llm","vertex.rs"],"content":"use crate::llm::{\n    types::*, ApiError, ApiErrorContext, LLMProvider, RateLimitHandler, StreamingCallback,\n};\nuse anyhow::Result;\nuse async_trait::async_trait;\nuse reqwest::{Client, Response, StatusCode};\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse std::time::Duration;\nuse tokio::time::sleep;\nuse tracing::{debug, trace, warn};\n\n#[derive(Debug, Serialize)]\nstruct VertexRequest {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    system_instruction: Option\u003cSystemInstruction\u003e,\n    contents: Vec\u003cVertexMessage\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    generation_config: Option\u003cGenerationConfig\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    tools: Option\u003cVec\u003cserde_json::Value\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    tool_config: Option\u003cserde_json::Value\u003e,\n}\n\n#[derive(Debug, Serialize)]\nstruct SystemInstruction {\n    parts: Parts,\n}\n\n#[derive(Debug, Serialize)]\nstruct Parts {\n    text: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct VertexMessage {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    role: Option\u003cString\u003e,\n    parts: Vec\u003cVertexPart\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct VertexPart {\n    #[serde(rename = \"functionCall\")]\n    function_call: Option\u003cVertexFunctionCall\u003e,\n    // Optional text field could be added if we get text responses\n    text: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize)]\nstruct GenerationConfig {\n    temperature: f32,\n    max_output_tokens: usize,\n}\n\n#[derive(Debug, Deserialize)]\nstruct VertexResponse {\n    candidates: Vec\u003cVertexCandidate\u003e,\n    #[serde(rename = \"usageMetadata\")]\n    usage_metadata: Option\u003cVertexUsageMetadata\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct VertexUsageMetadata {\n    #[serde(rename = \"promptTokenCount\")]\n    prompt_token_count: u32,\n    #[serde(rename = \"candidatesTokenCount\")]\n    candidates_token_count: u32,\n    #[allow(dead_code)]\n    #[serde(rename = \"totalTokenCount\")]\n    total_token_count: u32,\n}\n\n#[derive(Debug, Deserialize)]\nstruct VertexCandidate {\n    content: VertexContent,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct VertexContent {\n    parts: Vec\u003cVertexPart\u003e,\n    role: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct VertexFunctionCall {\n    name: String,\n    args: serde_json::Value,\n}\n\n#[derive(Debug, Deserialize)]\nstruct VertexErrorResponse {\n    error: VertexError,\n}\n\n#[derive(Debug, Deserialize)]\nstruct VertexError {\n    message: String,\n    code: Option\u003ci32\u003e,\n}\n\n/// Rate limit information extracted from response headers\n#[derive(Debug)]\nstruct VertexRateLimitInfo {\n    // TODO: Add actual rate limit fields once we know what headers Vertex AI uses\n    requests_remaining: Option\u003cu32\u003e,\n    #[allow(dead_code)]\n    requests_reset: Option\u003cDuration\u003e,\n}\n\nimpl RateLimitHandler for VertexRateLimitInfo {\n    fn from_response(_response: \u0026Response) -\u003e Self {\n        // TODO: Parse actual rate limit headers once we know what Vertex AI provides\n        Self {\n            requests_remaining: None,\n            requests_reset: None,\n        }\n    }\n\n    fn get_retry_delay(\u0026self) -\u003e Duration {\n        // Default exponential backoff strategy\n        Duration::from_secs(2)\n    }\n\n    fn log_status(\u0026self) {\n        debug!(\n            \"Vertex AI Rate limits - Requests remaining: {}\",\n            self.requests_remaining\n                .map_or(\"unknown\".to_string(), |r| r.to_string())\n        );\n    }\n}\n\npub struct VertexClient {\n    client: Client,\n    api_key: String,\n    model: String,\n    base_url: String,\n}\n\nimpl VertexClient {\n    pub fn new(api_key: String, model: String) -\u003e Self {\n        Self {\n            client: Client::new(),\n            api_key,\n            model,\n            base_url: \"https://generativelanguage.googleapis.com/v1beta\".to_string(),\n        }\n    }\n\n    #[cfg(test)]\n    pub fn new_with_base_url(api_key: String, model: String, base_url: String) -\u003e Self {\n        Self {\n            client: Client::new(),\n            api_key,\n            model,\n            base_url,\n        }\n    }\n\n    fn get_url(\u0026self, streaming: bool) -\u003e String {\n        if streaming {\n            format!(\n                \"{}/models/{}:streamGenerateContent\",\n                self.base_url, self.model\n            )\n        } else {\n            format!(\"{}/models/{}:generateContent\", self.base_url, self.model)\n        }\n    }\n\n    fn convert_message(message: \u0026Message) -\u003e VertexMessage {\n        let text = match \u0026message.content {\n            MessageContent::Text(text) =\u003e text.clone(),\n            MessageContent::Structured(_) =\u003e \"[Structured content not supported]\".to_string(),\n        };\n\n        VertexMessage {\n            role: Some(match message.role {\n                MessageRole::User =\u003e \"user\".to_string(),\n                MessageRole::Assistant =\u003e \"model\".to_string(),\n            }),\n            parts: vec![VertexPart {\n                text: Some(text),\n                function_call: None,\n            }],\n        }\n    }\n\n    async fn send_with_retry(\n        \u0026self,\n        request: \u0026VertexRequest,\n        streaming_callback: Option\u003c\u0026StreamingCallback\u003e,\n        max_retries: u32,\n    ) -\u003e Result\u003cLLMResponse\u003e {\n        let mut attempts = 0;\n\n        loop {\n            match if let Some(callback) = streaming_callback {\n                self.try_send_request_streaming(request, callback).await\n            } else {\n                self.try_send_request(request).await\n            } {\n                Ok((response, rate_limits)) =\u003e {\n                    rate_limits.log_status();\n                    return Ok(response);\n                }\n                Err(e) =\u003e {\n                    let rate_limits = e\n                        .downcast_ref::\u003cApiErrorContext\u003cVertexRateLimitInfo\u003e\u003e()\n                        .and_then(|ctx| ctx.rate_limits.as_ref());\n\n                    match e.downcast_ref::\u003cApiError\u003e() {\n                        Some(ApiError::RateLimit(_)) =\u003e {\n                            if attempts \u003c max_retries {\n                                attempts += 1;\n                                let delay = rate_limits\n                                    .map(|r| r.get_retry_delay())\n                                    .unwrap_or_else(|| Duration::from_secs(2u64.pow(attempts)));\n                                warn!(\n                                    \"Vertex AI rate limit hit (attempt {}/{}), waiting {} seconds before retry\",\n                                    attempts,\n                                    max_retries,\n                                    delay.as_secs()\n                                );\n                                sleep(delay).await;\n                                continue;\n                            }\n                        }\n                        Some(ApiError::ServiceError(_)) | Some(ApiError::NetworkError(_)) =\u003e {\n                            if attempts \u003c max_retries {\n                                attempts += 1;\n                                let delay = Duration::from_secs(2u64.pow(attempts - 1));\n                                warn!(\n                                    \"Error: {} (attempt {}/{}), retrying in {} seconds\",\n                                    e,\n                                    attempts,\n                                    max_retries,\n                                    delay.as_secs()\n                                );\n                                sleep(delay).await;\n                                continue;\n                            }\n                        }\n                        _ =\u003e {} // Don't retry other types of errors\n                    }\n                    return Err(e);\n                }\n            }\n        }\n    }\n\n    async fn handle_error_response(\n        \u0026self,\n        response: Response,\n    ) -\u003e Result\u003c(LLMResponse, VertexRateLimitInfo)\u003e {\n        let rate_limits = VertexRateLimitInfo::from_response(\u0026response);\n        let status = response.status();\n        let response_text = response\n            .text()\n            .await\n            .map_err(|e| ApiError::NetworkError(e.to_string()))?;\n\n        let error = if let Ok(error_response) =\n            serde_json::from_str::\u003cVertexErrorResponse\u003e(\u0026response_text)\n        {\n            match (status, error_response.error.code) {\n                (StatusCode::TOO_MANY_REQUESTS, _) =\u003e {\n                    ApiError::RateLimit(error_response.error.message)\n                }\n                (StatusCode::UNAUTHORIZED, _) =\u003e {\n                    ApiError::Authentication(error_response.error.message)\n                }\n                (StatusCode::BAD_REQUEST, _) =\u003e {\n                    ApiError::InvalidRequest(error_response.error.message)\n                }\n                (status, _) if status.is_server_error() =\u003e {\n                    ApiError::ServiceError(error_response.error.message)\n                }\n                _ =\u003e ApiError::Unknown(error_response.error.message),\n            }\n        } else {\n            ApiError::Unknown(format!(\"Status {}: {}\", status, response_text))\n        };\n\n        Err(ApiErrorContext {\n            error,\n            rate_limits: Some(rate_limits),\n        }\n        .into())\n    }\n\n    async fn try_send_request(\n        \u0026self,\n        request: \u0026VertexRequest,\n    ) -\u003e Result\u003c(LLMResponse, VertexRateLimitInfo)\u003e {\n        let url = self.get_url(false);\n\n        trace!(\n            \"Sending Vertex request to {}:\\n{}\",\n            self.model,\n            serde_json::to_string_pretty(request)?\n        );\n\n        let response = self\n            .client\n            .post(\u0026url)\n            .query(\u0026[(\"key\", \u0026self.api_key)])\n            .header(\"Content-Type\", \"application/json\")\n            .json(request)\n            .send()\n            .await\n            .map_err(|e| ApiError::NetworkError(e.to_string()))?;\n\n        if !response.status().is_success() {\n            return self.handle_error_response(response).await;\n        }\n\n        let rate_limits = VertexRateLimitInfo::from_response(\u0026response);\n\n        trace!(\"Response headers: {:?}\", response.headers());\n\n        let response_text = response\n            .text()\n            .await\n            .map_err(|e| ApiError::NetworkError(e.to_string()))?;\n\n        trace!(\n            \"Vertex response: {}\",\n            serde_json::to_string_pretty(\u0026serde_json::from_str::\u003cserde_json::Value\u003e(\n                \u0026response_text\n            )?)?\n        );\n\n        let vertex_response: VertexResponse = serde_json::from_str(\u0026response_text)\n            .map_err(|e| ApiError::Unknown(format!(\"Failed to parse response: {}\", e)))?;\n\n        // Convert to our generic LLMResponse format\n        let response = LLMResponse {\n            content: vertex_response\n                .candidates\n                .into_iter()\n                .flat_map(|candidate| {\n                    candidate\n                        .content\n                        .parts\n                        .into_iter()\n                        .enumerate()\n                        .map(|(index, part)| {\n                            if let Some(function_call) = part.function_call {\n                                ContentBlock::ToolUse {\n                                    id: format!(\"tool-{}\", index), // Generate a unique ID\n                                    name: function_call.name,\n                                    input: function_call.args,\n                                }\n                            } else if let Some(text) = part.text {\n                                ContentBlock::Text { text }\n                            } else {\n                                // Fallback if neither function_call nor text is present\n                                ContentBlock::Text {\n                                    text: \"Empty response part\".to_string(),\n                                }\n                            }\n                        })\n                        .collect::\u003cVec\u003c_\u003e\u003e()\n                })\n                .collect(),\n            usage: Usage {\n                input_tokens: vertex_response\n                    .usage_metadata\n                    .as_ref()\n                    .map(|u| u.prompt_token_count)\n                    .unwrap_or(0),\n                output_tokens: vertex_response\n                    .usage_metadata\n                    .as_ref()\n                    .map(|u| u.candidates_token_count)\n                    .unwrap_or(0),\n            },\n        };\n\n        Ok((response, rate_limits))\n    }\n\n    async fn try_send_request_streaming(\n        \u0026self,\n        request: \u0026VertexRequest,\n        streaming_callback: \u0026StreamingCallback,\n    ) -\u003e Result\u003c(LLMResponse, VertexRateLimitInfo)\u003e {\n        let mut response = self\n            .client\n            .post(\u0026self.get_url(true))\n            .query(\u0026[(\"key\", \u0026self.api_key), (\"alt\", \u0026\"sse\".to_string())])\n            .header(\"Content-Type\", \"application/json\")\n            .json(request)\n            .send()\n            .await\n            .map_err(|e| ApiError::NetworkError(e.to_string()))?;\n\n        if !response.status().is_success() {\n            return self.handle_error_response(response).await;\n        }\n\n        let rate_limits = VertexRateLimitInfo::from_response(\u0026response);\n\n        let mut content_blocks = Vec::new();\n        let mut current_text = String::new();\n        let mut last_usage: Option\u003cVertexUsageMetadata\u003e = None;\n        let mut line_buffer = String::new();\n\n        while let Some(chunk) = response.chunk().await? {\n            let chunk_str = std::str::from_utf8(\u0026chunk)?;\n\n            for c in chunk_str.chars() {\n                if c == '\\n' {\n                    if !line_buffer.is_empty() {\n                        if let Some(data) = line_buffer.strip_prefix(\"data: \") {\n                            if let Ok(response) = serde_json::from_str::\u003cVertexResponse\u003e(data) {\n                                if let Some(candidate) = response.candidates.first() {\n                                    for part in \u0026candidate.content.parts {\n                                        if let Some(text) = \u0026part.text {\n                                            streaming_callback(text)?;\n                                            current_text.push_str(text);\n                                        } else if let Some(function_call) = \u0026part.function_call {\n                                            // If we have accumulated text, push it as a content block\n                                            if !current_text.is_empty() {\n                                                content_blocks.push(ContentBlock::Text {\n                                                    text: current_text.clone(),\n                                                });\n                                                current_text.clear();\n                                            }\n\n                                            content_blocks.push(ContentBlock::ToolUse {\n                                                id: format!(\"tool-{}\", content_blocks.len()),\n                                                name: function_call.name.clone(),\n                                                input: function_call.args.clone(),\n                                            });\n                                        }\n                                    }\n                                }\n                                if let Some(usage) = response.usage_metadata {\n                                    last_usage = Some(usage);\n                                }\n                            }\n                        }\n                        line_buffer.clear();\n                    }\n                } else {\n                    line_buffer.push(c);\n                }\n            }\n        }\n\n        // Process any remaining data in the buffer\n        if !line_buffer.is_empty() {\n            if let Some(data) = line_buffer.strip_prefix(\"data: \") {\n                if let Ok(response) = serde_json::from_str::\u003cVertexResponse\u003e(data) {\n                    if let Some(usage) = response.usage_metadata {\n                        last_usage = Some(usage);\n                    }\n                }\n            }\n        }\n\n        // Push any remaining text as a final content block\n        if !current_text.is_empty() {\n            content_blocks.push(ContentBlock::Text { text: current_text });\n        }\n\n        Ok((\n            LLMResponse {\n                content: content_blocks,\n                usage: Usage {\n                    input_tokens: last_usage\n                        .as_ref()\n                        .map(|u| u.prompt_token_count)\n                        .unwrap_or(0),\n                    output_tokens: last_usage\n                        .as_ref()\n                        .map(|u| u.candidates_token_count)\n                        .unwrap_or(0),\n                },\n            },\n            rate_limits,\n        ))\n    }\n}\n\n#[async_trait]\nimpl LLMProvider for VertexClient {\n    async fn send_message(\n        \u0026self,\n        request: LLMRequest,\n        streaming_callback: Option\u003c\u0026StreamingCallback\u003e,\n    ) -\u003e Result\u003cLLMResponse\u003e {\n        let mut contents = Vec::new();\n\n        // Convert messages\n        contents.extend(request.messages.iter().map(Self::convert_message));\n\n        let vertex_request = VertexRequest {\n            system_instruction: Some(SystemInstruction {\n                parts: Parts {\n                    text: request.system_prompt,\n                },\n            }),\n            contents,\n            generation_config: Some(GenerationConfig {\n                temperature: 0.7,\n                max_output_tokens: 8192,\n            }),\n            tools: request.tools.map(|tools| {\n                vec![json!({\n                    \"function_declarations\": tools.into_iter().map(|tool| {\n                        json!({\n                            \"name\": tool.name,\n                            \"description\": tool.description,\n                            \"parameters\": tool.parameters,\n                        })\n                    }).collect::\u003cVec\u003c_\u003e\u003e()\n                })]\n            }),\n            tool_config: Some(json!({\n                \"function_calling_config\": {\n                    \"mode\": \"ANY\",\n                }\n            })),\n        };\n\n        self.send_with_retry(\u0026vertex_request, streaming_callback, 3)\n            .await\n    }\n}\n\n/*\nCommunicating tool call results back to LLM (including parallel function calls):\nNote, there is no ID associated with each function call/result, only the order.\n\n```json\n{\n    \"role\": \"user\",\n    \"parts\": {\n        \"text\": \"What is difference in temperature in New Delhi and San Francisco?\"\n    }\n},\n{\n    \"role\": \"model\",\n    \"parts\": [\n        {\n            \"functionCall\": {\n                \"name\": \"get_current_weather\",\n                \"args\": {\n                    \"location\": \"New Delhi\"\n                }\n            }\n        },\n        {\n            \"functionCall\": {\n                \"name\": \"get_current_weather\",\n                \"args\": {\n                    \"location\": \"San Francisco\"\n                }\n            }\n        }\n    ]\n},\n{\n    \"role\": \"user\",\n    \"parts\": [\n        {\n            \"functionResponse\": {\n                \"name\": \"get_current_weather\",\n                \"response\": {\n                    \"temperature\": 30.5,\n                    \"unit\": \"C\"\n                }\n            }\n        },\n        {\n            \"functionResponse\": {\n                \"name\": \"get_current_weather\",\n                \"response\": {\n                    \"temperature\": 20,\n                    \"unit\": \"C\"\n                }\n            }\n        }\n    ]\n}\n```\n*/\n","traces":[{"line":113,"address":[],"length":0,"stats":{"Line":4}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":127,"address":[],"length":0,"stats":{"Line":4}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":4}},{"line":163,"address":[],"length":0,"stats":{"Line":4}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":2}},{"line":173,"address":[],"length":0,"stats":{"Line":4}},{"line":174,"address":[],"length":0,"stats":{"Line":8}},{"line":175,"address":[],"length":0,"stats":{"Line":4}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":4}},{"line":184,"address":[],"length":0,"stats":{"Line":4}},{"line":191,"address":[],"length":0,"stats":{"Line":4}},{"line":197,"address":[],"length":0,"stats":{"Line":4}},{"line":200,"address":[],"length":0,"stats":{"Line":6}},{"line":201,"address":[],"length":0,"stats":{"Line":5}},{"line":203,"address":[],"length":0,"stats":{"Line":8}},{"line":205,"address":[],"length":0,"stats":{"Line":4}},{"line":206,"address":[],"length":0,"stats":{"Line":4}},{"line":207,"address":[],"length":0,"stats":{"Line":4}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":2}},{"line":298,"address":[],"length":0,"stats":{"Line":2}},{"line":300,"address":[],"length":0,"stats":{"Line":2}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":4}},{"line":307,"address":[],"length":0,"stats":{"Line":2}},{"line":308,"address":[],"length":0,"stats":{"Line":2}},{"line":309,"address":[],"length":0,"stats":{"Line":2}},{"line":311,"address":[],"length":0,"stats":{"Line":2}},{"line":313,"address":[],"length":0,"stats":{"Line":6}},{"line":314,"address":[],"length":0,"stats":{"Line":4}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":2}},{"line":322,"address":[],"length":0,"stats":{"Line":2}},{"line":324,"address":[],"length":0,"stats":{"Line":4}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":4}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":4}},{"line":337,"address":[],"length":0,"stats":{"Line":2}},{"line":341,"address":[],"length":0,"stats":{"Line":2}},{"line":369,"address":[],"length":0,"stats":{"Line":2}},{"line":383,"address":[],"length":0,"stats":{"Line":2}},{"line":386,"address":[],"length":0,"stats":{"Line":2}},{"line":391,"address":[],"length":0,"stats":{"Line":4}},{"line":392,"address":[],"length":0,"stats":{"Line":2}},{"line":393,"address":[],"length":0,"stats":{"Line":2}},{"line":394,"address":[],"length":0,"stats":{"Line":2}},{"line":396,"address":[],"length":0,"stats":{"Line":2}},{"line":398,"address":[],"length":0,"stats":{"Line":2}},{"line":399,"address":[],"length":0,"stats":{"Line":4}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":2}},{"line":407,"address":[],"length":0,"stats":{"Line":2}},{"line":408,"address":[],"length":0,"stats":{"Line":2}},{"line":409,"address":[],"length":0,"stats":{"Line":2}},{"line":410,"address":[],"length":0,"stats":{"Line":2}},{"line":412,"address":[],"length":0,"stats":{"Line":11}},{"line":413,"address":[],"length":0,"stats":{"Line":6}},{"line":415,"address":[],"length":0,"stats":{"Line":485}},{"line":416,"address":[],"length":0,"stats":{"Line":485}},{"line":417,"address":[],"length":0,"stats":{"Line":6}},{"line":418,"address":[],"length":0,"stats":{"Line":6}},{"line":419,"address":[],"length":0,"stats":{"Line":3}},{"line":420,"address":[],"length":0,"stats":{"Line":3}},{"line":421,"address":[],"length":0,"stats":{"Line":9}},{"line":422,"address":[],"length":0,"stats":{"Line":2}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":2}},{"line":425,"address":[],"length":0,"stats":{"Line":2}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":1}},{"line":435,"address":[],"length":0,"stats":{"Line":1}},{"line":436,"address":[],"length":0,"stats":{"Line":1}},{"line":437,"address":[],"length":0,"stats":{"Line":1}},{"line":442,"address":[],"length":0,"stats":{"Line":7}},{"line":443,"address":[],"length":0,"stats":{"Line":2}},{"line":447,"address":[],"length":0,"stats":{"Line":3}},{"line":450,"address":[],"length":0,"stats":{"Line":479}},{"line":456,"address":[],"length":0,"stats":{"Line":2}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":3}},{"line":468,"address":[],"length":0,"stats":{"Line":1}},{"line":471,"address":[],"length":0,"stats":{"Line":2}},{"line":472,"address":[],"length":0,"stats":{"Line":2}},{"line":473,"address":[],"length":0,"stats":{"Line":2}},{"line":474,"address":[],"length":0,"stats":{"Line":2}},{"line":475,"address":[],"length":0,"stats":{"Line":2}},{"line":476,"address":[],"length":0,"stats":{"Line":2}},{"line":477,"address":[],"length":0,"stats":{"Line":4}},{"line":481,"address":[],"length":0,"stats":{"Line":2}},{"line":497,"address":[],"length":0,"stats":{"Line":4}},{"line":500,"address":[],"length":0,"stats":{"Line":4}},{"line":503,"address":[],"length":0,"stats":{"Line":4}},{"line":509,"address":[],"length":0,"stats":{"Line":4}},{"line":513,"address":[],"length":0,"stats":{"Line":6}},{"line":524,"address":[],"length":0,"stats":{"Line":4}},{"line":531,"address":[],"length":0,"stats":{"Line":4}},{"line":532,"address":[],"length":0,"stats":{"Line":11}}],"covered":94,"coverable":163},{"path":["/","Users","stippi","projects","code-assistant","src","main.rs"],"content":"mod agent;\nmod config;\nmod explorer;\nmod llm;\nmod mcp;\nmod persistence;\nmod tools;\nmod types;\nmod ui;\nmod utils;\n\nuse crate::agent::{Agent, ToolMode};\nuse crate::explorer::Explorer;\nuse crate::llm::{AnthropicClient, LLMProvider, OllamaClient, OpenAIClient, VertexClient};\nuse crate::mcp::MCPServer;\nuse crate::ui::terminal::TerminalUI;\nuse crate::utils::DefaultCommandExecutor;\nuse anyhow::{Context, Result};\nuse clap::{Parser, Subcommand, ValueEnum};\nuse persistence::FileStatePersistence;\nuse std::io;\nuse std::path::PathBuf;\nuse tracing_subscriber::fmt::SubscriberBuilder;\n\n#[derive(ValueEnum, Debug, Clone)]\nenum LLMProviderType {\n    Anthropic,\n    OpenAI,\n    Ollama,\n    Vertex,\n}\n\n#[derive(ValueEnum, Debug, Clone)]\nenum ToolsType {\n    Native,\n    Xml,\n}\n\n#[derive(Parser, Debug)]\n#[command(version, about, long_about = None)]\nstruct Args {\n    #[command(subcommand)]\n    mode: Mode,\n}\n\n#[derive(Subcommand, Debug)]\nenum Mode {\n    /// Run as autonomous agent with LLM support\n    Agent {\n        /// Path to the code directory to analyze\n        #[arg(long, default_value = \".\")]\n        path: PathBuf,\n\n        /// Task to perform on the codebase (required unless --continue is used)\n        #[arg(short, long, required_unless_present = \"continue_task\")]\n        task: Option\u003cString\u003e,\n\n        /// Continue from previous state\n        #[arg(long)]\n        continue_task: bool,\n\n        /// Enable verbose logging\n        #[arg(short, long)]\n        verbose: bool,\n\n        /// LLM provider to use\n        #[arg(short = 'p', long, default_value = \"anthropic\")]\n        provider: LLMProviderType,\n\n        /// Model name to use (provider-specific)\n        #[arg(short = 'm', long)]\n        model: Option\u003cString\u003e,\n\n        /// Context window size (in tokens, only relevant for Ollama)\n        #[arg(long, default_value = \"8192\")]\n        num_ctx: usize,\n\n        /// Type of tool declaration ('native' = tools via API, 'xml' = custom system message)\n        #[arg(long)]\n        tools_type: ToolsType,\n    },\n    /// Run as MCP server\n    Server {\n        /// Enable verbose logging\n        #[arg(short, long)]\n        verbose: bool,\n    },\n}\n\nfn create_llm_client(\n    provider: LLMProviderType,\n    model: Option\u003cString\u003e,\n    num_ctx: usize,\n) -\u003e Result\u003cBox\u003cdyn LLMProvider\u003e\u003e {\n    match provider {\n        LLMProviderType::Anthropic =\u003e {\n            let api_key = std::env::var(\"ANTHROPIC_API_KEY\")\n                .context(\"ANTHROPIC_API_KEY environment variable not set\")?;\n\n            Ok(Box::new(AnthropicClient::new(\n                api_key,\n                model\n                    .clone()\n                    .unwrap_or_else(|| \"claude-3-5-sonnet-20241022\".to_string()),\n            )))\n        }\n\n        LLMProviderType::OpenAI =\u003e {\n            let api_key = std::env::var(\"OPENAI_API_KEY\")\n                .context(\"OPENAI_API_KEY environment variable not set\")?;\n\n            Ok(Box::new(OpenAIClient::new(\n                api_key,\n                model.clone().unwrap_or_else(|| \"gpt-4o\".to_string()),\n            )))\n        }\n\n        LLMProviderType::Vertex =\u003e {\n            let api_key = std::env::var(\"GOOGLE_API_KEY\")\n                .context(\"GOOGLE_API_KEY environment variable not set\")?;\n\n            Ok(Box::new(VertexClient::new(\n                api_key,\n                model\n                    .clone()\n                    .unwrap_or_else(|| \"gemini-1.5-pro-latest\".to_string()),\n            )))\n        }\n\n        LLMProviderType::Ollama =\u003e Ok(Box::new(OllamaClient::new(\n            model\n                .clone()\n                .context(\"Model name is required for Ollama provider\")?,\n            num_ctx,\n        ))),\n    }\n}\n\nfn setup_logging(verbose: bool, use_stdout: bool) {\n    let filter = {\n        if verbose {\n            \"code_assistant=debug,info\".to_string()\n        } else {\n            \"code_assistant=info,warn\".to_string()\n        }\n    };\n\n    let subscriber = tracing_subscriber::fmt()\n        .with_env_filter(filter)\n        .with_target(false)\n        .with_thread_ids(false)\n        .with_file(true)\n        .with_line_number(true)\n        .with_level(true);\n\n    // For server mode, write only to stderr to keep stdout clean for JSON-RPC\n    let subscriber: SubscriberBuilder\u003c_, _, _, fn() -\u003e Box\u003cdyn io::Write + Send\u003e\u003e = if use_stdout {\n        subscriber.with_writer(|| Box::new(std::io::stdout()) as Box\u003cdyn io::Write + Send\u003e)\n    } else {\n        subscriber.with_writer(|| Box::new(std::io::stderr()) as Box\u003cdyn io::Write + Send\u003e)\n    };\n\n    subscriber.init();\n}\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    // Parse command line arguments\n    let args = Args::parse();\n\n    match args.mode {\n        Mode::Agent {\n            path,\n            task,\n            continue_task,\n            verbose,\n            provider,\n            model,\n            num_ctx,\n            tools_type,\n        } =\u003e {\n            // Setup logging based on verbose flag\n            setup_logging(verbose, true);\n\n            // Ensure the path exists and is a directory\n            if !path.is_dir() {\n                anyhow::bail!(\"Path '{}' is not a directory\", path.display());\n            }\n\n            // Setup LLM client with the specified provider\n            let llm_client = create_llm_client(provider, model, num_ctx)\n                .context(\"Failed to initialize LLM client\")?;\n\n            // Setup dynamic types\n            let root_path = path.canonicalize()?;\n            let explorer = Box::new(Explorer::new(root_path.clone()));\n            let terminal_ui = Box::new(TerminalUI::new());\n            let command_executor = Box::new(DefaultCommandExecutor);\n            let state_persistence = Box::new(FileStatePersistence::new(root_path.clone()));\n\n            // Validate parameters\n            if continue_task \u0026\u0026 task.is_some() {\n                anyhow::bail!(\n                    \"Cannot specify both --task and --continue. The task will be loaded from the saved state.\"\n                );\n            }\n\n            if !continue_task \u0026\u0026 task.is_none() {\n                anyhow::bail!(\"Either --task or --continue must be specified\");\n            }\n\n            // Initialize agent\n            let mut agent = Agent::new(\n                llm_client,\n                match \u0026tools_type {\n                    ToolsType::Native =\u003e ToolMode::Native,\n                    ToolsType::Xml =\u003e ToolMode::Xml,\n                },\n                explorer,\n                command_executor,\n                terminal_ui,\n                state_persistence,\n            );\n\n            // Get task either from state file or argument\n            if continue_task {\n                agent.start_from_state().await?;\n            } else {\n                agent.start_with_task(task.unwrap()).await?;\n            }\n        }\n\n        Mode::Server { verbose } =\u003e {\n            // Setup logging based on verbose flag\n            setup_logging(verbose, false);\n\n            // Initialize server\n            let mut server = MCPServer::new()?;\n            server.run().await?;\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":76},{"path":["/","Users","stippi","projects","code-assistant","src","mcp","handler.rs"],"content":"use super::resources::ResourceManager;\nuse super::types::*;\nuse crate::explorer::Explorer;\nuse crate::tools::{parse_tool_json, MCPToolHandler, ToolExecutor};\nuse crate::types::{CodeExplorer, ToolResult, Tools};\nuse crate::utils::{CommandExecutor, DefaultCommandExecutor};\nuse anyhow::Result;\nuse tokio::io::{AsyncWriteExt, Stdout};\nuse tracing::{debug, error, trace};\n\npub struct MessageHandler {\n    explorer: Option\u003cBox\u003cdyn CodeExplorer\u003e\u003e,\n    command_executor: Box\u003cdyn CommandExecutor\u003e,\n    resources: ResourceManager,\n    stdout: Stdout,\n}\n\nimpl MessageHandler {\n    pub fn new(stdout: Stdout) -\u003e Result\u003cSelf\u003e {\n        Ok(Self {\n            explorer: None,\n            command_executor: Box::new(DefaultCommandExecutor),\n            resources: ResourceManager::new(),\n            stdout,\n        })\n    }\n\n    /// Sends a JSON-RPC response\n    async fn send_response\u003cT: serde::Serialize\u003e(\u0026mut self, id: RequestId, result: T) -\u003e Result\u003c()\u003e {\n        let response = JSONRPCResponse {\n            jsonrpc: \"2.0\".to_string(),\n            id,\n            result,\n        };\n        self.send_message(\u0026serde_json::to_value(response)?).await\n    }\n\n    /// Sends a JSON-RPC error response\n    async fn send_error(\n        \u0026mut self,\n        id: RequestId,\n        code: i32,\n        message: String,\n        data: Option\u003cserde_json::Value\u003e,\n    ) -\u003e Result\u003c()\u003e {\n        let error = JSONRPCError {\n            jsonrpc: \"2.0\".to_string(),\n            id,\n            error: ErrorObject {\n                code,\n                message,\n                data,\n            },\n        };\n        self.send_message(\u0026serde_json::to_value(error)?).await\n    }\n\n    /// Helper method to send any JSON message\n    async fn send_message(\u0026mut self, message: \u0026serde_json::Value) -\u003e Result\u003c()\u003e {\n        let message_str = serde_json::to_string(message)?;\n\n        // Skip logging for certain message types\n        let skip_logging = [\"\\\"result\\\":{\\\"prompts\\\":\", \"\\\"result\\\":{\\\"resources\\\":\"]\n            .iter()\n            .any(|s| message_str.contains(s));\n\n        if !skip_logging {\n            debug!(\"Sending message: {}\", message_str);\n        }\n\n        self.stdout.write_all(message_str.as_bytes()).await?;\n        self.stdout.write_all(b\"\\n\").await?;\n        self.stdout.flush().await?;\n        Ok(())\n    }\n\n    /// Sends a notification\n    async fn send_notification(\n        \u0026mut self,\n        method: \u0026str,\n        params: Option\u003cserde_json::Value\u003e,\n    ) -\u003e Result\u003c()\u003e {\n        let notification = if let Some(params) = params {\n            serde_json::json!({\n                \"jsonrpc\": \"2.0\",\n                \"method\": method,\n                \"params\": params\n            })\n        } else {\n            serde_json::json!({\n                \"jsonrpc\": \"2.0\",\n                \"method\": method\n            })\n        };\n        self.send_message(\u0026notification).await\n    }\n\n    /// Handle initialize request\n    async fn handle_initialize(\u0026mut self, id: RequestId, params: InitializeParams) -\u003e Result\u003c()\u003e {\n        debug!(\"Initialize params: {:?}\", params);\n\n        self.send_response(\n            id,\n            InitializeResult {\n                capabilities: ServerCapabilities {\n                    resources: Some(ResourcesCapability {\n                        list_changed: Some(true),\n                        subscribe: Some(true),\n                    }),\n                    tools: Some(ToolsCapability {\n                        list_changed: Some(true),\n                    }),\n                    experimental: None,\n                },\n                protocol_version: params.protocol_version,\n                server_info: Implementation {\n                    name: \"code-assistant\".to_string(),\n                    version: \"0.1.0\".to_string(),\n                },\n                instructions: Some(\"Code Assistant helps you analyze and modify code.\".to_string()),\n            },\n        )\n        .await\n    }\n\n    /// Notify clients that a specific resource has been updated\n    async fn send_resource_updated_notification(\u0026mut self, uri: \u0026str) -\u003e Result\u003c()\u003e {\n        if !self.resources.is_subscribed(uri) {\n            debug!(\"Resource changed, but is not subscribed: {}\", uri);\n            return Ok(());\n        }\n        self.send_notification(\n            \"notifications/resources/updated\",\n            Some(serde_json::json!({ \"uri\": uri })),\n        )\n        .await\n    }\n\n    /// Handle resources/list request\n    async fn handle_resources_list(\u0026mut self, id: RequestId) -\u003e Result\u003c()\u003e {\n        trace!(\"Handling resources/list request\");\n        self.send_response(\n            id,\n            ListResourcesResult {\n                resources: self.resources.list_resources(),\n                next_cursor: None,\n            },\n        )\n        .await\n    }\n\n    /// Handle resources/read request\n    async fn handle_resources_read(\u0026mut self, id: RequestId, uri: String) -\u003e Result\u003c()\u003e {\n        debug!(\"Handling resources/read request for {}\", uri);\n        match self.resources.read_resource(\u0026uri) {\n            Some(content) =\u003e {\n                self.send_response(\n                    id,\n                    ReadResourceResult {\n                        contents: vec![content],\n                    },\n                )\n                .await\n            }\n            None =\u003e {\n                self.send_error(id, -32001, format!(\"Resource not found: {}\", uri), None)\n                    .await\n            }\n        }\n    }\n\n    /// Handle resources/subscribe request\n    async fn handle_resources_subscribe(\u0026mut self, id: RequestId, uri: String) -\u003e Result\u003c()\u003e {\n        debug!(\"Handling resources/subscribe request for {}\", uri);\n        if self.resources.read_resource(\u0026uri).is_none() {\n            return self\n                .send_error(id, -32001, format!(\"Resource not found: {}\", uri), None)\n                .await;\n        }\n        self.resources.subscribe(\u0026uri);\n        self.send_response(id, EmptyResult { meta: None }).await\n    }\n\n    /// Handle resources/unsubscribe request\n    async fn handle_resources_unsubscribe(\u0026mut self, id: RequestId, uri: String) -\u003e Result\u003c()\u003e {\n        debug!(\"Handling resources/unsubscribe request for {}\", uri);\n        self.resources.unsubscribe(\u0026uri);\n        self.send_response(id, EmptyResult { meta: None }).await\n    }\n\n    /// Handle tools/list request\n    async fn handle_tools_list(\u0026mut self, id: RequestId) -\u003e Result\u003c()\u003e {\n        debug!(\"Handling tools/list request\");\n        self.send_response(\n            id,\n            ListToolsResult {\n                tools: Tools::mcp()\n                    .into_iter()\n                    .map(|tool| {\n                        serde_json::json!({\n                            \"name\": tool.name,\n                            \"description\": tool.description,\n                            \"inputSchema\": tool.parameters\n                        })\n                    })\n                    .collect(),\n                next_cursor: None,\n            },\n        )\n        .await\n    }\n\n    /// Notify clients that the tools list has changed\n    async fn send_tools_changed_notification(\u0026mut self) -\u003e Result\u003c()\u003e {\n        self.send_notification(\"notifications/tools/list_changed\", None)\n            .await\n    }\n\n    /// Handle tools/call request\n    async fn handle_tool_call(\u0026mut self, id: RequestId, params: ToolCallParams) -\u003e Result\u003c()\u003e {\n        debug!(\"Handling tool call for {}\", params.name);\n\n        let result = async {\n            let arguments = params\n                .arguments\n                .as_ref()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing parameters\"))?;\n\n            let tool = parse_tool_json(\u0026params.name, arguments)?;\n            let mut handler = MCPToolHandler::new();\n\n            let (output, result) = ToolExecutor::execute(\n                \u0026mut handler,\n                self.explorer.as_mut(),\n                \u0026self.command_executor,\n                None,\n                \u0026tool,\n            )\n            .await?;\n\n            // Handle special tool results\n            if let ToolResult::OpenProject { path, .. } = \u0026result {\n                if let Some(path) = path {\n                    self.explorer = Some(Box::new(Explorer::new(path.clone())));\n                    self.send_tools_changed_notification().await?;\n                    self.update_file_tree().await?;\n                }\n            }\n\n            if let ToolResult::ListFiles { .. } = \u0026result {\n                self.update_file_tree().await?;\n            }\n\n            Ok::\u003c_, anyhow::Error\u003e(output)\n        }\n        .await;\n\n        // Convert the result into a ToolCallResult response\n        match result {\n            Ok(output) =\u003e {\n                self.send_response(\n                    id,\n                    ToolCallResult {\n                        content: vec![ToolResultContent::Text { text: output }],\n                        is_error: None,\n                    },\n                )\n                .await\n            }\n            Err(e) =\u003e {\n                self.send_response(\n                    id,\n                    ToolCallResult {\n                        content: vec![ToolResultContent::Text {\n                            text: e.to_string(),\n                        }],\n                        is_error: Some(true),\n                    },\n                )\n                .await\n            }\n        }\n    }\n\n    async fn update_file_tree(\u0026mut self) -\u003e Result\u003c()\u003e {\n        if let Some(ref mut explorer) = self.explorer {\n            if let Ok(tree) = explorer.create_initial_tree(2) {\n                self.resources.update_file_tree(tree);\n                self.send_resource_updated_notification(\"tree:///\").await?;\n            }\n        }\n        Ok(())\n    }\n\n    /// Handle prompts/list request\n    async fn handle_prompts_list(\u0026mut self, id: RequestId) -\u003e Result\u003c()\u003e {\n        trace!(\"Handling prompts/list request\");\n        self.send_response(\n            id,\n            ListPromptsResult {\n                prompts: vec![],\n                next_cursor: None,\n            },\n        )\n        .await\n    }\n\n    /// Main message handling entry point\n    pub async fn handle_message(\u0026mut self, message: \u0026str) -\u003e Result\u003c()\u003e {\n        // Parse the message first\n        let message: JSONRPCMessage = match serde_json::from_str(message) {\n            Ok(msg) =\u003e msg,\n            Err(e) =\u003e {\n                error!(\"Invalid JSON-RPC message: {}\", e);\n                return Ok(());\n            }\n        };\n\n        match message {\n            JSONRPCMessage::Request(request) =\u003e {\n                trace!(\"Processing request: {:?}\", request);\n                match (request.method.as_str(), request.id) {\n                    (\"initialize\", Some(id)) =\u003e {\n                        let params: InitializeParams = serde_json::from_value(request.params)?;\n                        self.handle_initialize(id, params).await?;\n                    }\n\n                    (\"resources/list\", Some(id)) =\u003e {\n                        self.handle_resources_list(id).await?;\n                    }\n                    (\"resources/read\", Some(id)) =\u003e {\n                        let params: ReadResourceRequest = serde_json::from_value(request.params)?;\n                        self.handle_resources_read(id, params.uri).await?;\n                    }\n                    (\"resources/subscribe\", Some(id)) =\u003e {\n                        let params: SubscribeResourceRequest =\n                            serde_json::from_value(request.params)?;\n                        self.handle_resources_subscribe(id, params.uri).await?;\n                    }\n                    (\"resources/unsubscribe\", Some(id)) =\u003e {\n                        let params: UnsubscribeResourceRequest =\n                            serde_json::from_value(request.params)?;\n                        self.handle_resources_unsubscribe(id, params.uri).await?;\n                    }\n\n                    (\"tools/list\", Some(id)) =\u003e {\n                        self.handle_tools_list(id).await?;\n                    }\n\n                    (\"tools/call\", Some(id)) =\u003e {\n                        match serde_json::from_value::\u003cToolCallParams\u003e(request.params) {\n                            Ok(params) =\u003e {\n                                self.handle_tool_call(id, params).await?;\n                            }\n                            Err(e) =\u003e {\n                                self.send_response(\n                                    id,\n                                    ToolCallResult {\n                                        content: vec![ToolResultContent::Text {\n                                            text: format!(\"Invalid tool parameters: {}\", e),\n                                        }],\n                                        is_error: Some(true),\n                                    },\n                                )\n                                .await?;\n                            }\n                        }\n                    }\n\n                    (\"prompts/list\", Some(id)) =\u003e {\n                        self.handle_prompts_list(id).await?;\n                    }\n\n                    (method, Some(id)) =\u003e {\n                        self.send_error(id, -32601, format!(\"Method not found: {}\", method), None)\n                            .await?;\n                    }\n\n                    (_, None) =\u003e {\n                        debug!(\"Received notification request - ignoring\");\n                    }\n                }\n            }\n\n            JSONRPCMessage::Notification { method, params, .. } =\u003e match method.as_str() {\n                \"notifications/initialized\" =\u003e {\n                    if let Some(params) = params {\n                        debug!(\"Client initialized with params: {:?}\", params);\n                    } else {\n                        debug!(\"Client initialized\");\n                    }\n                }\n                _ =\u003e {\n                    debug!(\"Unknown notification: {}\", method);\n                }\n            },\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":213},{"path":["/","Users","stippi","projects","code-assistant","src","mcp","mod.rs"],"content":"mod handler;\nmod resources;\nmod server;\nmod types;\n\npub use server::MCPServer;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","stippi","projects","code-assistant","src","mcp","resources.rs"],"content":"use super::types::{Resource, ResourceContent};\nuse crate::types::FileTreeEntry;\nuse std::collections::HashSet;\n\npub struct ResourceManager {\n    file_tree: Option\u003cFileTreeEntry\u003e,\n    subscriptions: HashSet\u003cString\u003e,\n}\n\nimpl ResourceManager {\n    pub fn new() -\u003e Self {\n        Self {\n            file_tree: None,\n            subscriptions: HashSet::new(),\n        }\n    }\n\n    /// Lists all available resources\n    pub fn list_resources(\u0026self) -\u003e Vec\u003cResource\u003e {\n        let mut resources = Vec::new();\n        // Add file tree resource if available\n        if self.file_tree.is_some() {\n            resources.push(Resource {\n                uri: \"tree:///\".to_string(),\n                name: \"Repository Structure\".to_string(),\n                description: Some(\"The repository file tree structure\".to_string()),\n                mime_type: Some(\"text/plain\".to_string()),\n            });\n        }\n        resources\n    }\n\n    /// Reads a specific resource content\n    pub fn read_resource(\u0026self, uri: \u0026str) -\u003e Option\u003cResourceContent\u003e {\n        match uri {\n            \"tree:///\" =\u003e self.file_tree.as_ref().map(|t| ResourceContent {\n                uri: uri.to_string(),\n                mime_type: Some(\"text/plain\".to_string()),\n                text: Some(t.to_string()),\n            }),\n            _ =\u003e None,\n        }\n    }\n\n    /// Subscribes to a resource\n    pub fn subscribe(\u0026mut self, uri: \u0026str) {\n        self.subscriptions.insert(uri.to_string());\n    }\n\n    /// Unsubscribes from a resource\n    pub fn unsubscribe(\u0026mut self, uri: \u0026str) {\n        self.subscriptions.remove(uri);\n    }\n\n    /// Checks if a resource is subscribed\n    pub fn is_subscribed(\u0026self, uri: \u0026str) -\u003e bool {\n        self.subscriptions.contains(uri)\n    }\n\n    /// Updates the file tree\n    pub fn update_file_tree(\u0026mut self, tree: FileTreeEntry) {\n        self.file_tree = Some(tree);\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":26},{"path":["/","Users","stippi","projects","code-assistant","src","mcp","server.rs"],"content":"use crate::mcp::handler::MessageHandler;\nuse anyhow::Result;\nuse tokio::io::{stdin, AsyncBufReadExt, BufReader};\nuse tracing::{debug, error, trace};\n\npub struct MCPServer {\n    handler: MessageHandler,\n}\n\nimpl MCPServer {\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        Ok(Self {\n            handler: MessageHandler::new(tokio::io::stdout())?,\n        })\n    }\n\n    pub async fn run(\u0026mut self) -\u003e Result\u003c()\u003e {\n        debug!(\"Starting MCP server using stdio transport\");\n\n        let stdin = stdin();\n        let mut reader = BufReader::new(stdin);\n\n        let mut line = String::new();\n        while let Ok(n) = reader.read_line(\u0026mut line).await {\n            if n == 0 {\n                break; // EOF\n            }\n\n            let trimmed = line.trim();\n            trace!(\"Received message: {}\", trimmed);\n\n            // Process the message\n            match self.handler.handle_message(trimmed).await {\n                Ok(()) =\u003e {\n                    trace!(\"Message processed successfully\");\n                }\n                Err(e) =\u003e {\n                    error!(\"Error handling message: {}\", e);\n                }\n            }\n\n            line.clear();\n        }\n\n        debug!(\"MCP server shutting down\");\n        Ok(())\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":20},{"path":["/","Users","stippi","projects","code-assistant","src","mcp","types.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum RequestId {\n    String(String),\n    Number(i64),\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct JSONRPCRequest {\n    pub jsonrpc: String,\n    pub id: Option\u003cRequestId\u003e,\n    pub method: String,\n    pub params: serde_json::Value,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum JSONRPCMessage {\n    Request(JSONRPCRequest),\n    Notification {\n        jsonrpc: String,\n        method: String,\n        #[serde(default)]\n        params: Option\u003cserde_json::Value\u003e,\n    },\n}\n\n#[derive(Debug, Serialize)]\npub struct JSONRPCResponse\u003cT\u003e {\n    pub jsonrpc: String,\n    pub id: RequestId,\n    pub result: T,\n}\n\n#[derive(Debug, Serialize)]\npub struct JSONRPCError {\n    pub jsonrpc: String,\n    pub id: RequestId,\n    pub error: ErrorObject,\n}\n\n#[derive(Debug, Serialize)]\npub struct ErrorObject {\n    pub code: i32,\n    pub message: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub data: Option\u003cserde_json::Value\u003e,\n}\n\n#[derive(Debug, Serialize)]\npub struct EmptyResult {\n    #[serde(skip_serializing_if = \"Option::is_none\", rename = \"_meta\")]\n    pub meta: Option\u003cserde_json::Value\u003e,\n}\n\n// Client capabilities types\n#[derive(Debug, Serialize, Deserialize)]\npub struct ClientCapabilities {\n    pub tools: Option\u003cToolsCapability\u003e,\n    #[serde(default)]\n    pub experimental: Option\u003cserde_json::Map\u003cString, serde_json::Value\u003e\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ToolsCapability {\n    #[serde(rename = \"listChanged\")]\n    pub list_changed: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ResourcesCapability {\n    #[serde(rename = \"listChanged\")]\n    pub list_changed: Option\u003cbool\u003e,\n    pub subscribe: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Implementation {\n    pub name: String,\n    pub version: String,\n}\n\n// Initialize request/response types\n#[derive(Debug, Serialize, Deserialize)]\npub struct InitializeParams {\n    pub capabilities: ClientCapabilities,\n    #[serde(rename = \"clientInfo\")]\n    pub client_info: Implementation,\n    #[serde(rename = \"protocolVersion\")]\n    pub protocol_version: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ServerCapabilities {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub tools: Option\u003cToolsCapability\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub resources: Option\u003cResourcesCapability\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub experimental: Option\u003cserde_json::Map\u003cString, serde_json::Value\u003e\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct InitializeResult {\n    pub capabilities: ServerCapabilities,\n    #[serde(rename = \"protocolVersion\")]\n    pub protocol_version: String,\n    #[serde(rename = \"serverInfo\")]\n    pub server_info: Implementation,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub instructions: Option\u003cString\u003e,\n}\n\n// Resource types\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Resource {\n    pub uri: String,\n    pub name: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    #[serde(rename = \"mimeType\", skip_serializing_if = \"Option::is_none\")]\n    pub mime_type: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ListResourcesResult {\n    pub resources: Vec\u003cResource\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub next_cursor: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Deserialize)]\npub struct ReadResourceRequest {\n    pub uri: String,\n}\n\n#[derive(Debug, Deserialize)]\npub struct SubscribeResourceRequest {\n    pub uri: String,\n}\n\n#[derive(Debug, Deserialize)]\npub struct UnsubscribeResourceRequest {\n    pub uri: String,\n}\n\n#[derive(Debug, Serialize)]\npub struct ReadResourceResult {\n    pub contents: Vec\u003cResourceContent\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ResourceContent {\n    pub uri: String,\n    #[serde(rename = \"mimeType\", skip_serializing_if = \"Option::is_none\")]\n    pub mime_type: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub text: Option\u003cString\u003e,\n}\n\n// Tool types\n#[derive(Debug, Serialize, Deserialize)]\npub struct ListToolsResult {\n    pub tools: Vec\u003cserde_json::Value\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub next_cursor: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ToolCallParams {\n    pub name: String,\n    pub arguments: Option\u003cserde_json::Value\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ToolCallResult {\n    pub content: Vec\u003cToolResultContent\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub is_error: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(tag = \"type\")]\npub enum ToolResultContent {\n    #[serde(rename = \"text\")]\n    Text { text: String },\n}\n\n// Prompt types\n#[derive(Debug, Serialize, Deserialize)]\npub struct ListPromptsResult {\n    pub prompts: Vec\u003cPrompt\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub next_cursor: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Prompt {\n    pub name: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub arguments: Option\u003cVec\u003cPromptArgument\u003e\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct PromptArgument {\n    pub name: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub required: Option\u003cbool\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","stippi","projects","code-assistant","src","persistence.rs"],"content":"use crate::types::ActionResult;\nuse anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\nuse tracing::debug;\n\n/// Persistent state of the agent\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct AgentState {\n    /// Original task description\n    pub task: String,\n    /// Memory of all previous actions and their results\n    pub actions: Vec\u003cActionResult\u003e,\n}\n\npub trait StatePersistence: Send + Sync {\n    fn save_state(\u0026mut self, task: String, actions: Vec\u003cActionResult\u003e) -\u003e Result\u003c()\u003e;\n    fn load_state(\u0026mut self) -\u003e Result\u003cOption\u003cAgentState\u003e\u003e;\n    fn cleanup(\u0026mut self) -\u003e Result\u003c()\u003e;\n}\n\npub struct FileStatePersistence {\n    root_dir: PathBuf,\n}\n\nimpl FileStatePersistence {\n    pub fn new(root_dir: PathBuf) -\u003e Self {\n        Self { root_dir }\n    }\n}\n\nconst STATE_FILE: \u0026str = \".code-assistant.state.json\";\n\nimpl StatePersistence for FileStatePersistence {\n    fn save_state(\u0026mut self, task: String, actions: Vec\u003cActionResult\u003e) -\u003e Result\u003c()\u003e {\n        let state = AgentState { task, actions };\n        let state_path = self.root_dir.join(STATE_FILE);\n        debug!(\"Saving state to {}\", state_path.display());\n        let json = serde_json::to_string_pretty(\u0026state)?;\n        std::fs::write(state_path, json)?;\n        Ok(())\n    }\n\n    fn load_state(\u0026mut self) -\u003e Result\u003cOption\u003cAgentState\u003e\u003e {\n        let state_path = self.root_dir.join(STATE_FILE);\n        if !state_path.exists() {\n            return Ok(None);\n        }\n\n        debug!(\"Loading state from {}\", state_path.display());\n        let json = std::fs::read_to_string(state_path)?;\n        let state = serde_json::from_str(\u0026json)?;\n        Ok(Some(state))\n    }\n\n    fn cleanup(\u0026mut self) -\u003e Result\u003c()\u003e {\n        let state_path = self.root_dir.join(STATE_FILE);\n        if state_path.exists() {\n            debug!(\"Removing state file {}\", state_path.display());\n            std::fs::remove_file(state_path)?;\n        }\n        Ok(())\n    }\n}\n\n#[cfg(test)]\npub struct MockStatePersistence {\n    state: Option\u003cAgentState\u003e,\n}\n\n#[cfg(test)]\nimpl MockStatePersistence {\n    pub fn new() -\u003e Self {\n        Self { state: None }\n    }\n}\n\n#[cfg(test)]\nimpl StatePersistence for MockStatePersistence {\n    fn save_state(\u0026mut self, task: String, actions: Vec\u003cActionResult\u003e) -\u003e Result\u003c()\u003e {\n        // In-Memory state\n        let state = AgentState { task, actions };\n        self.state = Some(state);\n        Ok(())\n    }\n\n    fn load_state(\u0026mut self) -\u003e Result\u003cOption\u003cAgentState\u003e\u003e {\n        Ok(self.state.clone())\n    }\n\n    fn cleanup(\u0026mut self) -\u003e Result\u003c()\u003e {\n        self.state = None;\n        Ok(())\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["/","Users","stippi","projects","code-assistant","src","tools","definitions.rs"],"content":"use crate::types::{ToolDefinition, Tools};\nuse serde_json::json;\n\nimpl Tools {\n    /// Returns all available tool definitions\n    pub fn all() -\u003e Vec\u003cToolDefinition\u003e {\n        vec![\n            Self::execute_command(),\n            Self::search_files(),\n            Self::list_files(),\n            Self::read_files(),\n            Self::summarize(),\n            Self::replace_in_file(),\n            Self::write_file(),\n            Self::delete_files(),\n            Self::ask_user(),\n            Self::message_user(),\n            Self::complete_task(),\n        ]\n    }\n\n    pub fn mcp() -\u003e Vec\u003cToolDefinition\u003e {\n        vec![\n            Self::list_projects(),\n            Self::open_project(),\n            Self::execute_command(),\n            Self::search_files(),\n            Self::list_files(),\n            Self::read_files(),\n            Self::summarize(),\n            Self::replace_in_file(),\n            Self::write_file(),\n            Self::delete_files(),\n        ]\n    }\n\n    pub fn list_projects() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"list_projects\".to_string(),\n            description: \"List all available projects\".to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {},\n                \"required\": []\n            }),\n        }\n    }\n\n    pub fn open_project() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"open_project\".to_string(),\n            description: \"Open a specific project\".to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"name\": {\n                        \"type\": \"string\",\n                        \"description\": \"Name of the project to open\"\n                    }\n                },\n                \"required\": [\"name\"]\n            }),\n        }\n    }\n\n    pub fn execute_command() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"execute_command\".to_string(),\n            description: \"Execute a command line program\".to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"command_line\": {\n                        \"type\": \"string\",\n                        \"description\": \"The complete command to execute\"\n                    },\n                    \"working_dir\": {\n                        \"type\": \"string\",\n                        \"description\": \"Optional: working directory for the command\"\n                    }\n                },\n                \"required\": [\"command_line\"]\n            }),\n        }\n    }\n\n    pub fn search_files() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"search_files\".to_string(),\n            description: \"Search for text in files with advanced options\".to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"query\": {\n                        \"type\": \"string\",\n                        \"description\": \"The text to search for. Supports regular expressions.\"\n                    },\n                    \"path\": {\n                        \"type\": \"string\",\n                        \"description\": \"Optional: directory path to search in (relative to project root)\"\n                    },\n                    \"max_results\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Optional: maximum number of results to return\"\n                    },\n                    \"case_sensitive\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"Optional: whether the search should be case-sensitive (default: false)\"\n                    },\n                    \"whole_words\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"Optional: match whole words only (default: false)\"\n                    },\n                    \"mode\": {\n                        \"type\": \"string\",\n                        \"description\": \"Optional: search mode - 'exact' (default) for standard text search, or 'regex' for regular expressions\",\n                        \"enum\": [\"exact\", \"regex\"]\n                    }\n                },\n                \"required\": [\"query\"]\n            }),\n        }\n    }\n\n    pub fn list_files() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"list_files\".to_string(),\n            description: \"List files in a directory\".to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"paths\": {\n                        \"type\": \"array\",\n                        \"description\": \"Directory paths relative to project root\",\n                        \"items\": {\n                            \"type\": \"string\"\n                        }\n                    },\n                    \"max_depth\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Maximum directory depth\"\n                    }\n                },\n                \"required\": [\"paths\"]\n            }),\n        }\n    }\n\n    pub fn read_files() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"read_files\".to_string(),\n            description: \"Load files into working memory\".to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"paths\": {\n                        \"type\": \"array\",\n                        \"description\": \"Paths to the files relative to the workspace root directory\",\n                        \"items\": {\n                            \"type\": \"string\"\n                        }\n                    }\n                },\n                \"required\": [\"paths\"]\n            }),\n        }\n    }\n\n    pub fn summarize() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"summarize\".to_string(),\n            description:\n                \"Replace file content with a summary in working memory, unloading the full content.\"\n                    .to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"files\": {\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"type\": \"object\",\n                            \"properties\": {\n                                \"path\": {\n                                    \"type\": \"string\",\n                                    \"description\": \"Path to the file to summarize\"\n                                },\n                                \"summary\": {\n                                    \"type\": \"string\",\n                                    \"description\": \"Your summary of the file contents\"\n                                }\n                            },\n                            \"required\": [\"path\", \"summary\"]\n                        }\n                    }\n                },\n                \"required\": [\"files\"]\n            }),\n        }\n    }\n\n    pub fn replace_in_file() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"replace_in_file\".to_string(),\n            description: \"Replace sections in a file using search/replace blocks. Each search text must appear exactly once in the file - otherwise the operation will fail.\".to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"path\": {\n                        \"type\": \"string\",\n                        \"description\": \"Path to the file to modify\"\n                    },\n                    \"replacements\": {\n                        \"type\": \"array\",\n                        \"description\": \"List of search/replace pairs\",\n                        \"items\": {\n                            \"type\": \"object\",\n                            \"properties\": {\n                                \"search\": {\n                                    \"type\": \"string\",\n                                    \"description\": \"Exact content to find. Make sure it is unique in the file by providing a large enough search string!\"\n                                },\n                                \"replace\": {\n                                    \"type\": \"string\",\n                                    \"description\": \"Content to replace with\"\n                                }\n                            },\n                            \"required\": [\"search\", \"replace\"]\n                        }\n                    }\n                },\n                \"required\": [\"path\", \"replacements\"]\n            }),\n        }\n    }\n\n    pub fn write_file() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"write_file\".to_string(),\n            description:\n                \"Creates or overwrites a file. Use for new files or when updating most of a file. \\\n                         For smaller updates prefer to use update-file.\"\n                    .to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"path\": {\n                        \"type\": \"string\",\n                        \"description\": \"Path to create or overwrite\"\n                    },\n                    \"content\": {\n                        \"type\": \"string\",\n                        \"description\": \"Content to write\"\n                    }\n                },\n                \"required\": [\"path\", \"content\"]\n            }),\n        }\n    }\n\n    pub fn delete_files() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"delete_files\".to_string(),\n            description: \"Delete files from the workspace. This operation cannot be undone!\"\n                .to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"paths\": {\n                        \"type\": \"array\",\n                        \"description\": \"Paths to the files relative to the workspace root directory\",\n                        \"items\": {\n                            \"type\": \"string\"\n                        }\n                    }\n                },\n                \"required\": [\"paths\"]\n            }),\n        }\n    }\n\n    pub fn ask_user() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"ask_user\".to_string(),\n            description:\n                \"Ask the user a question. Use for clarifications, feedback or confirmation.\"\n                    .to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"question\": {\n                        \"type\": \"string\",\n                        \"description\": \"The question for the user\"\n                    }\n                },\n                \"required\": [\"question\"]\n            }),\n        }\n    }\n\n    pub fn message_user() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"message_user\".to_string(),\n            description: \"Complete the task\".to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"message\": {\n                        \"type\": \"string\",\n                        \"description\": \"A final message for the user\"\n                    }\n                },\n                \"required\": [\"message\"]\n            }),\n        }\n    }\n\n    pub fn complete_task() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"complete_task\".to_string(),\n            description: \"Complete the task\".to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"message\": {\n                        \"type\": \"string\",\n                        \"description\": \"A final message for the user\"\n                    }\n                },\n                \"required\": [\"message\"]\n            }),\n        }\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":22}},{"line":7,"address":[],"length":0,"stats":{"Line":22}},{"line":8,"address":[],"length":0,"stats":{"Line":22}},{"line":9,"address":[],"length":0,"stats":{"Line":22}},{"line":10,"address":[],"length":0,"stats":{"Line":22}},{"line":11,"address":[],"length":0,"stats":{"Line":22}},{"line":12,"address":[],"length":0,"stats":{"Line":22}},{"line":13,"address":[],"length":0,"stats":{"Line":22}},{"line":14,"address":[],"length":0,"stats":{"Line":22}},{"line":15,"address":[],"length":0,"stats":{"Line":22}},{"line":16,"address":[],"length":0,"stats":{"Line":22}},{"line":17,"address":[],"length":0,"stats":{"Line":22}},{"line":18,"address":[],"length":0,"stats":{"Line":22}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":22}},{"line":68,"address":[],"length":0,"stats":{"Line":22}},{"line":69,"address":[],"length":0,"stats":{"Line":22}},{"line":70,"address":[],"length":0,"stats":{"Line":22}},{"line":87,"address":[],"length":0,"stats":{"Line":22}},{"line":89,"address":[],"length":0,"stats":{"Line":22}},{"line":90,"address":[],"length":0,"stats":{"Line":22}},{"line":91,"address":[],"length":0,"stats":{"Line":22}},{"line":125,"address":[],"length":0,"stats":{"Line":22}},{"line":127,"address":[],"length":0,"stats":{"Line":22}},{"line":128,"address":[],"length":0,"stats":{"Line":22}},{"line":129,"address":[],"length":0,"stats":{"Line":22}},{"line":149,"address":[],"length":0,"stats":{"Line":22}},{"line":151,"address":[],"length":0,"stats":{"Line":22}},{"line":152,"address":[],"length":0,"stats":{"Line":22}},{"line":153,"address":[],"length":0,"stats":{"Line":22}},{"line":169,"address":[],"length":0,"stats":{"Line":22}},{"line":171,"address":[],"length":0,"stats":{"Line":22}},{"line":172,"address":[],"length":0,"stats":{"Line":22}},{"line":175,"address":[],"length":0,"stats":{"Line":22}},{"line":201,"address":[],"length":0,"stats":{"Line":22}},{"line":203,"address":[],"length":0,"stats":{"Line":22}},{"line":204,"address":[],"length":0,"stats":{"Line":22}},{"line":205,"address":[],"length":0,"stats":{"Line":22}},{"line":236,"address":[],"length":0,"stats":{"Line":22}},{"line":238,"address":[],"length":0,"stats":{"Line":22}},{"line":239,"address":[],"length":0,"stats":{"Line":22}},{"line":243,"address":[],"length":0,"stats":{"Line":22}},{"line":260,"address":[],"length":0,"stats":{"Line":22}},{"line":262,"address":[],"length":0,"stats":{"Line":22}},{"line":263,"address":[],"length":0,"stats":{"Line":22}},{"line":265,"address":[],"length":0,"stats":{"Line":22}},{"line":281,"address":[],"length":0,"stats":{"Line":22}},{"line":283,"address":[],"length":0,"stats":{"Line":22}},{"line":284,"address":[],"length":0,"stats":{"Line":22}},{"line":287,"address":[],"length":0,"stats":{"Line":22}},{"line":300,"address":[],"length":0,"stats":{"Line":22}},{"line":302,"address":[],"length":0,"stats":{"Line":22}},{"line":303,"address":[],"length":0,"stats":{"Line":22}},{"line":304,"address":[],"length":0,"stats":{"Line":22}},{"line":317,"address":[],"length":0,"stats":{"Line":22}},{"line":319,"address":[],"length":0,"stats":{"Line":22}},{"line":320,"address":[],"length":0,"stats":{"Line":22}},{"line":321,"address":[],"length":0,"stats":{"Line":22}}],"covered":57,"coverable":77},{"path":["/","Users","stippi","projects","code-assistant","src","tools","executor.rs"],"content":"use super::ToolResultHandler;\nuse crate::config;\nuse crate::types::{CodeExplorer, SearchMode, SearchOptions, Tool, ToolResult};\nuse crate::ui::{UIMessage, UserInterface};\nuse crate::utils::CommandExecutor;\nuse anyhow::Result;\nuse std::collections::HashMap;\nuse std::path::Path;\n\npub struct ToolExecutor {}\n\nfn check_absolute_path(path: \u0026Path) -\u003e Option\u003cToolResult\u003e {\n    if path.is_absolute() {\n        Some(ToolResult::AbsolutePathError {\n            path: path.to_path_buf(),\n        })\n    } else {\n        None\n    }\n}\n\nimpl ToolExecutor {\n    pub async fn execute\u003cH: ToolResultHandler\u003e(\n        handler: \u0026mut H,\n        explorer: Option\u003c\u0026mut Box\u003cdyn CodeExplorer\u003e\u003e,\n        command_executor: \u0026Box\u003cdyn CommandExecutor\u003e,\n        ui: Option\u003c\u0026Box\u003cdyn UserInterface\u003e\u003e,\n        tool: \u0026Tool,\n    ) -\u003e Result\u003c(String, ToolResult)\u003e {\n        let result = match tool {\n            Tool::ListProjects =\u003e {\n                let projects = config::load_projects()?;\n                ToolResult::ListProjects { projects }\n            }\n\n            Tool::OpenProject { name } =\u003e {\n                let projects = config::load_projects()?;\n                match projects.get(name) {\n                    Some(project) =\u003e ToolResult::OpenProject {\n                        name: name.clone(),\n                        path: Some(project.path.to_path_buf()),\n                        error: None,\n                    },\n                    None =\u003e ToolResult::OpenProject {\n                        name: name.clone(),\n                        path: None,\n                        error: Some(\"Project not found\".to_string()),\n                    },\n                }\n            }\n\n            Tool::Summarize { files } =\u003e ToolResult::Summarize {\n                files: files.clone(),\n            },\n\n            Tool::MessageUser { message } =\u003e match \u0026ui {\n                Some(ui) =\u003e match ui.display(UIMessage::Action(message.clone())).await {\n                    Ok(_) =\u003e ToolResult::MessageUser {\n                        result: \"Message delivered\".to_string(),\n                    },\n                    Err(e) =\u003e ToolResult::MessageUser {\n                        result: format!(\"Failed to deliver message: {}\", e),\n                    },\n                },\n                None =\u003e ToolResult::MessageUser {\n                    result: \"Messaging user not available\".to_string(),\n                },\n            },\n\n            Tool::AskUser { question } =\u003e match \u0026ui {\n                Some(ui) =\u003e {\n                    // Display the question\n                    ui.display(UIMessage::Question(question.clone())).await?;\n\n                    // Get the input\n                    match ui.get_input(\"\u003e \").await {\n                        Ok(response) =\u003e ToolResult::AskUser { response },\n                        Err(e) =\u003e ToolResult::AskUser {\n                            response: format!(\"Failed to get user input: {}\", e),\n                        },\n                    }\n                }\n                None =\u003e ToolResult::AskUser {\n                    response: \"User input not available\".to_string(),\n                },\n            },\n\n            Tool::CompleteTask { message } =\u003e match \u0026ui {\n                Some(ui) =\u003e match ui.display(UIMessage::Action(message.clone())).await {\n                    Ok(_) =\u003e ToolResult::CompleteTask {\n                        result: \"Message delivered\".to_string(),\n                    },\n                    Err(e) =\u003e ToolResult::CompleteTask {\n                        result: format!(\"Failed to deliver message: {}\", e),\n                    },\n                },\n                None =\u003e ToolResult::CompleteTask {\n                    result: \"Messaging user not available\".to_string(),\n                },\n            },\n\n            _ =\u003e {\n                let explorer = explorer.ok_or_else(|| {\n                    anyhow::anyhow!(\"This tool requires an active project. Use open_project first.\")\n                })?;\n                match tool {\n                    Tool::ReadFiles { paths } =\u003e {\n                        // Check for absolute paths\n                        for path in paths {\n                            if let Some(error) = check_absolute_path(path) {\n                                return Ok((String::new(), error));\n                            }\n                        }\n                        let mut loaded_files = HashMap::new();\n                        let mut failed_files = Vec::new();\n\n                        for path in paths {\n                            let full_path = explorer.root_dir().join(path);\n                            match explorer.read_file(\u0026full_path) {\n                                Ok(content) =\u003e {\n                                    loaded_files.insert(path.clone(), content);\n                                }\n                                Err(e) =\u003e {\n                                    failed_files.push((path.clone(), e.to_string()));\n                                }\n                            }\n                        }\n\n                        ToolResult::ReadFiles {\n                            loaded_files,\n                            failed_files,\n                        }\n                    }\n\n                    Tool::ListFiles { paths, max_depth } =\u003e {\n                        // Check for absolute paths\n                        for path in paths {\n                            if let Some(error) = check_absolute_path(path) {\n                                return Ok((String::new(), error));\n                            }\n                        }\n                        let explorer = explorer; // Shadow with non-ref binding\n                        let mut expanded_paths = Vec::new();\n                        let mut failed_paths = Vec::new();\n\n                        for path in paths {\n                            let full_path = explorer.root_dir().join(path);\n                            match explorer.list_files(\u0026full_path, *max_depth) {\n                                Ok(tree_entry) =\u003e {\n                                    expanded_paths.push((path.clone(), tree_entry));\n                                }\n                                Err(e) =\u003e {\n                                    failed_paths.push((path.display().to_string(), e.to_string()));\n                                }\n                            }\n                        }\n\n                        ToolResult::ListFiles {\n                            expanded_paths,\n                            failed_paths,\n                        }\n                    }\n\n                    Tool::SearchFiles {\n                        query,\n                        path,\n                        case_sensitive,\n                        whole_words,\n                        regex_mode,\n                        max_results,\n                    } =\u003e {\n                        let options = SearchOptions {\n                            query: query.clone(),\n                            case_sensitive: *case_sensitive,\n                            whole_words: *whole_words,\n                            mode: if *regex_mode {\n                                SearchMode::Regex\n                            } else {\n                                SearchMode::Exact\n                            },\n                            max_results: *max_results,\n                        };\n\n                        let search_path = if let Some(p) = path {\n                            if p.is_absolute() {\n                                p.clone()\n                            } else {\n                                explorer.root_dir().join(p)\n                            }\n                        } else {\n                            explorer.root_dir()\n                        };\n\n                        match explorer.search(\u0026search_path, options) {\n                            Ok(results) =\u003e ToolResult::SearchFiles {\n                                results,\n                                query: query.clone(),\n                            },\n                            Err(e) =\u003e ToolResult::SearchFiles {\n                                results: Vec::new(),\n                                query: format!(\"Search failed: {}\", e),\n                            },\n                        }\n                    }\n\n                    Tool::ExecuteCommand {\n                        command_line,\n                        working_dir,\n                    } =\u003e {\n                        let effective_working_dir = match working_dir {\n                            Some(dir) if dir.is_absolute() =\u003e {\n                                return Ok((\n                                    String::new(),\n                                    ToolResult::ExecuteCommand {\n                                        stdout: String::new(),\n                                        stderr: String::new(),\n                                        error: Some(\n                                            \"Working directory must be relative to project root\"\n                                                .to_string(),\n                                        ),\n                                    },\n                                ));\n                            }\n                            Some(dir) =\u003e explorer.root_dir().join(dir),\n                            None =\u003e explorer.root_dir(),\n                        };\n\n                        match command_executor\n                            .execute(command_line, Some(\u0026effective_working_dir))\n                            .await\n                        {\n                            Ok(output) =\u003e ToolResult::ExecuteCommand {\n                                stdout: output.stdout,\n                                stderr: output.stderr,\n                                error: if output.success {\n                                    None\n                                } else {\n                                    Some(\"Command failed\".to_string())\n                                },\n                            },\n                            Err(e) =\u003e ToolResult::ExecuteCommand {\n                                stdout: String::new(),\n                                stderr: String::new(),\n                                error: Some(e.to_string()),\n                            },\n                        }\n                    }\n\n                    Tool::WriteFile { path, content } =\u003e {\n                        if let Some(error) = check_absolute_path(path) {\n                            return Ok((String::new(), error));\n                        }\n                        let full_path = explorer.root_dir().join(path);\n\n                        match explorer.write_file(\u0026full_path, content) {\n                            Ok(_) =\u003e ToolResult::WriteFile {\n                                path: path.clone(),\n                                content: content.clone(),\n                                error: None,\n                            },\n                            Err(e) =\u003e ToolResult::WriteFile {\n                                path: path.clone(),\n                                content: String::new(), // Empty content on error\n                                error: Some(e.to_string()),\n                            },\n                        }\n                    }\n\n                    Tool::ReplaceInFile { path, replacements } =\u003e {\n                        if let Some(error) = check_absolute_path(path) {\n                            return Ok((String::new(), error));\n                        }\n                        let full_path = explorer.root_dir().join(path);\n\n                        match explorer.apply_replacements(\u0026full_path, replacements) {\n                            Ok(new_content) =\u003e ToolResult::ReplaceInFile {\n                                path: path.clone(),\n                                content: new_content,\n                                error: None,\n                            },\n                            Err(e) =\u003e ToolResult::ReplaceInFile {\n                                path: path.clone(),\n                                content: String::new(), // Empty content on error\n                                error: Some(e.to_string()),\n                            },\n                        }\n                    }\n\n                    Tool::DeleteFiles { paths } =\u003e {\n                        // Check for absolute paths\n                        for path in paths {\n                            if let Some(error) = check_absolute_path(path) {\n                                return Ok((String::new(), error));\n                            }\n                        }\n                        let mut deleted = Vec::new();\n                        let mut failed = Vec::new();\n\n                        for path in paths {\n                            let full_path = explorer.root_dir().join(path);\n                            match explorer.delete_file(\u0026full_path) {\n                                Ok(_) =\u003e deleted.push(path.clone()),\n                                Err(e) =\u003e failed.push((path.clone(), e.to_string())),\n                            }\n                        }\n\n                        ToolResult::DeleteFiles { deleted, failed }\n                    }\n\n                    _ =\u003e unreachable!(),\n                }\n            }\n        };\n\n        // Let the handler process the result and get formatted output\n        let output = handler.handle_result(\u0026result).await?;\n        Ok((output, result))\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":10}},{"line":13,"address":[],"length":0,"stats":{"Line":10}},{"line":14,"address":[],"length":0,"stats":{"Line":1}},{"line":15,"address":[],"length":0,"stats":{"Line":1}},{"line":18,"address":[],"length":0,"stats":{"Line":9}},{"line":23,"address":[],"length":0,"stats":{"Line":22}},{"line":30,"address":[],"length":0,"stats":{"Line":43}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":2}},{"line":57,"address":[],"length":0,"stats":{"Line":2}},{"line":59,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":8}},{"line":89,"address":[],"length":0,"stats":{"Line":8}},{"line":91,"address":[],"length":0,"stats":{"Line":8}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":22}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":4}},{"line":109,"address":[],"length":0,"stats":{"Line":12}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":4}},{"line":115,"address":[],"length":0,"stats":{"Line":4}},{"line":117,"address":[],"length":0,"stats":{"Line":12}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":3}},{"line":121,"address":[],"length":0,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":1}},{"line":124,"address":[],"length":0,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":6}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":153,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":1}},{"line":208,"address":[],"length":0,"stats":{"Line":1}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":1}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":1}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":1}},{"line":234,"address":[],"length":0,"stats":{"Line":1}},{"line":235,"address":[],"length":0,"stats":{"Line":1}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":2}},{"line":250,"address":[],"length":0,"stats":{"Line":3}},{"line":251,"address":[],"length":0,"stats":{"Line":1}},{"line":253,"address":[],"length":0,"stats":{"Line":1}},{"line":255,"address":[],"length":0,"stats":{"Line":1}},{"line":257,"address":[],"length":0,"stats":{"Line":1}},{"line":258,"address":[],"length":0,"stats":{"Line":1}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":2}},{"line":270,"address":[],"length":0,"stats":{"Line":2}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":2}},{"line":275,"address":[],"length":0,"stats":{"Line":2}},{"line":277,"address":[],"length":0,"stats":{"Line":1}},{"line":282,"address":[],"length":0,"stats":{"Line":1}},{"line":283,"address":[],"length":0,"stats":{"Line":1}},{"line":284,"address":[],"length":0,"stats":{"Line":1}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":21}},{"line":317,"address":[],"length":0,"stats":{"Line":21}}],"covered":61,"coverable":143},{"path":["/","Users","stippi","projects","code-assistant","src","tools","handlers.rs"],"content":"use crate::tools::ToolResultHandler;\nuse crate::types::{FileTreeEntry, ToolResult, WorkingMemory};\nuse crate::PathBuf;\nuse anyhow::Result;\nuse async_trait::async_trait;\n\npub struct AgentToolHandler\u003c'a\u003e {\n    working_memory: \u0026'a mut WorkingMemory,\n}\n\nimpl\u003c'a\u003e AgentToolHandler\u003c'a\u003e {\n    pub fn new(working_memory: \u0026'a mut WorkingMemory) -\u003e Self {\n        Self { working_memory }\n    }\n}\n\n#[async_trait::async_trait]\nimpl\u003c'a\u003e ToolResultHandler for AgentToolHandler\u003c'a\u003e {\n    async fn handle_result(\u0026mut self, result: \u0026ToolResult) -\u003e Result\u003cString\u003e {\n        // Update working memory if tool was successful\n        if result.is_success() {\n            match \u0026result {\n                ToolResult::ListFiles { expanded_paths, .. } =\u003e {\n                    // Update working memory file tree with each entry\n                    if let Some(file_tree) = \u0026mut self.working_memory.file_tree {\n                        for (path, entry) in expanded_paths {\n                            update_tree_entry(file_tree, path, entry.clone())?;\n                        }\n                    }\n                }\n                ToolResult::ReadFiles { loaded_files, .. } =\u003e {\n                    self.working_memory\n                        .loaded_files\n                        .extend(loaded_files.clone());\n                }\n                ToolResult::Summarize { files } =\u003e {\n                    for (path, summary) in files {\n                        self.working_memory.loaded_files.remove(path);\n                        self.working_memory\n                            .file_summaries\n                            .insert(path.clone(), summary.clone());\n                    }\n                }\n                ToolResult::ReplaceInFile { path, content, .. } =\u003e {\n                    // Update working memory if file was loaded\n                    if self.working_memory.loaded_files.contains_key(path) {\n                        self.working_memory\n                            .loaded_files\n                            .insert(path.clone(), content.clone());\n                    }\n                }\n                ToolResult::WriteFile {\n                    path,\n                    content,\n                    error: None,\n                    ..\n                } =\u003e {\n                    // Remove any existing summary since file is new/overwritten\n                    self.working_memory.file_summaries.remove(path);\n                    // Make this file part of the loaded files\n                    self.working_memory\n                        .loaded_files\n                        .insert(path.clone(), content.clone());\n                }\n                ToolResult::DeleteFiles { deleted, .. } =\u003e {\n                    for path in deleted {\n                        self.working_memory.loaded_files.remove(path);\n                        self.working_memory.file_summaries.remove(path);\n                    }\n                }\n                _ =\u003e {}\n            }\n        }\n\n        Ok(result.format_message())\n    }\n}\n\npub struct MCPToolHandler;\n\nimpl MCPToolHandler {\n    pub fn new() -\u003e Self {\n        Self\n    }\n}\n\n#[async_trait]\nimpl ToolResultHandler for MCPToolHandler {\n    async fn handle_result(\u0026mut self, result: \u0026ToolResult) -\u003e Result\u003cString\u003e {\n        match result {\n            ToolResult::ListFiles { expanded_paths, .. } =\u003e {\n                let mut output = String::new();\n                for (path, entry) in expanded_paths {\n                    output.push_str(\u0026format!(\n                        \"Contents of {}:\\n{}\\n\",\n                        path.display(),\n                        entry.to_string()\n                    ));\n                }\n                Ok(output)\n            }\n            ToolResult::ReadFiles { loaded_files, .. } =\u003e {\n                // Format detailed output with file contents\n                let mut output = String::new();\n                for (path, content) in loaded_files {\n                    output.push_str(\u0026format!(\"File: {}\\n{}\\n\", path.display(), content));\n                }\n                Ok(output)\n            }\n            // All other tools use standard message\n            _ =\u003e Ok(result.format_message()),\n        }\n    }\n}\n\npub struct ReplayToolHandler {\n    working_memory: WorkingMemory,\n}\n\nimpl ReplayToolHandler {\n    pub fn new(working_memory: WorkingMemory) -\u003e Self {\n        Self { working_memory }\n    }\n\n    pub fn into_memory(self) -\u003e WorkingMemory {\n        self.working_memory\n    }\n}\n\n#[async_trait]\nimpl ToolResultHandler for ReplayToolHandler {\n    async fn handle_result(\u0026mut self, result: \u0026ToolResult) -\u003e Result\u003cString\u003e {\n        // Only update working memory, ignore filesystem effects\n        if result.is_success() {\n            match \u0026result {\n                ToolResult::ReadFiles { loaded_files, .. } =\u003e {\n                    self.working_memory\n                        .loaded_files\n                        .extend(loaded_files.clone());\n                }\n                ToolResult::Summarize { files } =\u003e {\n                    for (path, summary) in files {\n                        self.working_memory.loaded_files.remove(path);\n                        self.working_memory\n                            .file_summaries\n                            .insert(path.clone(), summary.clone());\n                    }\n                }\n                ToolResult::ReplaceInFile {\n                    path,\n                    content,\n                    error: None,\n                    ..\n                } =\u003e {\n                    if self.working_memory.loaded_files.contains_key(path) {\n                        self.working_memory\n                            .loaded_files\n                            .insert(path.clone(), content.clone());\n                    }\n                }\n                ToolResult::WriteFile {\n                    path, error: None, ..\n                } =\u003e {\n                    // Just remove from working memory if files were loaded\n                    self.working_memory.loaded_files.remove(path);\n                    self.working_memory.file_summaries.remove(path);\n                }\n                ToolResult::ListFiles { expanded_paths, .. } =\u003e {\n                    // Update file tree with the entries\n                    if let Some(file_tree) = \u0026mut self.working_memory.file_tree {\n                        for (path, entry) in expanded_paths {\n                            update_tree_entry(file_tree, path, entry.clone())?;\n                        }\n                    }\n                }\n                _ =\u003e {}\n            }\n        }\n\n        Ok(result.format_message())\n    }\n}\n\nfn update_tree_entry(\n    tree: \u0026mut FileTreeEntry,\n    path: \u0026PathBuf,\n    new_entry: FileTreeEntry,\n) -\u003e Result\u003c()\u003e {\n    let components: Vec\u003c_\u003e = path.components().collect();\n    let mut current = tree;\n\n    for (i, component) in components.iter().enumerate() {\n        let name = component.as_os_str().to_string_lossy().to_string();\n        let is_last = i == components.len() - 1;\n\n        if is_last {\n            current.children.insert(name, new_entry.clone());\n            break;\n        }\n\n        current = current\n            .children\n            .get_mut(\u0026name)\n            .ok_or_else(|| anyhow::anyhow!(\"Path component not found: {}\", name))?;\n    }\n\n    Ok(())\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":22}},{"line":19,"address":[],"length":0,"stats":{"Line":21}},{"line":21,"address":[],"length":0,"stats":{"Line":21}},{"line":22,"address":[],"length":0,"stats":{"Line":1}},{"line":23,"address":[],"length":0,"stats":{"Line":1}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":26,"address":[],"length":0,"stats":{"Line":3}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":3}},{"line":32,"address":[],"length":0,"stats":{"Line":3}},{"line":33,"address":[],"length":0,"stats":{"Line":3}},{"line":34,"address":[],"length":0,"stats":{"Line":3}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":12}},{"line":75,"address":[],"length":0,"stats":{"Line":21}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":189,"address":[],"length":0,"stats":{"Line":1}},{"line":190,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":1}},{"line":196,"address":[],"length":0,"stats":{"Line":1}},{"line":197,"address":[],"length":0,"stats":{"Line":1}},{"line":198,"address":[],"length":0,"stats":{"Line":1}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":1}}],"covered":37,"coverable":106},{"path":["/","Users","stippi","projects","code-assistant","src","tools","mod.rs"],"content":"use crate::types::ToolResult;\nuse anyhow::Result;\n\nmod definitions;\nmod executor;\nmod handlers;\nmod parse;\nmod result;\n\npub use executor::ToolExecutor;\npub use handlers::{AgentToolHandler, MCPToolHandler, ReplayToolHandler};\npub use parse::{parse_tool_json, parse_tool_xml, TOOL_TAG_PREFIX};\n\n#[async_trait::async_trait]\npub trait ToolResultHandler: Send + Sync {\n    /// Handle a tool result, update internal state if needed, and return formatted output\n    async fn handle_result(\u0026mut self, result: \u0026ToolResult) -\u003e Result\u003cString\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","stippi","projects","code-assistant","src","tools","parse.rs"],"content":"use crate::types::FileReplacement;\nuse crate::types::Tool;\nuse anyhow::Result;\nuse std::collections::HashMap;\nuse std::path::PathBuf;\nuse tracing::trace;\n\npub const TOOL_TAG_PREFIX: \u0026str = \"tool:\";\nconst PARAM_TAG_PREFIX: \u0026str = \"param:\";\n\npub fn parse_tool_xml(xml: \u0026str) -\u003e Result\u003cTool\u003e {\n    trace!(\"Parsing XML:\\n{}\", xml);\n\n    let tool_name = xml\n        .trim()\n        .strip_prefix(\u0026format!(\"\u003c{}\", TOOL_TAG_PREFIX))\n        .and_then(|s| s.split_whitespace().next())\n        .and_then(|s| s.strip_suffix('\u003e'))\n        .ok_or_else(|| anyhow::anyhow!(\"Missing tool name\"))?\n        .to_string();\n\n    trace!(\"Found tool name: {}\", tool_name);\n\n    let mut params: HashMap\u003cString, Vec\u003cString\u003e\u003e = HashMap::new();\n    let mut current_param = String::new();\n    let mut content_start = 0;\n\n    let mut chars = xml.char_indices().peekable();\n    while let Some((i, ch)) = chars.next() {\n        if ch == '\u003c' {\n            // Check for parameter tag\n            let rest = \u0026xml[i..];\n            trace!(\"Found '\u003c', rest of string: {}\", rest);\n            if rest.starts_with(\u0026format!(\"\u003c/{}\", PARAM_TAG_PREFIX)) {\n                // Closing tag\n                let param_name = rest[format!(\"\u003c/{}\", PARAM_TAG_PREFIX).len()..] // skip the \"\u003c/param:\"\n                    .split('\u003e')\n                    .next()\n                    .ok_or_else(|| anyhow::anyhow!(\"Invalid closing tag format\"))?;\n                trace!(\"Found closing tag for: {}\", param_name);\n                if param_name == current_param {\n                    let content = \u0026xml[content_start..i];\n                    trace!(\"Found content for {}: {}\", current_param, content);\n                    params\n                        .entry(current_param.clone())\n                        .or_default()\n                        .push(content.to_string());\n                    current_param.clear();\n                }\n            } else if let Some(param_start) = rest.strip_prefix(\u0026format!(\"\u003c{}\", PARAM_TAG_PREFIX)) {\n                // Opening tag\n                if let Some(param_name) = param_start.split('\u003e').next() {\n                    current_param = param_name.to_string();\n                    content_start = i + format!(\"\u003c{}{}\u003e\", PARAM_TAG_PREFIX, param_name).len();\n                    trace!(\"Found param start: {} at {}\", current_param, content_start);\n                }\n            }\n        }\n    }\n\n    trace!(\"Final parameters: {:?}\", params);\n    parse_tool_from_params(\u0026tool_name, \u0026params)\n}\n\nfn parse_search_replace_blocks(content: \u0026str) -\u003e Result\u003cVec\u003cFileReplacement\u003e\u003e {\n    let mut replacements = Vec::new();\n    let mut lines = content.lines().peekable();\n\n    while let Some(line) = lines.next() {\n        if line.trim() == \"\u003c\u003c\u003c\u003c\u003c\u003c\u003c SEARCH\" {\n            let mut search = String::new();\n            let mut replace = String::new();\n\n            // Collect search content\n            while let Some(line) = lines.next() {\n                if line.trim() == \"=======\" {\n                    break;\n                }\n                if !search.is_empty() {\n                    search.push('\\n');\n                }\n                search.push_str(line);\n            }\n\n            // Collect replace content\n            while let Some(line) = lines.next() {\n                if line.trim() == \"\u003e\u003e\u003e\u003e\u003e\u003e\u003e REPLACE\" {\n                    break;\n                }\n                if !replace.is_empty() {\n                    replace.push('\\n');\n                }\n                replace.push_str(line);\n            }\n\n            replacements.push(FileReplacement { search, replace });\n        }\n    }\n\n    Ok(replacements)\n}\n\npub fn parse_tool_from_params(\n    tool_name: \u0026str,\n    params: \u0026HashMap\u003cString, Vec\u003cString\u003e\u003e,\n) -\u003e Result\u003cTool\u003e {\n    match tool_name {\n        \"search_files\" =\u003e Ok(Tool::SearchFiles {\n            query: params\n                .get(\"query\")\n                .ok_or_else(|| anyhow::anyhow!(\"Missing query\"))?\n                .first()\n                .ok_or_else(|| anyhow::anyhow!(\"Query parameter is empty\"))?\n                .to_string(),\n            path: params\n                .get(\"path\")\n                .and_then(|v| v.first())\n                .map(PathBuf::from),\n            case_sensitive: params\n                .get(\"case_sensitive\")\n                .map_or(false, |v| v.first().map_or(false, |s| s == \"true\")),\n            whole_words: params\n                .get(\"whole_words\")\n                .map_or(false, |v| v.first().map_or(false, |s| s == \"true\")),\n            regex_mode: params\n                .get(\"regex_mode\")\n                .map_or(false, |v| v.first().map_or(false, |s| s == \"true\")),\n            max_results: params\n                .get(\"max_results\")\n                .and_then(|v| v.first())\n                .map(|v| v.trim().parse::\u003cusize\u003e())\n                .transpose()?,\n        }),\n\n        \"list_files\" =\u003e Ok(Tool::ListFiles {\n            paths: params\n                .get(\"path\")\n                .ok_or_else(|| anyhow::anyhow!(\"Missing path parameter\"))?\n                .iter()\n                .map(|s| PathBuf::from(s.trim()))\n                .collect(),\n            max_depth: params\n                .get(\"max_depth\")\n                .and_then(|v| v.first())\n                .map(|v| v.trim().parse::\u003cusize\u003e())\n                .transpose()?,\n        }),\n\n        \"read_files\" =\u003e Ok(Tool::ReadFiles {\n            paths: params\n                .get(\"path\")\n                .ok_or_else(|| anyhow::anyhow!(\"Missing path parameter\"))?\n                .iter()\n                .map(|s| PathBuf::from(s.trim()))\n                .collect(),\n        }),\n\n        \"summarize\" =\u003e Ok(Tool::Summarize {\n            files: params\n                .get(\"file\")\n                .ok_or_else(|| anyhow::anyhow!(\"Missing file parameter\"))?\n                .iter()\n                .filter_map(|line| {\n                    let mut parts = line.splitn(2, ':');\n                    Some((\n                        PathBuf::from(parts.next()?.trim()),\n                        parts.next()?.trim().to_string(),\n                    ))\n                })\n                .collect(),\n        }),\n\n        \"replace_in_file\" =\u003e Ok(Tool::ReplaceInFile {\n            path: PathBuf::from(\n                params\n                    .get(\"path\")\n                    .and_then(|v| v.first())\n                    .ok_or_else(|| anyhow::anyhow!(\"Missing path parameter\"))?,\n            ),\n            replacements: parse_search_replace_blocks(\n                params\n                    .get(\"diff\")\n                    .and_then(|v| v.first())\n                    .ok_or_else(|| anyhow::anyhow!(\"Missing diff parameter\"))?,\n            )?,\n        }),\n\n        \"write_file\" =\u003e Ok(Tool::WriteFile {\n            path: PathBuf::from(\n                params\n                    .get(\"path\")\n                    .and_then(|v| v.first())\n                    .ok_or_else(|| anyhow::anyhow!(\"Missing path parameter\"))?,\n            ),\n            content: params\n                .get(\"content\")\n                .and_then(|v| v.first())\n                .ok_or_else(|| anyhow::anyhow!(\"Missing content parameter\"))?\n                .to_string(),\n        }),\n\n        \"delete_files\" =\u003e Ok(Tool::DeleteFiles {\n            paths: params\n                .get(\"path\")\n                .ok_or_else(|| anyhow::anyhow!(\"Missing path parameter\"))?\n                .iter()\n                .map(|s| PathBuf::from(s.trim()))\n                .collect(),\n        }),\n\n        \"ask_user\" =\u003e Ok(Tool::AskUser {\n            question: params\n                .get(\"question\")\n                .ok_or_else(|| anyhow::anyhow!(\"Missing question parameter\"))?\n                .first()\n                .ok_or_else(|| anyhow::anyhow!(\"Question parameter is empty\"))?\n                .to_string(),\n        }),\n\n        \"message_user\" =\u003e Ok(Tool::MessageUser {\n            message: params\n                .get(\"message\")\n                .ok_or_else(|| anyhow::anyhow!(\"Missing message parameter\"))?\n                .first()\n                .ok_or_else(|| anyhow::anyhow!(\"Message parameter is empty\"))?\n                .to_string(),\n        }),\n\n        \"complete_task\" =\u003e Ok(Tool::CompleteTask {\n            message: params\n                .get(\"message\")\n                .ok_or_else(|| anyhow::anyhow!(\"Missing message parameter\"))?\n                .first()\n                .ok_or_else(|| anyhow::anyhow!(\"Message parameter is empty\"))?\n                .to_string(),\n        }),\n\n        \"execute_command\" =\u003e Ok(Tool::ExecuteCommand {\n            command_line: params\n                .get(\"command_line\")\n                .ok_or_else(|| anyhow::anyhow!(\"Missing command_line parameter\"))?\n                .first()\n                .ok_or_else(|| anyhow::anyhow!(\"Command line parameter is empty\"))?\n                .to_string(),\n            working_dir: params\n                .get(\"working_dir\")\n                .and_then(|v| v.first())\n                .map(|v| PathBuf::from(v)),\n        }),\n\n        _ =\u003e Err(anyhow::anyhow!(\"Unknown tool: {}\", tool_name)),\n    }\n}\n\npub fn parse_tool_json(name: \u0026str, params: \u0026serde_json::Value) -\u003e Result\u003cTool\u003e {\n    match name {\n        \"list_projects\" =\u003e Ok(Tool::ListProjects),\n        \"open_project\" =\u003e Ok(Tool::OpenProject {\n            name: params[\"name\"]\n                .as_str()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing project name\"))?\n                .to_string(),\n        }),\n        \"execute_command\" =\u003e Ok(Tool::ExecuteCommand {\n            command_line: params[\"command_line\"]\n                .as_str()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing command_line\"))?\n                .to_string(),\n            working_dir: params\n                .get(\"working_dir\")\n                .and_then(|d| d.as_str())\n                .map(PathBuf::from),\n        }),\n        \"search_files\" =\u003e Ok(Tool::SearchFiles {\n            query: params[\"query\"]\n                .as_str()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing query\"))?\n                .to_string(),\n            path: params\n                .get(\"path\")\n                .and_then(|p| p.as_str())\n                .map(PathBuf::from),\n            case_sensitive: params\n                .get(\"case_sensitive\")\n                .and_then(|b| b.as_bool())\n                .unwrap_or(false),\n            whole_words: params\n                .get(\"whole_words\")\n                .and_then(|b| b.as_bool())\n                .unwrap_or(false),\n            regex_mode: params\n                .get(\"mode\")\n                .and_then(|m| m.as_str())\n                .map_or(false, |m| m == \"regex\"),\n            max_results: params\n                .get(\"max_results\")\n                .and_then(|n| n.as_u64())\n                .map(|n| n as usize),\n        }),\n        \"list_files\" =\u003e Ok(Tool::ListFiles {\n            paths: params[\"paths\"]\n                .as_array()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing or invalid paths array\"))?\n                .iter()\n                .map(|p| {\n                    Ok(PathBuf::from(\n                        p.as_str()\n                            .ok_or_else(|| anyhow::anyhow!(\"Invalid path in array\"))?,\n                    ))\n                })\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?,\n            max_depth: params[\"max_depth\"].as_u64().map(|d| d as usize),\n        }),\n        \"read_files\" =\u003e Ok(Tool::ReadFiles {\n            paths: params[\"paths\"]\n                .as_array()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing or invalid paths array\"))?\n                .iter()\n                .map(|p| {\n                    Ok(PathBuf::from(\n                        p.as_str()\n                            .ok_or_else(|| anyhow::anyhow!(\"Invalid path in array\"))?,\n                    ))\n                })\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?,\n        }),\n        \"summarize\" =\u003e Ok(Tool::Summarize {\n            files: params[\"files\"]\n                .as_array()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing or invalid files array\"))?\n                .iter()\n                .map(|f| {\n                    Ok((\n                        PathBuf::from(\n                            f[\"path\"]\n                                .as_str()\n                                .ok_or_else(|| anyhow::anyhow!(\"Missing path in file entry\"))?,\n                        ),\n                        f[\"summary\"]\n                            .as_str()\n                            .ok_or_else(|| anyhow::anyhow!(\"Missing summary in file entry\"))?\n                            .to_string(),\n                    ))\n                })\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?,\n        }),\n        \"replace_in_file\" =\u003e Ok(Tool::ReplaceInFile {\n            path: PathBuf::from(\n                params[\"path\"]\n                    .as_str()\n                    .ok_or_else(|| anyhow::anyhow!(\"Missing path parameter\"))?,\n            ),\n            replacements: params[\"replacements\"]\n                .as_array()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing replacements array\"))?\n                .iter()\n                .map(|r| {\n                    Ok(FileReplacement {\n                        search: r[\"search\"]\n                            .as_str()\n                            .ok_or_else(|| anyhow::anyhow!(\"Missing search content\"))?\n                            .to_string(),\n                        replace: r[\"replace\"]\n                            .as_str()\n                            .ok_or_else(|| anyhow::anyhow!(\"Missing replace content\"))?\n                            .to_string(),\n                    })\n                })\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?,\n        }),\n        \"write_file\" =\u003e Ok(Tool::WriteFile {\n            path: PathBuf::from(\n                params[\"path\"]\n                    .as_str()\n                    .ok_or_else(|| anyhow::anyhow!(\"Missing path parameter\"))?,\n            ),\n            content: params[\"content\"]\n                .as_str()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing content parameter\"))?\n                .to_string(),\n        }),\n        \"delete_files\" =\u003e Ok(Tool::DeleteFiles {\n            paths: params[\"paths\"]\n                .as_array()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing or invalid paths array\"))?\n                .iter()\n                .map(|p| {\n                    Ok(PathBuf::from(\n                        p.as_str()\n                            .ok_or_else(|| anyhow::anyhow!(\"Invalid path in array\"))?,\n                    ))\n                })\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?,\n        }),\n        \"ask_user\" =\u003e Ok(Tool::AskUser {\n            question: params[\"question\"]\n                .as_str()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing question parameter\"))?\n                .to_string(),\n        }),\n        \"message_user\" =\u003e Ok(Tool::MessageUser {\n            message: params[\"message\"]\n                .as_str()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing message parameter\"))?\n                .to_string(),\n        }),\n        \"complete_task\" =\u003e Ok(Tool::CompleteTask {\n            message: params[\"message\"]\n                .as_str()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing message parameter\"))?\n                .to_string(),\n        }),\n        _ =\u003e Err(anyhow::anyhow!(\"Unknown tool: {}\", name)),\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":2}},{"line":12,"address":[],"length":0,"stats":{"Line":2}},{"line":14,"address":[],"length":0,"stats":{"Line":4}},{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":4}},{"line":18,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":2}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":26,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":2}},{"line":29,"address":[],"length":0,"stats":{"Line":1038}},{"line":32,"address":[],"length":0,"stats":{"Line":31}},{"line":33,"address":[],"length":0,"stats":{"Line":31}},{"line":34,"address":[],"length":0,"stats":{"Line":31}},{"line":36,"address":[],"length":0,"stats":{"Line":12}},{"line":39,"address":[],"length":0,"stats":{"Line":12}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":6}},{"line":42,"address":[],"length":0,"stats":{"Line":6}},{"line":43,"address":[],"length":0,"stats":{"Line":6}},{"line":44,"address":[],"length":0,"stats":{"Line":6}},{"line":45,"address":[],"length":0,"stats":{"Line":6}},{"line":47,"address":[],"length":0,"stats":{"Line":6}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":50,"address":[],"length":0,"stats":{"Line":31}},{"line":52,"address":[],"length":0,"stats":{"Line":6}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":67,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":9}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":12}},{"line":77,"address":[],"length":0,"stats":{"Line":2}},{"line":79,"address":[],"length":0,"stats":{"Line":6}},{"line":80,"address":[],"length":0,"stats":{"Line":2}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":86,"address":[],"length":0,"stats":{"Line":12}},{"line":88,"address":[],"length":0,"stats":{"Line":2}},{"line":90,"address":[],"length":0,"stats":{"Line":6}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":2}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":2}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":1}},{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":121,"address":[],"length":0,"stats":{"Line":3}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":1}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":1}},{"line":176,"address":[],"length":0,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":3}},{"line":178,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":2}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":22}},{"line":256,"address":[],"length":0,"stats":{"Line":22}},{"line":257,"address":[],"length":0,"stats":{"Line":22}},{"line":258,"address":[],"length":0,"stats":{"Line":22}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":22}},{"line":265,"address":[],"length":0,"stats":{"Line":1}},{"line":266,"address":[],"length":0,"stats":{"Line":1}},{"line":267,"address":[],"length":0,"stats":{"Line":2}},{"line":268,"address":[],"length":0,"stats":{"Line":1}},{"line":269,"address":[],"length":0,"stats":{"Line":1}},{"line":270,"address":[],"length":0,"stats":{"Line":1}},{"line":271,"address":[],"length":0,"stats":{"Line":3}},{"line":272,"address":[],"length":0,"stats":{"Line":1}},{"line":274,"address":[],"length":0,"stats":{"Line":21}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":21}},{"line":301,"address":[],"length":0,"stats":{"Line":2}},{"line":302,"address":[],"length":0,"stats":{"Line":2}},{"line":303,"address":[],"length":0,"stats":{"Line":4}},{"line":304,"address":[],"length":0,"stats":{"Line":2}},{"line":305,"address":[],"length":0,"stats":{"Line":4}},{"line":306,"address":[],"length":0,"stats":{"Line":2}},{"line":307,"address":[],"length":0,"stats":{"Line":2}},{"line":308,"address":[],"length":0,"stats":{"Line":4}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":4}},{"line":314,"address":[],"length":0,"stats":{"Line":19}},{"line":315,"address":[],"length":0,"stats":{"Line":4}},{"line":316,"address":[],"length":0,"stats":{"Line":4}},{"line":317,"address":[],"length":0,"stats":{"Line":8}},{"line":318,"address":[],"length":0,"stats":{"Line":4}},{"line":319,"address":[],"length":0,"stats":{"Line":8}},{"line":320,"address":[],"length":0,"stats":{"Line":4}},{"line":321,"address":[],"length":0,"stats":{"Line":4}},{"line":322,"address":[],"length":0,"stats":{"Line":8}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":15}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":15}},{"line":349,"address":[],"length":0,"stats":{"Line":2}},{"line":350,"address":[],"length":0,"stats":{"Line":2}},{"line":351,"address":[],"length":0,"stats":{"Line":4}},{"line":353,"address":[],"length":0,"stats":{"Line":2}},{"line":354,"address":[],"length":0,"stats":{"Line":2}},{"line":355,"address":[],"length":0,"stats":{"Line":2}},{"line":356,"address":[],"length":0,"stats":{"Line":2}},{"line":357,"address":[],"length":0,"stats":{"Line":4}},{"line":358,"address":[],"length":0,"stats":{"Line":2}},{"line":359,"address":[],"length":0,"stats":{"Line":2}},{"line":360,"address":[],"length":0,"stats":{"Line":2}},{"line":361,"address":[],"length":0,"stats":{"Line":4}},{"line":362,"address":[],"length":0,"stats":{"Line":2}},{"line":363,"address":[],"length":0,"stats":{"Line":2}},{"line":364,"address":[],"length":0,"stats":{"Line":2}},{"line":365,"address":[],"length":0,"stats":{"Line":2}},{"line":366,"address":[],"length":0,"stats":{"Line":2}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":13}},{"line":373,"address":[],"length":0,"stats":{"Line":2}},{"line":374,"address":[],"length":0,"stats":{"Line":2}},{"line":375,"address":[],"length":0,"stats":{"Line":4}},{"line":377,"address":[],"length":0,"stats":{"Line":2}},{"line":378,"address":[],"length":0,"stats":{"Line":2}},{"line":379,"address":[],"length":0,"stats":{"Line":2}},{"line":380,"address":[],"length":0,"stats":{"Line":2}},{"line":382,"address":[],"length":0,"stats":{"Line":11}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":11}},{"line":396,"address":[],"length":0,"stats":{"Line":1}},{"line":397,"address":[],"length":0,"stats":{"Line":1}},{"line":398,"address":[],"length":0,"stats":{"Line":2}},{"line":399,"address":[],"length":0,"stats":{"Line":1}},{"line":401,"address":[],"length":0,"stats":{"Line":10}},{"line":402,"address":[],"length":0,"stats":{"Line":2}},{"line":403,"address":[],"length":0,"stats":{"Line":2}},{"line":404,"address":[],"length":0,"stats":{"Line":4}},{"line":405,"address":[],"length":0,"stats":{"Line":2}},{"line":407,"address":[],"length":0,"stats":{"Line":8}},{"line":408,"address":[],"length":0,"stats":{"Line":8}},{"line":409,"address":[],"length":0,"stats":{"Line":8}},{"line":410,"address":[],"length":0,"stats":{"Line":8}},{"line":411,"address":[],"length":0,"stats":{"Line":8}},{"line":413,"address":[],"length":0,"stats":{"Line":0}}],"covered":147,"coverable":285},{"path":["/","Users","stippi","projects","code-assistant","src","tools","result.rs"],"content":"use crate::types::ToolResult;\n\nimpl ToolResult {\n    // Format a user-facing message describing the result\n    pub fn format_message(\u0026self) -\u003e String {\n        match self {\n            ToolResult::ListProjects { projects } =\u003e {\n                if projects.is_empty() {\n                    \"No projects configured.\".to_string()\n                } else {\n                    let mut msg = String::from(\"Available projects:\\n\");\n                    for (name, project) in projects {\n                        msg.push_str(\u0026format!(\"- {}: {}\\n\", name, project.path.display()));\n                    }\n                    msg\n                }\n            }\n            ToolResult::OpenProject { name, error, .. } =\u003e {\n                if error.is_none() {\n                    format!(\"Successfully opened project '{}'\", name)\n                } else {\n                    format!(\n                        \"Failed to open project '{}': {}\",\n                        name,\n                        error.as_ref().unwrap_or(\u0026\"unknown error\".to_string())\n                    )\n                }\n            }\n            ToolResult::AbsolutePathError { path } =\u003e {\n                format!(\"Path must be relative to project root: {}\", path.display())\n            }\n            ToolResult::ReadFiles {\n                loaded_files,\n                failed_files,\n            } =\u003e {\n                let mut msg = String::new();\n                if !loaded_files.is_empty() {\n                    msg.push_str(\u0026format!(\n                        \"Successfully loaded files: {}\",\n                        loaded_files\n                            .keys()\n                            .map(|p| p.display().to_string())\n                            .collect::\u003cVec\u003c_\u003e\u003e()\n                            .join(\", \")\n                    ));\n                }\n                if !failed_files.is_empty() {\n                    if !msg.is_empty() {\n                        msg.push_str(\"\\n\");\n                    }\n                    msg.push_str(\"Failed to load: \");\n                    msg.push_str(\n                        \u0026failed_files\n                            .iter()\n                            .map(|(p, e)| format!(\"{}: {}\", p.display(), e))\n                            .collect::\u003cVec\u003c_\u003e\u003e()\n                            .join(\", \"),\n                    );\n                }\n                msg\n            }\n            ToolResult::ListFiles {\n                expanded_paths,\n                failed_paths,\n                ..\n            } =\u003e {\n                let mut msg = String::new();\n                if !expanded_paths.is_empty() {\n                    msg.push_str(\u0026format!(\"Successfully listed contents of: \"));\n                    msg.push_str(\n                        \u0026expanded_paths\n                            .iter()\n                            .map(|(path, _)| format!(\"{}\", path.display()))\n                            .collect::\u003cVec\u003c_\u003e\u003e()\n                            .join(\"; \"),\n                    );\n                }\n                if !failed_paths.is_empty() {\n                    if !msg.is_empty() {\n                        msg.push_str(\"\\n\");\n                    }\n                    msg.push_str(\"Failed listing: \");\n                    msg.push_str(\n                        \u0026failed_paths\n                            .iter()\n                            .map(|(path, err)| format!(\"{}: {}\", path, err))\n                            .collect::\u003cVec\u003c_\u003e\u003e()\n                            .join(\"; \"),\n                    );\n                }\n                msg\n            }\n            ToolResult::SearchFiles { results, query } =\u003e {\n                if results.is_empty() {\n                    format!(\"No matches found for '{}'\", query)\n                } else {\n                    let mut msg = format!(\"Found matches for '{}':\\n\", query);\n                    for result in results {\n                        msg.push_str(\u0026format!(\n                            \"{}:{}-{}:\\n\",\n                            result.file.display(),\n                            result.start_line + 1,\n                            result.start_line + result.line_content.len()\n                        ));\n                        for (i, line) in result.line_content.iter().enumerate() {\n                            let line_prefix = if result.match_lines.contains(\u0026i) {\n                                \"\u003e\"\n                            } else {\n                                \" \"\n                            };\n                            msg.push_str(\u0026format!(\"{} {}\\n\", line_prefix, line));\n                        }\n                        msg.push('\\n');\n                    }\n                    msg\n                }\n            }\n            ToolResult::ExecuteCommand {\n                stdout,\n                stderr,\n                error,\n            } =\u003e {\n                let mut msg = String::new();\n                if !stdout.is_empty() {\n                    msg.push_str(\"Output:\\n\");\n                    msg.push_str(stdout);\n                }\n                if !stderr.is_empty() {\n                    if !msg.is_empty() {\n                        msg.push_str(\"\\n\");\n                    }\n                    msg.push_str(\"Errors:\\n\");\n                    msg.push_str(stderr);\n                }\n                if error.is_some() {\n                    if !msg.is_empty() {\n                        msg.push_str(\"\\n\");\n                    }\n                    msg.push_str(\u0026format!(\"Command failed: {}\", error.as_ref().unwrap()));\n                }\n                msg\n            }\n            ToolResult::WriteFile { path, error, .. } =\u003e {\n                if error.is_some() {\n                    format!(\n                        \"Failed to write file {}: {}\",\n                        path.display(),\n                        error.as_ref().unwrap()\n                    )\n                } else {\n                    format!(\"Successfully wrote file: {}\", path.display())\n                }\n            }\n            ToolResult::ReplaceInFile { path, error, .. } =\u003e {\n                if error.is_some() {\n                    format!(\n                        \"Failed to replace in file {}: {}\",\n                        path.display(),\n                        error.as_ref().unwrap()\n                    )\n                } else {\n                    format!(\"Successfully replaced in file: {}\", path.display())\n                }\n            }\n            ToolResult::DeleteFiles { deleted, failed } =\u003e {\n                let mut msg = String::new();\n                if !deleted.is_empty() {\n                    msg.push_str(\u0026format!(\n                        \"Successfully deleted: {}\",\n                        deleted\n                            .iter()\n                            .map(|p| p.display().to_string())\n                            .collect::\u003cVec\u003c_\u003e\u003e()\n                            .join(\", \")\n                    ));\n                }\n                if !failed.is_empty() {\n                    if !msg.is_empty() {\n                        msg.push_str(\"\\n\");\n                    }\n                    msg.push_str(\"Failed to delete: \");\n                    msg.push_str(\n                        \u0026failed\n                            .iter()\n                            .map(|(p, e)| format!(\"{}: {}\", p.display(), e))\n                            .collect::\u003cVec\u003c_\u003e\u003e()\n                            .join(\", \"),\n                    );\n                }\n                msg\n            }\n            ToolResult::Summarize { files } =\u003e {\n                format!(\"Created summaries for {} files\", files.len())\n            }\n            ToolResult::AskUser { response } =\u003e response.clone(),\n            ToolResult::MessageUser { result } =\u003e result.clone(),\n            ToolResult::CompleteTask { result } =\u003e result.clone(),\n        }\n    }\n\n    pub fn is_success(\u0026self) -\u003e bool {\n        match self {\n            ToolResult::ListProjects { .. } =\u003e true,\n            ToolResult::OpenProject { error, .. } =\u003e error.is_none(),\n            ToolResult::AbsolutePathError { .. } =\u003e false,\n            ToolResult::ReadFiles {\n                loaded_files,\n                failed_files,\n            } =\u003e !loaded_files.is_empty() \u0026\u0026 failed_files.is_empty(),\n            ToolResult::ListFiles {\n                expanded_paths,\n                failed_paths,\n                ..\n            } =\u003e !expanded_paths.is_empty() \u0026\u0026 failed_paths.is_empty(),\n            ToolResult::SearchFiles { .. } =\u003e true,\n            ToolResult::ExecuteCommand { error, .. } =\u003e error.is_none(),\n            ToolResult::WriteFile { error, .. } =\u003e error.is_none(),\n            ToolResult::ReplaceInFile { error, .. } =\u003e error.is_none(),\n            ToolResult::DeleteFiles {\n                deleted, failed, ..\n            } =\u003e !deleted.is_empty() \u0026\u0026 failed.is_empty(),\n            ToolResult::Summarize { .. } =\u003e true,\n            ToolResult::AskUser { .. } =\u003e true,\n            ToolResult::MessageUser { .. } =\u003e true,\n            ToolResult::CompleteTask { .. } =\u003e true,\n        }\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":37}},{"line":6,"address":[],"length":0,"stats":{"Line":37}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":1}},{"line":30,"address":[],"length":0,"stats":{"Line":1}},{"line":33,"address":[],"length":0,"stats":{"Line":10}},{"line":34,"address":[],"length":0,"stats":{"Line":10}},{"line":35,"address":[],"length":0,"stats":{"Line":10}},{"line":36,"address":[],"length":0,"stats":{"Line":10}},{"line":37,"address":[],"length":0,"stats":{"Line":18}},{"line":38,"address":[],"length":0,"stats":{"Line":8}},{"line":39,"address":[],"length":0,"stats":{"Line":8}},{"line":40,"address":[],"length":0,"stats":{"Line":8}},{"line":41,"address":[],"length":0,"stats":{"Line":8}},{"line":42,"address":[],"length":0,"stats":{"Line":16}},{"line":47,"address":[],"length":0,"stats":{"Line":10}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":52,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[],"length":0,"stats":{"Line":4}},{"line":60,"address":[],"length":0,"stats":{"Line":10}},{"line":63,"address":[],"length":0,"stats":{"Line":4}},{"line":64,"address":[],"length":0,"stats":{"Line":4}},{"line":65,"address":[],"length":0,"stats":{"Line":4}},{"line":66,"address":[],"length":0,"stats":{"Line":4}},{"line":67,"address":[],"length":0,"stats":{"Line":4}},{"line":68,"address":[],"length":0,"stats":{"Line":6}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":4}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":2}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":2}},{"line":83,"address":[],"length":0,"stats":{"Line":2}},{"line":84,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":4}},{"line":91,"address":[],"length":0,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":120,"address":[],"length":0,"stats":{"Line":2}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":122,"address":[],"length":0,"stats":{"Line":2}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":124,"address":[],"length":0,"stats":{"Line":4}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":128,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":2}},{"line":154,"address":[],"length":0,"stats":{"Line":4}},{"line":155,"address":[],"length":0,"stats":{"Line":4}},{"line":156,"address":[],"length":0,"stats":{"Line":2}},{"line":158,"address":[],"length":0,"stats":{"Line":2}},{"line":159,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":2}},{"line":196,"address":[],"length":0,"stats":{"Line":4}},{"line":197,"address":[],"length":0,"stats":{"Line":8}},{"line":201,"address":[],"length":0,"stats":{"Line":43}},{"line":202,"address":[],"length":0,"stats":{"Line":43}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":1}},{"line":207,"address":[],"length":0,"stats":{"Line":8}},{"line":208,"address":[],"length":0,"stats":{"Line":8}},{"line":209,"address":[],"length":0,"stats":{"Line":14}},{"line":211,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":213,"address":[],"length":0,"stats":{"Line":4}},{"line":214,"address":[],"length":0,"stats":{"Line":6}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":2}},{"line":217,"address":[],"length":0,"stats":{"Line":2}},{"line":218,"address":[],"length":0,"stats":{"Line":4}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":2}},{"line":224,"address":[],"length":0,"stats":{"Line":4}},{"line":225,"address":[],"length":0,"stats":{"Line":16}}],"covered":80,"coverable":140},{"path":["/","Users","stippi","projects","code-assistant","src","types.rs"],"content":"use anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Project {\n    pub path: PathBuf,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct FileTreeEntry {\n    pub name: String,\n    pub entry_type: FileSystemEntryType,\n    pub children: HashMap\u003cString, FileTreeEntry\u003e,\n    pub is_expanded: bool,\n}\n\n/// Represents the agent's working memory during execution\n#[derive(Debug, Serialize, Deserialize, Default, Clone)]\npub struct WorkingMemory {\n    /// Currently loaded file contents\n    pub loaded_files: HashMap\u003cPathBuf, String\u003e,\n    /// Summaries of previously seen files\n    pub file_summaries: HashMap\u003cPathBuf, String\u003e,\n    /// Complete file tree of the repository\n    pub file_tree: Option\u003cFileTreeEntry\u003e,\n    /// Current task description\n    pub current_task: String,\n    /// Memory of previous actions and their results\n    pub action_history: Vec\u003cActionResult\u003e,\n    /// Additional context or notes the agent has generated\n    pub notes: Vec\u003cString\u003e,\n}\n\n/// Details for a text replacement operation\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct FileReplacement {\n    /// The text to search for. Must match exactly one location in the file.\n    pub search: String,\n    /// The text to replace it with\n    pub replace: String,\n}\n\n/// Available tools the agent can use\n#[derive(Debug, Serialize, Deserialize, Clone)]\n#[serde(tag = \"tool\", content = \"params\")]\npub enum Tool {\n    /// List available projects\n    ListProjects,\n    /// Open a project by name\n    OpenProject { name: String },\n    /// Delete one or more files\n    DeleteFiles { paths: Vec\u003cPathBuf\u003e },\n    /// List contents of directories\n    ListFiles {\n        paths: Vec\u003cPathBuf\u003e,\n        // Optional depth limit, None means unlimited\n        max_depth: Option\u003cusize\u003e,\n    },\n    /// Read content of one or multiple files into working memory\n    ReadFiles { paths: Vec\u003cPathBuf\u003e },\n    /// Write content to a file\n    WriteFile { path: PathBuf, content: String },\n    /// Replace parts within a file. Each search text must match exactly once.\n    /// Returns an error if any search text matches zero or multiple times.\n    ReplaceInFile {\n        path: PathBuf,\n        replacements: Vec\u003cFileReplacement\u003e,\n    },\n    /// Replace file content with summaries in working memory\n    Summarize { files: Vec\u003c(PathBuf, String)\u003e },\n    /// Ask user a question and wait for response\n    AskUser { question: String },\n    /// Message the user\n    MessageUser { message: String },\n    /// Complete the current task\n    CompleteTask { message: String },\n    /// Execute a CLI command\n    ExecuteCommand {\n        /// The complete command line to execute\n        command_line: String,\n        /// Optional working directory for the command\n        working_dir: Option\u003cPathBuf\u003e,\n    },\n    /// Search for text in files\n    SearchFiles {\n        /// The text to search for\n        query: String,\n        /// Optional directory path to search in\n        path: Option\u003cPathBuf\u003e,\n        /// Whether the search should be case-sensitive\n        case_sensitive: bool,\n        /// Whether to match whole words only\n        whole_words: bool,\n        /// Whether to use regex mode\n        regex_mode: bool,\n        /// Maximum number of results to return\n        max_results: Option\u003cusize\u003e,\n    },\n}\n\n/// Specific results for each tool type\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub enum ToolResult {\n    ListProjects {\n        projects: HashMap\u003cString, Project\u003e,\n    },\n    OpenProject {\n        name: String,\n        path: Option\u003cPathBuf\u003e,\n        error: Option\u003cString\u003e,\n    },\n    AbsolutePathError {\n        path: PathBuf,\n    },\n    ReadFiles {\n        loaded_files: HashMap\u003cPathBuf, String\u003e,\n        failed_files: Vec\u003c(PathBuf, String)\u003e,\n    },\n    ListFiles {\n        expanded_paths: Vec\u003c(PathBuf, FileTreeEntry)\u003e,\n        failed_paths: Vec\u003c(String, String)\u003e,\n    },\n    SearchFiles {\n        results: Vec\u003cSearchResult\u003e,\n        query: String,\n    },\n    ExecuteCommand {\n        stdout: String,\n        stderr: String,\n        error: Option\u003cString\u003e,\n    },\n    WriteFile {\n        path: PathBuf,\n        content: String,\n        error: Option\u003cString\u003e,\n    },\n    ReplaceInFile {\n        path: PathBuf,\n        content: String,\n        error: Option\u003cString\u003e,\n    },\n    DeleteFiles {\n        deleted: Vec\u003cPathBuf\u003e,\n        failed: Vec\u003c(PathBuf, String)\u003e,\n    },\n    Summarize {\n        files: Vec\u003c(PathBuf, String)\u003e,\n    },\n    AskUser {\n        response: String,\n    },\n    MessageUser {\n        result: String,\n    },\n    CompleteTask {\n        result: String,\n    },\n}\n\n/// Collection of all available tool definitions\n#[derive(Debug, Clone)]\npub struct Tools;\n\n/// Tool description for LLM\n#[derive(Debug, Clone, Serialize)]\npub struct ToolDefinition {\n    pub name: String,\n    pub description: String,\n    pub parameters: serde_json::Value,\n}\n\n/// Represents the parsed response from the LLM\n#[derive(Debug, Deserialize)]\npub struct AgentAction {\n    pub tool: Tool,\n    pub reasoning: String,\n}\n\n/// Result of a tool execution\n#[derive(Clone, Debug, Deserialize, Serialize)]\npub struct ActionResult {\n    pub tool: Tool,\n    pub result: ToolResult,\n    pub reasoning: String,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct FileSystemEntry {\n    pub path: PathBuf,\n    pub name: String,\n    pub entry_type: FileSystemEntryType,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\npub enum FileSystemEntryType {\n    File,\n    Directory,\n}\n\n#[derive(Debug, Clone)]\npub enum SearchMode {\n    /// Standard text search, case-insensitive by default\n    Exact,\n    /// Regular expression search\n    Regex,\n}\n\nimpl Default for SearchMode {\n    fn default() -\u003e Self {\n        Self::Exact\n    }\n}\n\n#[derive(Debug, Clone, Default)]\npub struct SearchOptions {\n    pub query: String,\n    pub case_sensitive: bool,\n    pub whole_words: bool,\n    pub mode: SearchMode,\n    pub max_results: Option\u003cusize\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct SearchResult {\n    pub file: PathBuf,\n    pub start_line: usize, // First line in the section (including context)\n    pub line_content: Vec\u003cString\u003e, // All lines in the section\n    pub match_lines: Vec\u003cusize\u003e, // Line numbers with matches (relative to start_line)\n    pub match_ranges: Vec\u003cVec\u003c(usize, usize)\u003e\u003e, // Match positions for each line, aligned with match_lines\n}\n\npub trait CodeExplorer: Send + Sync {\n    fn root_dir(\u0026self) -\u003e PathBuf;\n    /// Reads the content of a file\n    fn read_file(\u0026self, path: \u0026PathBuf) -\u003e Result\u003cString\u003e;\n    /// Write the content of a file\n    fn write_file(\u0026self, path: \u0026PathBuf, content: \u0026String) -\u003e Result\u003c()\u003e;\n    fn delete_file(\u0026self, path: \u0026PathBuf) -\u003e Result\u003c()\u003e;\n    fn create_initial_tree(\u0026mut self, max_depth: usize) -\u003e Result\u003cFileTreeEntry\u003e;\n    fn list_files(\u0026mut self, path: \u0026PathBuf, max_depth: Option\u003cusize\u003e) -\u003e Result\u003cFileTreeEntry\u003e;\n    /// Applies FileReplacements to a file\n    fn apply_replacements(\u0026self, path: \u0026Path, replacements: \u0026[FileReplacement]) -\u003e Result\u003cString\u003e;\n    /// Search for text in files with advanced options\n    fn search(\u0026self, path: \u0026Path, options: SearchOptions) -\u003e Result\u003cVec\u003cSearchResult\u003e\u003e;\n}\n","traces":[{"line":211,"address":[],"length":0,"stats":{"Line":12}},{"line":212,"address":[],"length":0,"stats":{"Line":12}}],"covered":2,"coverable":2},{"path":["/","Users","stippi","projects","code-assistant","src","ui","mod.rs"],"content":"pub mod terminal;\nuse async_trait::async_trait;\nuse thiserror::Error;\n\n#[derive(Debug, Clone)]\npub enum UIMessage {\n    // System actions that the agent takes\n    Action(String),\n    // Questions to the user that need a response\n    Question(String),\n    // LLM's reasoning about its next action\n    Reasoning(String),\n}\n\n#[derive(Error, Debug)]\npub enum UIError {\n    #[error(\"IO error: {0}\")]\n    IOError(#[from] std::io::Error),\n    // #[error(\"Input cancelled\")]\n    // Cancelled,\n    // #[error(\"Other UI error: {0}\")]\n    // Other(String),\n}\n\n#[async_trait]\npub trait UserInterface: Send + Sync {\n    /// Display a message to the user\n    async fn display(\u0026self, message: UIMessage) -\u003e Result\u003c(), UIError\u003e;\n\n    /// Get input from the user\n    async fn get_input(\u0026self, prompt: \u0026str) -\u003e Result\u003cString, UIError\u003e;\n\n    /// Display streaming output synchronously\n    fn display_streaming(\u0026self, text: \u0026str) -\u003e Result\u003c(), UIError\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","stippi","projects","code-assistant","src","ui","terminal.rs"],"content":"use super::{UIError, UIMessage, UserInterface};\nuse async_trait::async_trait;\nuse std::io::{self, Write};\nuse tokio::io::{AsyncBufReadExt, BufReader};\n\npub struct TerminalUI;\n\nimpl TerminalUI {\n    pub fn new() -\u003e Self {\n        Self\n    }\n\n    async fn write_line(\u0026self, s: \u0026str) -\u003e Result\u003c(), UIError\u003e {\n        let mut stdout = io::stdout().lock();\n        writeln!(stdout, \"{}\", s)?;\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl UserInterface for TerminalUI {\n    async fn display(\u0026self, message: UIMessage) -\u003e Result\u003c(), UIError\u003e {\n        match message {\n            UIMessage::Action(msg) =\u003e self.write_line(\u0026msg).await?,\n            UIMessage::Question(msg) =\u003e self.write_line(\u0026format!(\"{}\\n\u003e \", msg)).await?,\n            UIMessage::Reasoning(msg) =\u003e {\n                self.write_line(\"\").await?;\n                self.write_line(\"Reasoning:\").await?;\n                self.write_line(\u0026format!(\"  {}\", msg)).await?;\n                self.write_line(\"\").await?;\n            }\n        }\n        Ok(())\n    }\n\n    async fn get_input(\u0026self, prompt: \u0026str) -\u003e Result\u003cString, UIError\u003e {\n        print!(\"{}\", prompt);\n        io::stdout().flush()?;\n\n        let mut line = String::new();\n        let stdin = tokio::io::stdin();\n        let mut reader = BufReader::new(stdin);\n        reader.read_line(\u0026mut line).await?;\n\n        Ok(line.trim().to_string())\n    }\n\n    fn display_streaming(\u0026self, text: \u0026str) -\u003e Result\u003c(), UIError\u003e {\n        let mut stdout = io::stdout().lock();\n        write!(stdout, \"{}\", text)?;\n        stdout.flush()?;\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":29},{"path":["/","Users","stippi","projects","code-assistant","src","utils","command.rs"],"content":"use anyhow::Result;\nuse std::path::PathBuf;\n\npub struct CommandOutput {\n    pub success: bool,\n    pub stdout: String,\n    pub stderr: String,\n}\n\n#[async_trait::async_trait]\npub trait CommandExecutor: Send + Sync {\n    async fn execute(\n        \u0026self,\n        command_line: \u0026str,\n        working_dir: Option\u003c\u0026PathBuf\u003e,\n    ) -\u003e Result\u003cCommandOutput\u003e;\n}\n\npub struct DefaultCommandExecutor;\n\n#[async_trait::async_trait]\nimpl CommandExecutor for DefaultCommandExecutor {\n    async fn execute(\n        \u0026self,\n        command_line: \u0026str,\n        working_dir: Option\u003c\u0026PathBuf\u003e,\n    ) -\u003e Result\u003cCommandOutput\u003e {\n        // Validate working_dir first\n        if let Some(dir) = working_dir {\n            if !dir.exists() {\n                return Err(anyhow::anyhow!(\n                    \"Working directory does not exist: {}\",\n                    dir.display()\n                ));\n            }\n            if !dir.is_dir() {\n                return Err(anyhow::anyhow!(\n                    \"Path is not a directory: {}\",\n                    dir.display()\n                ));\n            }\n        }\n        // Create shell command using login shell or fallback\n        #[cfg(target_family = \"unix\")]\n        let shell = std::env::var(\"SHELL\").unwrap_or_else(|_| \"/bin/bash\".to_string());\n        #[cfg(target_family = \"unix\")]\n        let mut cmd = std::process::Command::new(shell);\n        #[cfg(target_family = \"unix\")]\n        cmd.args([\"-c\", command_line]);\n\n        #[cfg(target_family = \"windows\")]\n        let mut cmd = std::process::Command::new(\"cmd\");\n        #[cfg(target_family = \"windows\")]\n        cmd.args([\"/C\", command_line]);\n\n        if let Some(dir) = working_dir {\n            cmd.current_dir(dir);\n        }\n        let output = cmd.output()?;\n\n        Ok(CommandOutput {\n            success: output.status.success(),\n            stdout: String::from_utf8_lossy(\u0026output.stdout).into_owned(),\n            stderr: String::from_utf8_lossy(\u0026output.stderr).into_owned(),\n        })\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":19},{"path":["/","Users","stippi","projects","code-assistant","src","utils","file_updater.rs"],"content":"use crate::types::FileReplacement;\n\npub fn apply_replacements(\n    content: \u0026str,\n    replacements: \u0026[FileReplacement],\n) -\u003e Result\u003cString, anyhow::Error\u003e {\n    let mut result = content.to_string();\n\n    for replacement in replacements {\n        // Count occurrences to ensure uniqueness\n        let matches: Vec\u003c_\u003e = result.match_indices(\u0026replacement.search).collect();\n\n        match matches.len() {\n            0 =\u003e anyhow::bail!(\n                \"Could not find search content:\\n{}\\nin file content\",\n                replacement.search\n            ),\n            1 =\u003e {\n                let (pos, _) = matches[0];\n                result.replace_range(\n                    pos..pos + replacement.search.len(),\n                    \u0026replacement.replace\n                );\n            },\n            _ =\u003e anyhow::bail!(\n                \"Found {} occurrences of search content:\\n```\\n{}\\n```\\nSearch text must match exactly one location. Try enlarging the section to replace.\",\n                matches.len(),\n                replacement.search\n            ),\n        }\n    }\n\n    Ok(result)\n}\n\n#[test]\nfn test_apply_replacements() -\u003e Result\u003c(), anyhow::Error\u003e {\n    let test_cases = vec![\n        // Basic replacement\n        (\n            \"Hello World\\nThis is a test\\nGoodbye\",\n            vec![FileReplacement {\n                search: \"Hello World\".to_string(),\n                replace: \"Hi there\".to_string(),\n            }],\n            Ok(\"Hi there\\nThis is a test\\nGoodbye\"),\n        ),\n        // Multiple unique replacements\n        (\n            \"function test() {\\n  console.log('test');\\n}\",\n            vec![\n                FileReplacement {\n                    search: \"console.log('test');\".to_string(),\n                    replace: \"return 42;\".to_string(),\n                },\n                FileReplacement {\n                    search: \"function test()\".to_string(),\n                    replace: \"function answer()\".to_string(),\n                },\n            ],\n            Ok(\"function answer() {\\n  return 42;\\n}\"),\n        ),\n        // Test error with duplicate content\n        (\n            \"test\\ntest\\ntest\",\n            vec![FileReplacement {\n                search: \"test\".to_string(),\n                replace: \"replaced\".to_string(),\n            }],\n            Err(\"Found 3 occurrences of search content\"), // Partial string match is fine for the test\n        ),\n        // Test error with not found content\n        (\n            \"test content\",\n            vec![FileReplacement {\n                search: \"not found\".to_string(),\n                replace: \"anything\".to_string(),\n            }],\n            Err(\"Could not find search content\"), // Partial string match is fine for the test\n        ),\n    ];\n\n    for (input, replacements, expected) in test_cases {\n        let result = apply_replacements(input, \u0026replacements);\n        match (result, expected) {\n            (Ok(result), Ok(expected)) =\u003e assert_eq!(result, expected),\n            (Err(e), Err(expected)) =\u003e assert!(e.to_string().contains(expected)),\n            _ =\u003e panic!(\"Test case result did not match expected outcome\"),\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":3,"address":[],"length":0,"stats":{"Line":9}},{"line":7,"address":[],"length":0,"stats":{"Line":9}},{"line":9,"address":[],"length":0,"stats":{"Line":29}},{"line":14,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":18,"address":[],"length":0,"stats":{"Line":8}},{"line":19,"address":[],"length":0,"stats":{"Line":8}},{"line":20,"address":[],"length":0,"stats":{"Line":8}},{"line":21,"address":[],"length":0,"stats":{"Line":8}},{"line":22,"address":[],"length":0,"stats":{"Line":8}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":27,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":5}}],"covered":14,"coverable":14},{"path":["/","Users","stippi","projects","code-assistant","src","utils","mod.rs"],"content":"mod command;\nmod file_updater;\n\n#[allow(unused_imports)]\npub use command::{CommandExecutor, CommandOutput, DefaultCommandExecutor};\npub use file_updater::apply_replacements;\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","Users","stippi","projects","code-assistant","src","agent","agent.rs"],"content":"use crate::llm::{\n    ContentBlock, LLMProvider, LLMRequest, Message, MessageContent, MessageRole, StreamingCallback,\n};\nuse crate::persistence::StatePersistence;\nuse crate::tools::{\n    parse_tool_json, parse_tool_xml, AgentToolHandler, ReplayToolHandler, ToolExecutor,\n    TOOL_TAG_PREFIX,\n};\nuse crate::types::*;\nuse crate::ui::{UIMessage, UserInterface};\nuse crate::utils::CommandExecutor;\nuse anyhow::Result;\nuse std::sync::Arc;\nuse tracing::debug;\n\nconst SYSTEM_MESSAGE: \u0026str = include_str!(\"../../resources/system_message.md\");\nconst SYSTEM_MESSAGE_TOOLS: \u0026str = include_str!(\"../../resources/system_message_tools.md\");\n\npub enum ToolMode {\n    Native,\n    Xml,\n}\n\npub struct Agent {\n    working_memory: WorkingMemory,\n    llm_provider: Box\u003cdyn LLMProvider\u003e,\n    tool_mode: ToolMode,\n    explorer: Box\u003cdyn CodeExplorer\u003e,\n    command_executor: Box\u003cdyn CommandExecutor\u003e,\n    ui: Arc\u003cBox\u003cdyn UserInterface\u003e\u003e,\n    state_persistence: Box\u003cdyn StatePersistence\u003e,\n}\n\nimpl Agent {\n    pub fn new(\n        llm_provider: Box\u003cdyn LLMProvider\u003e,\n        tool_mode: ToolMode,\n        explorer: Box\u003cdyn CodeExplorer\u003e,\n        command_executor: Box\u003cdyn CommandExecutor\u003e,\n        ui: Box\u003cdyn UserInterface\u003e,\n        state_persistence: Box\u003cdyn StatePersistence\u003e,\n    ) -\u003e Self {\n        Self {\n            working_memory: WorkingMemory::default(),\n            llm_provider,\n            tool_mode,\n            explorer,\n            ui: Arc::new(ui),\n            command_executor,\n            state_persistence,\n        }\n    }\n\n    async fn run_agent_loop(\u0026mut self) -\u003e Result\u003c()\u003e {\n        // Main agent loop\n        loop {\n            // Start with just the working memory message\n            let mut messages = self.prepare_messages();\n\n            // Keep trying until all actions succeed\n            let mut all_actions_succeeded = false;\n            while !all_actions_succeeded {\n                let (actions, assistant_msg) = self.get_next_actions(messages.clone()).await?;\n                messages.push(assistant_msg);\n\n                all_actions_succeeded = true; // Will be set to false if any action fails\n\n                for action in actions {\n                    let result = self.execute_action(\u0026action).await?;\n\n                    if !result.result.is_success() {\n                        all_actions_succeeded = false;\n                        // Add error message to conversation\n                        messages.push(Message {\n                            role: MessageRole::User,\n                            content: MessageContent::Text(format!(\n                                \"Error executing action: {}\\n{}\",\n                                result.reasoning,\n                                result.result.format_message()\n                            )),\n                        });\n                        break; // Stop processing remaining actions\n                    }\n\n                    self.working_memory.action_history.push(result);\n\n                    // Save state after each successful action\n                    self.state_persistence.save_state(\n                        self.working_memory.current_task.clone(),\n                        self.working_memory.action_history.clone(),\n                    )?;\n\n                    // Check if this was a CompleteTask action\n                    if let Tool::CompleteTask { .. } = action.tool {\n                        // Clean up state file on successful completion\n                        self.state_persistence.cleanup()?;\n                        debug!(\"Task completed\");\n                        return Ok(());\n                    }\n                }\n            }\n        }\n    }\n\n    /// Start a new agent task\n    pub async fn start_with_task(\u0026mut self, task: String) -\u003e Result\u003c()\u003e {\n        debug!(\"Starting agent with task: {}\", task);\n        self.working_memory.current_task = task.clone();\n\n        self.ui\n            .display(UIMessage::Action(\n                \"Creating initial repository structure...\".to_string(),\n            ))\n            .await?;\n\n        self.working_memory.file_tree = Some(self.explorer.create_initial_tree(2)?);\n\n        // Save initial state\n        self.state_persistence\n            .save_state(task, self.working_memory.action_history.clone())?;\n\n        self.run_agent_loop().await\n    }\n\n    /// Continue from a saved state\n    pub async fn start_from_state(\u0026mut self) -\u003e Result\u003c()\u003e {\n        if let Some(state) = self.state_persistence.load_state()? {\n            debug!(\"Continuing task: {}\", state.task);\n\n            // Create fresh working memory for replay\n            let mut replay_memory = WorkingMemory::default();\n            replay_memory.current_task = state.task.clone();\n            replay_memory.file_tree = Some(self.explorer.create_initial_tree(2)?);\n\n            // Create replay executor\n            let mut replay_handler = ReplayToolHandler::new(replay_memory);\n\n            self.ui\n                .display(UIMessage::Action(format!(\n                    \"Continuing task: {}, replaying {} actions\",\n                    state.task,\n                    state.actions.len()\n                )))\n                .await?;\n\n            // Replay actions into replay memory\n            for original_action in state.actions {\n                debug!(\"Replaying action: {:?}\", original_action.tool);\n                let action = AgentAction {\n                    tool: original_action.tool.clone(),\n                    reasoning: original_action.reasoning.clone(),\n                };\n\n                if let Ok((_, result)) = ToolExecutor::execute(\n                    \u0026mut replay_handler,\n                    Some(\u0026mut self.explorer),\n                    \u0026self.command_executor,\n                    Some(\u0026self.ui),\n                    \u0026action.tool,\n                )\n                .await\n                {\n                    if result.is_success() {\n                        self.working_memory.action_history.push(ActionResult {\n                            tool: action.tool,\n                            result,\n                            reasoning: action.reasoning,\n                        });\n                    } else {\n                        // On failure use original result\n                        self.working_memory.action_history.push(original_action);\n                    }\n                } else {\n                    // On error use original result\n                    self.working_memory.action_history.push(original_action);\n                }\n            }\n\n            // Take the replayed memory\n            self.working_memory = replay_handler.into_memory();\n\n            self.run_agent_loop().await\n        } else {\n            anyhow::bail!(\"No saved state found\")\n        }\n    }\n\n    /// Get next actions from LLM\n    async fn get_next_actions(\n        \u0026self,\n        messages: Vec\u003cMessage\u003e,\n    ) -\u003e Result\u003c(Vec\u003cAgentAction\u003e, Message)\u003e {\n        let request = LLMRequest {\n            messages,\n            system_prompt: match self.tool_mode {\n                ToolMode::Native =\u003e SYSTEM_MESSAGE.to_string(),\n                ToolMode::Xml =\u003e SYSTEM_MESSAGE_TOOLS.to_string(),\n            },\n            tools: match self.tool_mode {\n                ToolMode::Native =\u003e Some(Tools::all()),\n                ToolMode::Xml =\u003e None,\n            },\n        };\n\n        for (i, message) in request.messages.iter().enumerate() {\n            if let MessageContent::Text(text) = \u0026message.content {\n                debug!(\"Message {}: Role={:?}\\n---\\n{}\\n---\", i, message.role, text);\n            }\n        }\n\n        let ui = Arc::clone(\u0026self.ui);\n        let streaming_callback: StreamingCallback = Box::new(move |text: \u0026str| {\n            ui.display_streaming(text)\n                .map_err(|e| anyhow::anyhow!(\"Failed to display streaming output: {}\", e))\n        });\n\n        let response = self\n            .llm_provider\n            .send_message(request, Some(\u0026streaming_callback))\n            .await?;\n\n        debug!(\"Raw LLM response:\");\n        for block in \u0026response.content {\n            match block {\n                ContentBlock::Text { text } =\u003e {\n                    debug!(\"---\\n{}\\n---\", text);\n                }\n                ContentBlock::ToolUse { name, input, .. } =\u003e {\n                    debug!(\"---\\ntool: {}, input: {}\\n---\", name, input);\n                }\n                _ =\u003e {}\n            }\n        }\n        debug!(\n            \"==== Token usage: Input: {}, Output: {}\",\n            response.usage.input_tokens, response.usage.output_tokens\n        );\n\n        let actions = parse_llm_response(\u0026response)?;\n        let assistant_msg = Message {\n            role: MessageRole::Assistant,\n            content: MessageContent::Structured(response.content),\n        };\n        Ok((actions, assistant_msg))\n    }\n\n    pub fn render_working_memory(\u0026self) -\u003e String {\n        let mut memory = format!(\"Task: {}\\n\\n\", self.working_memory.current_task);\n\n        // Add repository structure with proper indentation\n        memory.push_str(\"Repository structure:\\n\");\n        if let Some(tree) = \u0026self.working_memory.file_tree {\n            memory.push_str(\u0026tree.to_string());\n        } else {\n            memory.push_str(\"No file tree available\");\n        }\n        memory.push_str(\"\\n\\n\");\n\n        // Add loaded files with their contents\n        memory.push_str(\"Current Working Memory:\\n\");\n        memory.push_str(\"- Loaded files and their contents:\\n\");\n        for (path, content) in \u0026self.working_memory.loaded_files {\n            memory.push_str(\u0026format!(\"\\n-----{}:\\n{}\\n\", path.display(), content));\n        }\n\n        // Add file summaries\n        memory.push_str(\"\\n- File summaries:\\n\");\n        for (path, summary) in \u0026self.working_memory.file_summaries {\n            memory.push_str(\u0026format!(\"  {}: {}\\n\", path.display(), summary));\n        }\n\n        // Add action history\n        memory.push_str(\"\\nPrevious actions:\\n\");\n        for (i, action) in self.working_memory.action_history.iter().enumerate() {\n            memory.push_str(\u0026format!(\"\\n{}. Tool: {:?}\\n\", i + 1, action.tool));\n            memory.push_str(\u0026format!(\"   Reasoning: {}\\n\", action.reasoning));\n            memory.push_str(\u0026format!(\"   Result: {}\\n\", action.result.format_message()));\n        }\n\n        memory\n    }\n\n    /// Prepare messages for LLM request - currently returns a single user message\n    /// but kept as Vec\u003cMessage\u003e for flexibility to change the format later\n    fn prepare_messages(\u0026self) -\u003e Vec\u003cMessage\u003e {\n        vec![Message {\n            role: MessageRole::User,\n            content: MessageContent::Text(self.render_working_memory()),\n        }]\n    }\n\n    /// Executes an action and returns the result\n    async fn execute_action(\u0026mut self, action: \u0026AgentAction) -\u003e Result\u003cActionResult\u003e {\n        debug!(\"Executing action: {:?}\", action.tool);\n\n        // Display the agent's reasoning\n        self.ui\n            .display(UIMessage::Reasoning(action.reasoning.clone()))\n            .await?;\n\n        let mut handler = AgentToolHandler::new(\u0026mut self.working_memory);\n\n        // Execute the tool and get both the output and result\n        let (output, tool_result) = ToolExecutor::execute(\n            \u0026mut handler,\n            Some(\u0026mut self.explorer),\n            \u0026self.command_executor,\n            Some(\u0026self.ui),\n            \u0026action.tool,\n        )\n        .await?;\n\n        // Display any tool output to the user\n        if !output.is_empty() {\n            self.ui.display(UIMessage::Action(output)).await?;\n        }\n\n        Ok(ActionResult {\n            tool: action.tool.clone(),\n            result: tool_result,\n            reasoning: action.reasoning.clone(),\n        })\n    }\n}\n\npub(crate) fn parse_llm_response(response: \u0026crate::llm::LLMResponse) -\u003e Result\u003cVec\u003cAgentAction\u003e\u003e {\n    let mut actions = Vec::new();\n\n    let mut reasoning = String::new();\n\n    for block in \u0026response.content {\n        if let ContentBlock::Text { text } = block {\n            let mut current_pos = 0;\n\n            while let Some(tool_start) = text[current_pos..].find(\u0026format!(\"\u003c{}\", TOOL_TAG_PREFIX))\n            {\n                let abs_start = current_pos + tool_start;\n\n                // Add text before tool to reasoning\n                reasoning.push_str(text[current_pos..abs_start].trim());\n                if !reasoning.is_empty() {\n                    reasoning.push('\\n');\n                }\n\n                // Find the root tag name\n                let tag_name = text[abs_start..]\n                    .split('\u003e')\n                    .next()\n                    .and_then(|s| s.strip_prefix('\u003c'))\n                    .ok_or_else(|| anyhow::anyhow!(\"Invalid XML: missing tag name\"))?;\n\n                // Only process tags with our tool prefix\n                if let Some(tool_name) = tag_name.strip_prefix(TOOL_TAG_PREFIX) {\n                    // Find closing tag for the root element\n                    let closing_tag = format!(\"\u003c/{}{}\u003e\", TOOL_TAG_PREFIX, tool_name);\n                    if let Some(rel_end) = text[abs_start..].find(\u0026closing_tag) {\n                        let abs_end = abs_start + rel_end + closing_tag.len();\n                        let tool_content = \u0026text[abs_start..abs_end];\n                        debug!(\"Found tool content:\\n{}\", tool_content);\n\n                        // Parse and add the tool action\n                        let tool = parse_tool_xml(tool_content)?;\n                        actions.push(AgentAction {\n                            tool,\n                            reasoning: remove_thinking_tags(reasoning.trim()).to_owned(),\n                        });\n\n                        current_pos = abs_end;\n                        continue;\n                    }\n                }\n\n                // If we get here, either the tag didn't have our prefix or we didn't find the closing tag\n                // In both cases, treat it as regular text\n                reasoning.push_str(\u0026text[abs_start..abs_start + 1]);\n                current_pos = abs_start + 1;\n            }\n\n            // Add any remaining text to reasoning\n            if current_pos \u003c text.len() {\n                reasoning.push_str(text[current_pos..].trim());\n            }\n        }\n\n        if let ContentBlock::ToolUse { name, input, .. } = block {\n            let tool = parse_tool_json(name, input)?;\n            actions.push(AgentAction {\n                tool,\n                reasoning: remove_thinking_tags(reasoning.trim()).to_owned(),\n            });\n            reasoning = String::new();\n        }\n    }\n\n    Ok(actions)\n}\n\nfn remove_thinking_tags(input: \u0026str) -\u003e \u0026str {\n    if input.starts_with(\"\u003cthinking\u003e\") \u0026\u0026 input.ends_with(\"\u003c/thinking\u003e\") {\n        \u0026input[10..input.len() - 11]\n    } else {\n        input\n    }\n}\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":5}},{"line":44,"address":[],"length":0,"stats":{"Line":5}},{"line":48,"address":[],"length":0,"stats":{"Line":5}},{"line":54,"address":[],"length":0,"stats":{"Line":10}},{"line":58,"address":[],"length":0,"stats":{"Line":12}},{"line":61,"address":[],"length":0,"stats":{"Line":12}},{"line":62,"address":[],"length":0,"stats":{"Line":20}},{"line":63,"address":[],"length":0,"stats":{"Line":26}},{"line":64,"address":[],"length":0,"stats":{"Line":13}},{"line":66,"address":[],"length":0,"stats":{"Line":13}},{"line":68,"address":[],"length":0,"stats":{"Line":33}},{"line":69,"address":[],"length":0,"stats":{"Line":13}},{"line":71,"address":[],"length":0,"stats":{"Line":13}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":85,"address":[],"length":0,"stats":{"Line":12}},{"line":88,"address":[],"length":0,"stats":{"Line":12}},{"line":89,"address":[],"length":0,"stats":{"Line":12}},{"line":90,"address":[],"length":0,"stats":{"Line":12}},{"line":94,"address":[],"length":0,"stats":{"Line":12}},{"line":96,"address":[],"length":0,"stats":{"Line":5}},{"line":97,"address":[],"length":0,"stats":{"Line":5}},{"line":98,"address":[],"length":0,"stats":{"Line":5}},{"line":106,"address":[],"length":0,"stats":{"Line":10}},{"line":107,"address":[],"length":0,"stats":{"Line":5}},{"line":108,"address":[],"length":0,"stats":{"Line":5}},{"line":110,"address":[],"length":0,"stats":{"Line":5}},{"line":111,"address":[],"length":0,"stats":{"Line":5}},{"line":112,"address":[],"length":0,"stats":{"Line":5}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":10}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":5}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":13}},{"line":195,"address":[],"length":0,"stats":{"Line":13}},{"line":199,"address":[],"length":0,"stats":{"Line":13}},{"line":205,"address":[],"length":0,"stats":{"Line":28}},{"line":206,"address":[],"length":0,"stats":{"Line":29}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":13}},{"line":212,"address":[],"length":0,"stats":{"Line":13}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":26}},{"line":218,"address":[],"length":0,"stats":{"Line":13}},{"line":219,"address":[],"length":0,"stats":{"Line":13}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":13}},{"line":223,"address":[],"length":0,"stats":{"Line":65}},{"line":225,"address":[],"length":0,"stats":{"Line":13}},{"line":226,"address":[],"length":0,"stats":{"Line":13}},{"line":228,"address":[],"length":0,"stats":{"Line":13}},{"line":229,"address":[],"length":0,"stats":{"Line":13}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":13}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":26}},{"line":242,"address":[],"length":0,"stats":{"Line":13}},{"line":244,"address":[],"length":0,"stats":{"Line":13}},{"line":247,"address":[],"length":0,"stats":{"Line":12}},{"line":248,"address":[],"length":0,"stats":{"Line":12}},{"line":251,"address":[],"length":0,"stats":{"Line":12}},{"line":252,"address":[],"length":0,"stats":{"Line":24}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":12}},{"line":260,"address":[],"length":0,"stats":{"Line":12}},{"line":261,"address":[],"length":0,"stats":{"Line":12}},{"line":262,"address":[],"length":0,"stats":{"Line":24}},{"line":263,"address":[],"length":0,"stats":{"Line":4}},{"line":267,"address":[],"length":0,"stats":{"Line":12}},{"line":268,"address":[],"length":0,"stats":{"Line":12}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":12}},{"line":274,"address":[],"length":0,"stats":{"Line":30}},{"line":275,"address":[],"length":0,"stats":{"Line":9}},{"line":276,"address":[],"length":0,"stats":{"Line":9}},{"line":277,"address":[],"length":0,"stats":{"Line":9}},{"line":280,"address":[],"length":0,"stats":{"Line":12}},{"line":285,"address":[],"length":0,"stats":{"Line":12}},{"line":286,"address":[],"length":0,"stats":{"Line":12}},{"line":287,"address":[],"length":0,"stats":{"Line":12}},{"line":288,"address":[],"length":0,"stats":{"Line":12}},{"line":293,"address":[],"length":0,"stats":{"Line":26}},{"line":294,"address":[],"length":0,"stats":{"Line":13}},{"line":297,"address":[],"length":0,"stats":{"Line":13}},{"line":298,"address":[],"length":0,"stats":{"Line":13}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":13}},{"line":305,"address":[],"length":0,"stats":{"Line":13}},{"line":306,"address":[],"length":0,"stats":{"Line":13}},{"line":307,"address":[],"length":0,"stats":{"Line":13}},{"line":308,"address":[],"length":0,"stats":{"Line":13}},{"line":309,"address":[],"length":0,"stats":{"Line":13}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":13}},{"line":315,"address":[],"length":0,"stats":{"Line":13}},{"line":318,"address":[],"length":0,"stats":{"Line":13}},{"line":319,"address":[],"length":0,"stats":{"Line":13}},{"line":320,"address":[],"length":0,"stats":{"Line":13}},{"line":321,"address":[],"length":0,"stats":{"Line":13}},{"line":326,"address":[],"length":0,"stats":{"Line":15}},{"line":327,"address":[],"length":0,"stats":{"Line":15}},{"line":329,"address":[],"length":0,"stats":{"Line":15}},{"line":331,"address":[],"length":0,"stats":{"Line":71}},{"line":332,"address":[],"length":0,"stats":{"Line":15}},{"line":335,"address":[],"length":0,"stats":{"Line":19}},{"line":341,"address":[],"length":0,"stats":{"Line":2}},{"line":342,"address":[],"length":0,"stats":{"Line":2}},{"line":346,"address":[],"length":0,"stats":{"Line":2}},{"line":349,"address":[],"length":0,"stats":{"Line":2}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":2}},{"line":356,"address":[],"length":0,"stats":{"Line":2}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":4}},{"line":363,"address":[],"length":0,"stats":{"Line":2}},{"line":364,"address":[],"length":0,"stats":{"Line":2}},{"line":365,"address":[],"length":0,"stats":{"Line":2}},{"line":368,"address":[],"length":0,"stats":{"Line":2}},{"line":369,"address":[],"length":0,"stats":{"Line":2}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":28}},{"line":381,"address":[],"length":0,"stats":{"Line":13}},{"line":385,"address":[],"length":0,"stats":{"Line":41}},{"line":386,"address":[],"length":0,"stats":{"Line":13}},{"line":387,"address":[],"length":0,"stats":{"Line":13}},{"line":388,"address":[],"length":0,"stats":{"Line":13}},{"line":389,"address":[],"length":0,"stats":{"Line":13}},{"line":391,"address":[],"length":0,"stats":{"Line":13}},{"line":395,"address":[],"length":0,"stats":{"Line":15}},{"line":398,"address":[],"length":0,"stats":{"Line":15}},{"line":399,"address":[],"length":0,"stats":{"Line":15}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":15}}],"covered":124,"coverable":174},{"path":["/","Users","stippi","projects","code-assistant","src","agent","mod.rs"],"content":"#[cfg(test)]\nmod tests;\n\nmod agent;\n\npub use agent::Agent;\npub use agent::ToolMode;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","stippi","projects","code-assistant","src","agent","tests.rs"],"content":"use super::*;\nuse crate::agent::agent::parse_llm_response;\nuse crate::llm::{types::*, LLMProvider, LLMRequest, StreamingCallback};\nuse crate::persistence::MockStatePersistence;\nuse crate::types::*;\nuse crate::ui::{UIError, UIMessage, UserInterface};\nuse crate::utils::{CommandExecutor, CommandOutput};\nuse agent::ToolMode;\nuse anyhow::Result;\nuse async_trait::async_trait;\nuse regex::RegexBuilder;\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::sync::{Arc, Mutex};\n\n// Mock LLM Provider\n#[derive(Default, Clone)]\nstruct MockLLMProvider {\n    requests: Arc\u003cMutex\u003cVec\u003cLLMRequest\u003e\u003e\u003e,\n    responses: Arc\u003cMutex\u003cVec\u003cResult\u003cLLMResponse, anyhow::Error\u003e\u003e\u003e\u003e,\n}\n\nimpl MockLLMProvider {\n    fn new(mut responses: Vec\u003cResult\u003cLLMResponse, anyhow::Error\u003e\u003e) -\u003e Self {\n        // Add CompleteTask response at the beginning if the first response is ok\n        if responses.first().map_or(false, |r| r.is_ok()) {\n            responses.insert(\n                0,\n                Ok(create_test_response(\n                    Tool::CompleteTask {\n                        message: \"Task completed successfully\".to_string(),\n                    },\n                    \"Completing task after successful execution\",\n                )),\n            );\n        }\n\n        Self {\n            requests: Arc::new(Mutex::new(Vec::new())),\n            responses: Arc::new(Mutex::new(responses)),\n        }\n    }\n\n    pub fn print_requests(\u0026self) {\n        let requests = self.requests.lock().unwrap();\n        println!(\"\\nTotal number of requests: {}\", requests.len());\n        for (i, request) in requests.iter().enumerate() {\n            println!(\"\\nRequest {}:\", i);\n            for (j, message) in request.messages.iter().enumerate() {\n                println!(\"  Message {}:\", j);\n                if let MessageContent::Text(content) = \u0026message.content {\n                    println!(\"    {}\", content.replace('\\n', \"\\n    \"));\n                }\n            }\n        }\n    }\n\n    // // Helper method for tests that need specific completion handling\n    // fn new_with_custom_completion(\n    //     mut responses: Vec\u003cResult\u003cLLMResponse, anyhow::Error\u003e\u003e,\n    //     completion_message: Option\u003cString\u003e,\n    // ) -\u003e Self {\n    //     if let Some(msg) = completion_message {\n    //         responses.push(Ok(create_test_response(\n    //             Tool::CompleteTask { message: msg },\n    //             \"Custom completion message\",\n    //         )));\n    //     }\n\n    //     Self {\n    //         requests: Arc::new(Mutex::new(Vec::new())),\n    //         responses: Arc::new(Mutex::new(responses)),\n    //     }\n    // }\n}\n\n#[async_trait]\nimpl LLMProvider for MockLLMProvider {\n    async fn send_message(\n        \u0026self,\n        request: LLMRequest,\n        _streaming_callback: Option\u003c\u0026StreamingCallback\u003e,\n    ) -\u003e Result\u003cLLMResponse, anyhow::Error\u003e {\n        self.requests.lock().unwrap().push(request);\n        self.responses\n            .lock()\n            .unwrap()\n            .pop()\n            .unwrap_or(Err(anyhow::anyhow!(\"No more mock responses\")))\n    }\n}\n\n// Mock CommandExecutor\n#[derive(Clone)]\nstruct MockCommandExecutor {\n    responses: Arc\u003cMutex\u003cVec\u003cResult\u003cCommandOutput, anyhow::Error\u003e\u003e\u003e\u003e,\n    calls: Arc\u003cAtomicUsize\u003e,\n    captured_commands: Arc\u003cMutex\u003cVec\u003c(String, Option\u003cPathBuf\u003e)\u003e\u003e\u003e,\n}\n\nimpl MockCommandExecutor {\n    fn new(responses: Vec\u003cResult\u003cCommandOutput, anyhow::Error\u003e\u003e) -\u003e Self {\n        Self {\n            responses: Arc::new(Mutex::new(responses)),\n            calls: Arc::new(AtomicUsize::new(0)),\n            captured_commands: Arc::new(Mutex::new(Vec::new())),\n        }\n    }\n\n    fn get_captured_commands(\u0026self) -\u003e Vec\u003c(String, Option\u003cPathBuf\u003e)\u003e {\n        self.captured_commands.lock().unwrap().clone()\n    }\n}\n\n#[async_trait::async_trait]\nimpl CommandExecutor for MockCommandExecutor {\n    async fn execute(\n        \u0026self,\n        command_line: \u0026str,\n        working_dir: Option\u003c\u0026PathBuf\u003e,\n    ) -\u003e Result\u003cCommandOutput\u003e {\n        self.calls.fetch_add(1, Ordering::Relaxed);\n        self.captured_commands\n            .lock()\n            .unwrap()\n            .push((command_line.to_string(), working_dir.cloned()));\n\n        self.responses\n            .lock()\n            .unwrap()\n            .pop()\n            .unwrap_or(Err(anyhow::anyhow!(\"No more mock responses\")))\n    }\n}\n\n// Mock UI\n#[derive(Default, Clone)]\nstruct MockUI {\n    messages: Arc\u003cMutex\u003cVec\u003cUIMessage\u003e\u003e\u003e,\n    streaming: Arc\u003cMutex\u003cVec\u003cString\u003e\u003e\u003e,\n    responses: Arc\u003cMutex\u003cVec\u003cResult\u003cString, UIError\u003e\u003e\u003e\u003e,\n}\n\nimpl MockUI {\n    fn new(responses: Vec\u003cResult\u003cString, UIError\u003e\u003e) -\u003e Self {\n        Self {\n            messages: Arc::new(Mutex::new(Vec::new())),\n            streaming: Arc::new(Mutex::new(Vec::new())),\n            responses: Arc::new(Mutex::new(responses)),\n        }\n    }\n\n    fn get_messages(\u0026self) -\u003e Vec\u003cUIMessage\u003e {\n        self.messages.lock().unwrap().clone()\n    }\n}\n\n#[async_trait]\nimpl UserInterface for MockUI {\n    async fn display(\u0026self, message: UIMessage) -\u003e Result\u003c(), UIError\u003e {\n        self.messages.lock().unwrap().push(message);\n        Ok(())\n    }\n\n    async fn get_input(\u0026self, _prompt: \u0026str) -\u003e Result\u003cString, UIError\u003e {\n        self.responses\n            .lock()\n            .unwrap()\n            .pop()\n            .unwrap_or(Err(UIError::IOError(std::io::Error::new(\n                std::io::ErrorKind::Other,\n                \"No more mock responses\",\n            ))))\n    }\n\n    fn display_streaming(\u0026self, text: \u0026str) -\u003e Result\u003c(), UIError\u003e {\n        self.streaming.lock().unwrap().push(text.to_string());\n        Ok(())\n    }\n}\n\n// Mock Explorer\n#[derive(Default)]\nstruct MockExplorer {\n    files: Arc\u003cMutex\u003cHashMap\u003cPathBuf, String\u003e\u003e\u003e,\n    file_tree: Arc\u003cMutex\u003cOption\u003cFileTreeEntry\u003e\u003e\u003e,\n}\n\nimpl MockExplorer {\n    pub fn new(files: HashMap\u003cPathBuf, String\u003e, file_tree: Option\u003cFileTreeEntry\u003e) -\u003e Self {\n        Self {\n            files: Arc::new(Mutex::new(files)),\n            file_tree: Arc::new(Mutex::new(file_tree)),\n        }\n    }\n}\n\nimpl CodeExplorer for MockExplorer {\n    fn root_dir(\u0026self) -\u003e PathBuf {\n        PathBuf::from(\"./root\")\n    }\n\n    fn read_file(\u0026self, path: \u0026PathBuf) -\u003e Result\u003cString, anyhow::Error\u003e {\n        self.files\n            .lock()\n            .unwrap()\n            .get(path)\n            .cloned()\n            .ok_or_else(|| anyhow::anyhow!(\"File not found: {}\", path.display()))\n    }\n\n    fn write_file(\u0026self, path: \u0026PathBuf, content: \u0026String) -\u003e Result\u003c()\u003e {\n        // Check parent directories\n        for component in path.parent().unwrap_or(path).components() {\n            let current = PathBuf::from(component.as_os_str());\n            if let Some(_) = self.files.lock().unwrap().get(\u0026current) {\n                // If any parent is a file (has content), that's an error\n                return Err(anyhow::anyhow!(\n                    \"Cannot create file: {} is a file\",\n                    current.display()\n                ));\n            }\n        }\n\n        let mut files = self.files.lock().unwrap();\n        files.insert(path.to_path_buf(), content.clone());\n        Ok(())\n    }\n\n    fn delete_file(\u0026self, path: \u0026PathBuf) -\u003e Result\u003c()\u003e {\n        let mut files = self.files.lock().unwrap();\n        files.remove(path);\n        Ok(())\n    }\n\n    fn create_initial_tree(\u0026mut self, _max_depth: usize) -\u003e Result\u003cFileTreeEntry, anyhow::Error\u003e {\n        self.file_tree\n            .lock()\n            .unwrap()\n            .clone()\n            .ok_or_else(|| anyhow::anyhow!(\"No file tree configured\"))\n    }\n\n    fn list_files(\n        \u0026mut self,\n        path: \u0026PathBuf,\n        _max_depth: Option\u003cusize\u003e,\n    ) -\u003e Result\u003cFileTreeEntry, anyhow::Error\u003e {\n        let file_tree = self.file_tree.lock().unwrap();\n        let root = file_tree\n            .as_ref()\n            .ok_or_else(|| anyhow::anyhow!(\"No file tree configured\"))?;\n\n        // Handle request for root\n        if path == \u0026PathBuf::from(\"./root\") {\n            return Ok(root.clone());\n        }\n\n        // Handle relative paths from root\n        if let Some(rel_path) = path.strip_prefix(\"./root/\").ok() {\n            let mut current = root;\n            for component in rel_path.components() {\n                if let Some(name) = component.as_os_str().to_str() {\n                    current = current\n                        .children\n                        .get(name)\n                        .ok_or_else(|| anyhow::anyhow!(\"Path not found: {}\", path.display()))?;\n                }\n            }\n            return Ok(current.clone());\n        }\n\n        // Handle paths without ./root prefix\n        let path_str = path\n            .to_str()\n            .ok_or_else(|| anyhow::anyhow!(\"Invalid path: {}\", path.display()))?;\n        let entry = root\n            .children\n            .get(path_str)\n            .ok_or_else(|| anyhow::anyhow!(\"Path not found: {}\", path.display()))?;\n\n        Ok(entry.clone())\n    }\n\n    fn apply_replacements(\u0026self, path: \u0026Path, replacements: \u0026[FileReplacement]) -\u003e Result\u003cString\u003e {\n        let mut files = self.files.lock().unwrap();\n\n        let content = files\n            .get(path)\n            .ok_or_else(|| anyhow::anyhow!(\"File not found: {}\", path.display()))?\n            .clone();\n\n        let updated_content = crate::utils::apply_replacements(\u0026content, replacements)?;\n\n        // Update the stored content\n        files.insert(path.to_path_buf(), updated_content.clone());\n\n        Ok(updated_content)\n    }\n\n    fn search(\n        \u0026self,\n        path: \u0026Path,\n        options: SearchOptions,\n    ) -\u003e Result\u003cVec\u003cSearchResult\u003e, anyhow::Error\u003e {\n        let files = self.files.lock().unwrap();\n        let max_results = options.max_results.unwrap_or(usize::MAX);\n        let mut results = Vec::new();\n\n        // Create regex based on search mode\n        let regex = match options.mode {\n            SearchMode::Exact =\u003e {\n                // For exact search, escape regex special characters and optionally add word boundaries\n                let pattern = if options.whole_words {\n                    format!(r\"\\b{}\\b\", regex::escape(\u0026options.query))\n                } else {\n                    regex::escape(\u0026options.query)\n                };\n                RegexBuilder::new(\u0026pattern)\n                    .case_insensitive(!options.case_sensitive)\n                    .build()?\n            }\n            SearchMode::Regex =\u003e {\n                // For regex search, optionally add word boundaries to user's pattern\n                let pattern = if options.whole_words {\n                    format!(r\"\\b{}\\b\", options.query)\n                } else {\n                    options.query.clone()\n                };\n                RegexBuilder::new(\u0026pattern)\n                    .case_insensitive(!options.case_sensitive)\n                    .build()?\n            }\n        };\n\n        for (file_path, content) in files.iter() {\n            // Only search files under the specified path\n            if !file_path.starts_with(path) {\n                continue;\n            }\n\n            for (line_idx, line) in content.lines().enumerate() {\n                let matches: Vec\u003c_\u003e = regex.find_iter(line).collect();\n                if !matches.is_empty() {\n                    let context_lines = 2;\n                    let start_line = line_idx.saturating_sub(context_lines);\n                    let section_end = (line_idx + context_lines + 1).min(content.lines().count());\n\n                    let mut section_lines = Vec::new();\n                    for i in start_line..section_end {\n                        section_lines.push(content.lines().nth(i).unwrap().to_string());\n                    }\n\n                    results.push(SearchResult {\n                        file: file_path.clone(),\n                        start_line,\n                        line_content: section_lines,\n                        match_lines: vec![line_idx - start_line],\n                        match_ranges: vec![matches.iter().map(|m| (m.start(), m.end())).collect()],\n                    });\n\n                    if results.len() \u003e= max_results {\n                        return Ok(results);\n                    }\n                }\n            }\n        }\n\n        Ok(results)\n    }\n}\n\n// Helper function to create a test response\nfn create_test_response(tool: Tool, reasoning: \u0026str) -\u003e LLMResponse {\n    let tool_name = match \u0026tool {\n        Tool::ListProjects { .. } =\u003e \"list_projects\",\n        Tool::OpenProject { .. } =\u003e \"open_project\",\n        Tool::SearchFiles { .. } =\u003e \"search_files\",\n        Tool::ExecuteCommand { .. } =\u003e \"execute_command\",\n        Tool::ListFiles { .. } =\u003e \"list_files\",\n        Tool::ReadFiles { .. } =\u003e \"read_files\",\n        Tool::WriteFile { .. } =\u003e \"write_file\",\n        Tool::ReplaceInFile { .. } =\u003e \"replace_in_file\",\n        Tool::DeleteFiles { .. } =\u003e \"delete_files\",\n        Tool::Summarize { .. } =\u003e \"summarize\",\n        Tool::AskUser { .. } =\u003e \"ask_user\",\n        Tool::MessageUser { .. } =\u003e \"message_user\",\n        Tool::CompleteTask { .. } =\u003e \"complete_task\",\n    };\n    let tool_input = match \u0026tool {\n        Tool::ListProjects {} =\u003e serde_json::json!({}),\n        Tool::OpenProject { name } =\u003e serde_json::json!({\n            \"name\": name\n        }),\n        Tool::SearchFiles {\n            query,\n            path,\n            case_sensitive,\n            whole_words,\n            regex_mode,\n            max_results,\n        } =\u003e serde_json::json!({\n            \"query\": query,\n            \"path\": path,\n            \"case_sensitive\": case_sensitive,\n            \"whole_words\": whole_words,\n            \"regex_mode\": regex_mode,\n            \"max_results\": max_results\n        }),\n        Tool::ExecuteCommand {\n            command_line,\n            working_dir,\n        } =\u003e serde_json::json!({\n            \"command_line\": command_line,\n            \"working_dir\": working_dir\n        }),\n        Tool::ListFiles { paths, max_depth } =\u003e {\n            let mut map = serde_json::Map::new();\n            map.insert(\"paths\".to_string(), serde_json::json!(paths));\n            if let Some(depth) = max_depth {\n                map.insert(\"max_depth\".to_string(), serde_json::json!(depth));\n            }\n            serde_json::Value::Object(map)\n        }\n        Tool::ReadFiles { paths } =\u003e serde_json::json!({\n            \"paths\": paths\n        }),\n        Tool::WriteFile { path, content } =\u003e serde_json::json!({\n            \"path\": path,\n            \"content\": content\n        }),\n        Tool::ReplaceInFile { path, replacements } =\u003e serde_json::json!({\n            \"path\": path,\n            \"replacements\": replacements\n        }),\n        Tool::DeleteFiles { paths } =\u003e serde_json::json!({\n            \"paths\": paths\n        }),\n        Tool::Summarize { files } =\u003e serde_json::json!({\n            \"files\": files.iter().map(|(path, summary)| {\n                serde_json::json!({\n                    \"path\": path,\n                    \"summary\": summary\n                })\n            }).collect::\u003cVec\u003c_\u003e\u003e()\n        }),\n        Tool::AskUser { question } =\u003e serde_json::json!({\n            \"question\": question\n        }),\n        Tool::MessageUser { message } =\u003e serde_json::json!({\n            \"message\": message\n        }),\n        Tool::CompleteTask { message } =\u003e serde_json::json!({\n            \"message\": message\n        }),\n    };\n\n    LLMResponse {\n        content: vec![\n            ContentBlock::Text {\n                text: reasoning.to_string(),\n            },\n            ContentBlock::ToolUse {\n                id: \"some-tool-id\".to_string(),\n                name: tool_name.to_string(),\n                input: tool_input,\n            },\n        ],\n        usage: Usage {\n            input_tokens: 0,\n            output_tokens: 0,\n        },\n    }\n}\n\nfn create_explorer_mock() -\u003e MockExplorer {\n    let mut files = HashMap::new();\n    files.insert(\n        PathBuf::from(\"./root/test.txt\"),\n        \"line 1\\nline 2\\nline 3\\n\".to_string(),\n    );\n\n    // Add src directory to tree\n    let mut root_children = HashMap::new();\n    root_children.insert(\n        \"src\".to_string(),\n        FileTreeEntry {\n            name: \"src\".to_string(),\n            entry_type: FileSystemEntryType::Directory,\n            children: HashMap::new(),\n            is_expanded: true,\n        },\n    );\n\n    let file_tree = Some(FileTreeEntry {\n        name: \"./root\".to_string(),\n        entry_type: FileSystemEntryType::Directory,\n        children: root_children,\n        is_expanded: true,\n    });\n\n    MockExplorer::new(files, file_tree)\n}\n\nfn create_command_executor_mock() -\u003e MockCommandExecutor {\n    MockCommandExecutor::new(vec![])\n}\n\n#[test]\nfn test_mock_explorer_search() -\u003e Result\u003c(), anyhow::Error\u003e {\n    let mut files = HashMap::new();\n    files.insert(\n        PathBuf::from(\"./root/test1.txt\"),\n        \"line 1\\nline 2\\nline 3\\n\".to_string(),\n    );\n    files.insert(\n        PathBuf::from(\"./root/test2.txt\"),\n        \"another line\\nmatching line\\n\".to_string(),\n    );\n    files.insert(\n        PathBuf::from(\"./root/subdir/test3.txt\"),\n        \"subdir line\\nmatching line\\n\".to_string(),\n    );\n\n    let explorer = MockExplorer::new(files, None);\n\n    // Test basic search\n    let results = explorer.search(\n        \u0026PathBuf::from(\"./root\"),\n        SearchOptions {\n            query: \"matching\".to_string(),\n            ..Default::default()\n        },\n    )?;\n    assert_eq!(results.len(), 2);\n    assert!(results.iter().any(|r| r.file.ends_with(\"test2.txt\")));\n    assert!(results.iter().any(|r| r.file.ends_with(\"test3.txt\")));\n\n    // Test case-sensitive search\n    let results = explorer.search(\n        \u0026PathBuf::from(\"./root\"),\n        SearchOptions {\n            query: \"LINE\".to_string(),\n            case_sensitive: true,\n            ..Default::default()\n        },\n    )?;\n    assert_eq!(results.len(), 0); // Should find nothing with case-sensitive search\n\n    // Test case-insensitive search\n    let results = explorer.search(\n        \u0026PathBuf::from(\"./root\"),\n        SearchOptions {\n            query: \"LINE\".to_string(),\n            case_sensitive: false,\n            ..Default::default()\n        },\n    )?;\n    assert!(results.len() \u003e 0); // Should find matches\n\n    // Test whole word search\n    let results = explorer.search(\n        \u0026PathBuf::from(\"./root\"),\n        SearchOptions {\n            query: \"line\".to_string(),\n            whole_words: true,\n            ..Default::default()\n        },\n    )?;\n    // When searching for whole words, matches should not be part of other words\n    assert!(results.iter().all(|r| {\n        r.line_content.iter().all(|line| {\n            // Check that \"line\" is not part of another word\n            !line.contains(\u0026\"inline\".to_string())\n                \u0026\u0026 !line.contains(\u0026\"pipeline\".to_string())\n                \u0026\u0026 !line.contains(\u0026\"airline\".to_string())\n        })\n    }));\n\n    // Test regex mode\n    let results = explorer.search(\n        \u0026PathBuf::from(\"./root\"),\n        SearchOptions {\n            query: r\"line \\d\".to_string(),\n            mode: SearchMode::Regex,\n            ..Default::default()\n        },\n    )?;\n    assert!(results.iter().any(|r| r\n        .line_content\n        .iter()\n        .any(|line| line.contains(\u0026\"line 1\".to_string()))));\n\n    // Test regex search\n    let results = explorer.search(\n        \u0026PathBuf::from(\"./root\"),\n        SearchOptions {\n            query: r\"line \\d+\".to_string(), // Match \"line\" followed by numbers\n            mode: SearchMode::Regex,\n            ..Default::default()\n        },\n    )?;\n    assert!(results.iter().any(|r| r\n        .line_content\n        .iter()\n        .any(|line| line.contains(\u0026\"line 1\".to_string()))));\n\n    // Test with max_results\n    let results = explorer.search(\n        \u0026PathBuf::from(\"./root\"),\n        SearchOptions {\n            query: \"line\".to_string(),\n            max_results: Some(2),\n            ..Default::default()\n        },\n    )?;\n    assert_eq!(results.len(), 2);\n\n    // Test search in subdirectory\n    let results = explorer.search(\n        \u0026PathBuf::from(\"./root/subdir\"),\n        SearchOptions {\n            query: \"subdir\".to_string(),\n            ..Default::default()\n        },\n    )?;\n    assert_eq!(results.len(), 1);\n    assert!(results[0].file.ends_with(\"test3.txt\"));\n\n    // Test search with no matches\n    let results = explorer.search(\n        \u0026PathBuf::from(\"./root\"),\n        SearchOptions {\n            query: \"nonexistent\".to_string(),\n            ..Default::default()\n        },\n    )?;\n    assert_eq!(results.len(), 0);\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_agent_start_with_message() -\u003e Result\u003c(), anyhow::Error\u003e {\n    // Prepare test data\n    let test_message = \"Test message for user\";\n    let test_reasoning = \"Dummy reason\";\n    let tool = Tool::MessageUser {\n        message: test_message.to_string(),\n    };\n\n    let mock_llm = MockLLMProvider::new(vec![Ok(create_test_response(tool, test_reasoning))]);\n\n    let mock_ui = MockUI::default();\n\n    let mut agent = Agent::new(\n        Box::new(mock_llm),\n        ToolMode::Native,\n        Box::new(create_explorer_mock()),\n        Box::new(create_command_executor_mock()),\n        Box::new(mock_ui.clone()),\n        Box::new(MockStatePersistence::new()),\n    );\n\n    // Run the agent\n    agent.start_with_task(\"Test task\".to_string()).await?;\n\n    // Verify the message was displayed\n    let messages = mock_ui.get_messages();\n    assert!(!messages.is_empty());\n\n    // First message is about creating repository structure\n    if let UIMessage::Reasoning(msg) = \u0026messages[1] {\n        assert!(msg.contains(test_reasoning));\n    } else {\n        panic!(\"Expected UIMessage::Reasoning\");\n    }\n\n    if let UIMessage::Action(msg) = \u0026messages[2] {\n        assert!(msg.contains(test_message));\n    } else {\n        panic!(\"Expected UIMessage::Action\");\n    }\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_agent_ask_user() -\u003e Result\u003c(), anyhow::Error\u003e {\n    // Prepare test data\n    let test_question = \"Test question?\";\n    let test_answer = \"Test answer\";\n\n    let mock_llm = MockLLMProvider::new(vec![Ok(create_test_response(\n        Tool::AskUser {\n            question: test_question.to_string(),\n        },\n        \"Need to ask user a question\",\n    ))]);\n\n    let mock_ui = MockUI::new(vec![Ok(test_answer.to_string())]);\n\n    let mut agent = Agent::new(\n        Box::new(mock_llm),\n        ToolMode::Native,\n        Box::new(create_explorer_mock()),\n        Box::new(create_command_executor_mock()),\n        Box::new(mock_ui.clone()),\n        Box::new(MockStatePersistence::new()),\n    );\n\n    // Run the agent\n    agent.start_with_task(\"Test task\".to_string()).await?;\n\n    // Verify the question was asked\n    let messages = mock_ui.get_messages();\n    assert!(messages.iter().any(|msg| match msg {\n        UIMessage::Question(q) =\u003e q == test_question,\n        _ =\u003e false,\n    }));\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_agent_read_files() -\u003e Result\u003c(), anyhow::Error\u003e {\n    // Test success case\n    let mock_llm = MockLLMProvider::new(vec![\n        // Responses in reverse order\n        Ok(create_test_response(\n            Tool::MessageUser {\n                message: (String::from(\"Done\")),\n            },\n            \"Dummy reason\",\n        )),\n        Ok(create_test_response(\n            Tool::ReadFiles {\n                paths: vec![PathBuf::from(\"test.txt\")],\n            },\n            \"Reading test file\",\n        )),\n    ]);\n    // Obtain a reference to the mock_llm before handing ownership to the agent\n    let mock_llm_ref = mock_llm.clone();\n\n    let mut agent = Agent::new(\n        Box::new(mock_llm),\n        ToolMode::Native,\n        Box::new(create_explorer_mock()),\n        Box::new(create_command_executor_mock()),\n        Box::new(MockUI::default()),\n        Box::new(MockStatePersistence::new()),\n    );\n\n    // Run the agent\n    agent.start_with_task(\"Test task\".to_string()).await?;\n\n    // Verify the file is displayed in the working memory of the second request\n    let locked_requests = mock_llm_ref.requests.lock().unwrap();\n    let second_request = \u0026locked_requests[1];\n\n    if let MessageContent::Text(content) = \u0026second_request.messages[0].content {\n        assert!(\n            content.contains(\n                \"Loaded files and their contents:\\n\\n-----test.txt:\\nline 1\\nline 2\\nline 3\\n\"\n            ),\n            \"File content not found in working memory message:\\n{}\",\n            content\n        );\n    } else {\n        panic!(\"Expected text content in message\");\n    }\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_execute_command() -\u003e Result\u003c()\u003e {\n    let test_output = CommandOutput {\n        success: true,\n        stdout: \"command output\".to_string(),\n        stderr: \"\".to_string(),\n    };\n\n    let mock_command_executor = MockCommandExecutor::new(vec![Ok(test_output)]);\n    let mock_command_executor_ref = mock_command_executor.clone();\n\n    let mock_llm = MockLLMProvider::new(vec![Ok(create_test_response(\n        Tool::ExecuteCommand {\n            command_line: \"test command\".to_string(),\n            working_dir: None,\n        },\n        \"Testing command execution\",\n    ))]);\n\n    let mut agent = Agent::new(\n        Box::new(mock_llm),\n        ToolMode::Native,\n        Box::new(create_explorer_mock()),\n        Box::new(mock_command_executor),\n        Box::new(MockUI::default()),\n        Box::new(MockStatePersistence::new()),\n    );\n\n    // Run the agent\n    agent.start_with_task(\"Test task\".to_string()).await?;\n\n    // Verify number of calls and command parameters\n    assert_eq!(mock_command_executor_ref.calls.load(Ordering::Relaxed), 1);\n\n    let captured_commands = mock_command_executor_ref.get_captured_commands();\n    assert_eq!(captured_commands.len(), 1);\n    assert_eq!(captured_commands[0].0, \"test command\");\n    assert_eq!(\n        captured_commands[0].1.as_ref().map(|p| p.to_str().unwrap()),\n        Some(\"./root\")\n    );\n\n    Ok(())\n}\n\n#[test]\nfn test_flexible_xml_parsing() -\u003e Result\u003c()\u003e {\n    let response = LLMResponse {\n        content: vec![ContentBlock::Text {\n            text: r#\"I will search for TODO comments in the code.\n\n\u003ctool:search_files\u003e\n\u003cparam:query\u003eTODO \u0026 FIXME \u003chtml\u003e\u003c/param:query\u003e\n\u003cparam:path\u003esrc/\u003c/param:path\u003e\n\u003cparam:case_sensitive\u003etrue\u003c/param:case_sensitive\u003e\n\u003cparam:max_results\u003e\n    50\n\u003c/param:max_results\u003e\n\u003c/tool:search_files\u003e\"#\n                .to_string(),\n        }],\n        usage: Usage {\n            input_tokens: 0,\n            output_tokens: 0,\n        },\n    };\n\n    let actions = parse_llm_response(\u0026response)?;\n    assert_eq!(actions.len(), 1);\n    assert!(actions[0].reasoning.contains(\"search for TODO comments\"));\n\n    if let Tool::SearchFiles {\n        query, max_results, ..\n    } = \u0026actions[0].tool\n    {\n        assert_eq!(query, \"TODO \u0026 FIXME \u003chtml\u003e\"); // Notice the \u0026 character is allowed and also tags\n        assert_eq!(*max_results, Some(50));\n    } else {\n        panic!(\"Expected Search tool\");\n    }\n\n    Ok(())\n}\n\n#[test]\nfn test_replacement_xml_parsing() -\u003e Result\u003c()\u003e {\n    let response = LLMResponse {\n        content: vec![ContentBlock::Text {\n            text: r#\"I will fix the code formatting.\n\n\u003ctool:replace_in_file\u003e\n\u003cparam:path\u003esrc/main.rs\u003c/param:path\u003e\n\u003cparam:diff\u003e\n\u003c\u003c\u003c\u003c\u003c\u003c\u003c SEARCH\nfunction test(){\n  console.log(\"messy\");\n}\n=======\nfunction test() {\n    console.log(\"clean\");\n}\n\u003e\u003e\u003e\u003e\u003e\u003e\u003e REPLACE\n\n\u003c\u003c\u003c\u003c\u003c\u003c\u003c SEARCH\nconst x=42\n=======\nconst x = 42;\n\u003e\u003e\u003e\u003e\u003e\u003e\u003e REPLACE\n\u003c/param:diff\u003e\n\u003c/tool:replace_in_file\u003e\"#\n                .to_string(),\n        }],\n        usage: Usage {\n            input_tokens: 0,\n            output_tokens: 0,\n        },\n    };\n\n    let actions = parse_llm_response(\u0026response)?;\n    assert_eq!(actions.len(), 1);\n    assert!(actions[0].reasoning.contains(\"fix the code formatting\"));\n\n    if let Tool::ReplaceInFile { path, replacements } = \u0026actions[0].tool {\n        assert_eq!(path, \u0026PathBuf::from(\"src/main.rs\"));\n        assert_eq!(replacements.len(), 2);\n        assert_eq!(\n            replacements[0].search,\n            \"function test(){\\n  console.log(\\\"messy\\\");\\n}\"\n        );\n        assert_eq!(\n            replacements[0].replace,\n            \"function test() {\\n    console.log(\\\"clean\\\");\\n}\"\n        );\n        assert_eq!(replacements[1].search, \"const x=42\");\n        assert_eq!(replacements[1].replace, \"const x = 42;\");\n    } else {\n        panic!(\"Expected ReplaceInFile tool\");\n    }\n\n    Ok(())\n}\n\n#[test]\nfn test_apply_replacements() -\u003e Result\u003c(), anyhow::Error\u003e {\n    let mut files = HashMap::new();\n    files.insert(\n        PathBuf::from(\"./root/test.txt\"),\n        \"Hello World\\nThis is a test\\nGoodbye\".to_string(),\n    );\n\n    let explorer = MockExplorer::new(files, None);\n\n    let replacements = vec![\n        FileReplacement {\n            search: \"Hello World\".to_string(),\n            replace: \"Hi there\".to_string(),\n        },\n        FileReplacement {\n            search: \"Goodbye\".to_string(),\n            replace: \"See you\".to_string(),\n        },\n    ];\n\n    let result = explorer.apply_replacements(\u0026PathBuf::from(\"./root/test.txt\"), \u0026replacements)?;\n\n    assert_eq!(result, \"Hi there\\nThis is a test\\nSee you\");\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_replace_in_file_error_handling() -\u003e Result\u003c()\u003e {\n    // Setup a scenario where a file replacement fails first (wrong search string),\n    // then succeeds with corrected search string\n    let initial_content = \"function test() {\\n    console.log(\\\"test\\\");\\n}\\n\";\n\n    // First a read action to get the file into working memory\n    let mock_llm = MockLLMProvider::new(vec![\n        Ok(create_test_response(\n            Tool::ReplaceInFile {\n                path: PathBuf::from(\"test.rs\"),\n                replacements: vec![FileReplacement {\n                    search: \"function test()\".to_string(), // correct\n                    replace: \"fn test()\".to_string(),\n                }],\n            },\n            \"Trying with correct search string\",\n        )),\n        Ok(create_test_response(\n            Tool::ReplaceInFile {\n                path: PathBuf::from(\"test.rs\"),\n                replacements: vec![FileReplacement {\n                    search: \"wrong search\".to_string(), // will fail\n                    replace: \"fn test()\".to_string(),\n                }],\n            },\n            \"Initial attempt to replace\",\n        )),\n        Ok(create_test_response(\n            Tool::ReadFiles {\n                paths: vec![PathBuf::from(\"test.rs\")],\n            },\n            \"Reading test file\",\n        )),\n    ]);\n    let mock_llm_ref = mock_llm.clone();\n\n    // File exists and has content\n    let mock_explorer = MockExplorer::new(\n        HashMap::from([(PathBuf::from(\"./root/test.rs\"), initial_content.to_string())]),\n        Some(FileTreeEntry {\n            name: \"./root\".to_string(),\n            entry_type: FileSystemEntryType::Directory,\n            children: HashMap::new(),\n            is_expanded: true,\n        }),\n    );\n\n    let mut agent = Agent::new(\n        Box::new(mock_llm),\n        ToolMode::Native,\n        Box::new(mock_explorer),\n        Box::new(create_command_executor_mock()),\n        Box::new(MockUI::default()),\n        Box::new(MockStatePersistence::new()),\n    );\n\n    // Run the agent\n    agent\n        .start_with_task(\"Convert JavaScript function to Rust\".to_string())\n        .await?;\n\n    // Check that error was communicated to LLM\n    let requests = mock_llm_ref.requests.lock().unwrap();\n\n    // Should see four requests:\n    // 1. Initial ReadFiles\n    // 2. Failed ReplaceInFile\n    // 3. Corrected ReplaceInFile\n    // 4. CompleteTask\n    assert_eq!(requests.len(), 4);\n\n    // The error message should be a user message in the third request\n    let error_request = \u0026requests[2];\n    assert_eq!(error_request.messages.len(), 3); // Working Memory + Tool Response + Error\n    if let MessageContent::Text(content) = \u0026error_request.messages[2].content {\n        assert!(\n            content.contains(\"Could not find search content\"),\n            \"Expected error message about missing search content, got:\\n{}\",\n            content\n        );\n    } else {\n        panic!(\"Expected error message to be text content\");\n    }\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_list_files_error_handling() -\u003e Result\u003c()\u003e {\n    let mock_llm = MockLLMProvider::new(vec![\n        Ok(create_test_response(\n            Tool::ListFiles {\n                paths: vec![PathBuf::from(\"src\")],\n                max_depth: None,\n            },\n            \"Listing files with correct path\",\n        )),\n        Ok(create_test_response(\n            Tool::ListFiles {\n                paths: vec![PathBuf::from(\"nonexistent\")],\n                max_depth: None,\n            },\n            \"Initial attempt to list files\",\n        )),\n    ]);\n    let mock_llm_ref = mock_llm.clone();\n\n    let mut agent = Agent::new(\n        Box::new(mock_llm),\n        ToolMode::Native,\n        Box::new(create_explorer_mock()),\n        Box::new(create_command_executor_mock()),\n        Box::new(MockUI::default()),\n        Box::new(MockStatePersistence::new()),\n    );\n\n    agent\n        .start_with_task(\"List project files\".to_string())\n        .await?;\n\n    let requests = mock_llm_ref.requests.lock().unwrap();\n\n    // Should see three requests:\n    // 1. Failed ListFiles\n    // 2. Corrected ListFiles\n    // 3. CompleteTask\n    assert_eq!(requests.len(), 3);\n\n    // The error message should be a user message in the second request\n    let error_request = \u0026requests[1];\n    assert_eq!(error_request.messages.len(), 3); // Working Memory + Tool Response + Error\n    if let MessageContent::Text(content) = \u0026error_request.messages[2].content {\n        println!(\"{}\", content);\n        assert!(content.contains(\"Error executing action\"));\n        assert!(content.contains(\"Path not found\"));\n    }\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_read_files_error_handling() -\u003e Result\u003c()\u003e {\n    let mock_llm = MockLLMProvider::new(vec![\n        Ok(create_test_response(\n            Tool::ReadFiles {\n                paths: vec![PathBuf::from(\"test.txt\")],\n            },\n            \"Reading existing file\",\n        )),\n        Ok(create_test_response(\n            Tool::ReadFiles {\n                paths: vec![PathBuf::from(\"nonexistent.txt\")],\n            },\n            \"Attempting to read non-existent file\",\n        )),\n    ]);\n    let mock_llm_ref = mock_llm.clone();\n\n    let mut agent = Agent::new(\n        Box::new(mock_llm),\n        ToolMode::Native,\n        Box::new(create_explorer_mock()),\n        Box::new(create_command_executor_mock()),\n        Box::new(MockUI::default()),\n        Box::new(MockStatePersistence::new()),\n    );\n\n    agent\n        .start_with_task(\"Read file contents\".to_string())\n        .await?;\n\n    let requests = mock_llm_ref.requests.lock().unwrap();\n\n    // Should see three requests:\n    // 1. Failed ReadFiles\n    // 2. Corrected ReadFiles\n    // 3. CompleteTask\n    assert_eq!(requests.len(), 3);\n\n    // The error message should be a user message in the second request\n    let error_request = \u0026requests[1];\n    assert_eq!(error_request.messages.len(), 3); // Working Memory + Tool Response + Error\n    if let MessageContent::Text(content) = \u0026error_request.messages[2].content {\n        assert!(content.contains(\"Error executing action\"));\n        assert!(content.contains(\"File not found\"));\n    }\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_write_file_error_handling() -\u003e Result\u003c()\u003e {\n    let mock_llm = MockLLMProvider::new(vec![\n        Ok(create_test_response(\n            Tool::WriteFile {\n                path: PathBuf::from(\"test.txt\"),\n                content: \"valid content\".to_string(),\n            },\n            \"Writing to valid path\",\n        )),\n        Ok(create_test_response(\n            Tool::WriteFile {\n                path: PathBuf::from(\"/invalid/path/test.txt\"),\n                content: \"test content\".to_string(),\n            },\n            \"Attempting to write to invalid absolute path\",\n        )),\n    ]);\n    let mock_llm_ref = mock_llm.clone();\n\n    let mut agent = Agent::new(\n        Box::new(mock_llm),\n        ToolMode::Native,\n        Box::new(create_explorer_mock()),\n        Box::new(create_command_executor_mock()),\n        Box::new(MockUI::default()),\n        Box::new(MockStatePersistence::new()),\n    );\n\n    agent\n        .start_with_task(\"Write file contents\".to_string())\n        .await?;\n\n    let requests = mock_llm_ref.requests.lock().unwrap();\n\n    // Should see three requests:\n    // 1. Failed WriteFile\n    // 2. Corrected WriteFile\n    // 3. CompleteTask\n    assert_eq!(requests.len(), 3);\n\n    // The error message should be a user message in the second request\n    let error_request = \u0026requests[1];\n    assert_eq!(error_request.messages.len(), 3); // Working Memory + Tool Response + Error\n    if let MessageContent::Text(content) = \u0026error_request.messages[2].content {\n        assert!(content.contains(\"Error executing action\"));\n        assert!(content.contains(\"absolute path\"));\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","stippi","projects","code-assistant","src","config.rs"],"content":"use crate::types::Project;\nuse anyhow::Result;\nuse std::collections::HashMap;\nuse std::path::PathBuf;\n\npub fn get_config_path() -\u003e Result\u003cPathBuf\u003e {\n    let home =\n        dirs::home_dir().ok_or_else(|| anyhow::anyhow!(\"Could not determine home directory\"))?;\n    Ok(home.join(\".code-assistant\").join(\"projects.json\"))\n}\n\npub fn load_projects() -\u003e Result\u003cHashMap\u003cString, Project\u003e\u003e {\n    let config_path = get_config_path()?;\n    if !config_path.exists() {\n        return Ok(HashMap::new());\n    }\n    let content = std::fs::read_to_string(config_path)?;\n    Ok(serde_json::from_str(\u0026content)?)\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","Users","stippi","projects","code-assistant","src","explorer.rs"],"content":"use crate::types::{\n    CodeExplorer, FileReplacement, FileSystemEntryType, FileTreeEntry, SearchMode, SearchOptions,\n    SearchResult,\n};\nuse anyhow::Result;\nuse ignore::WalkBuilder;\nuse regex::RegexBuilder;\nuse std::collections::{HashMap, HashSet};\n// Removed unused imports\nuse std::path::{Path, PathBuf};\nuse tracing::debug;\n\n/// Handles file system operations for code exploration\npub struct Explorer {\n    root_dir: PathBuf,\n    // Track which paths were explicitly listed\n    expanded_paths: HashSet\u003cPathBuf\u003e,\n}\n\nimpl FileTreeEntry {\n    /// Converts the file tree to a readable string representation\n    pub fn to_string(\u0026self) -\u003e String {\n        self.to_string_with_indent(0, \"\")\n    }\n\n    fn to_string_with_indent(\u0026self, level: usize, prefix: \u0026str) -\u003e String {\n        let mut result = String::new();\n\n        // Root level doesn't get a prefix\n        if level == 0 {\n            result.push_str(\u0026format!(\"{}/\\n\", self.name));\n        } else {\n            result.push_str(prefix);\n            result.push_str(\u0026self.name);\n\n            match self.entry_type {\n                FileSystemEntryType::Directory =\u003e {\n                    result.push('/');\n                    // Add [...] for unexpanded directories that aren't empty\n                    if !self.is_expanded {\n                        result.push_str(\" [...]\");\n                    }\n                }\n                FileSystemEntryType::File =\u003e {}\n            }\n            result.push('\\n');\n        }\n\n        // Only show children if this directory is expanded\n        if matches!(self.entry_type, FileSystemEntryType::Directory) \u0026\u0026 self.is_expanded {\n            // Sort children: directories first, then files, both alphabetically\n            let mut sorted_children: Vec\u003c_\u003e = self.children.values().collect();\n            sorted_children.sort_by_key(|entry| {\n                (\n                    matches!(entry.entry_type, FileSystemEntryType::File),\n                    \u0026entry.name,\n                )\n            });\n\n            // Add children\n            let child_count = sorted_children.len();\n            for (i, child) in sorted_children.iter().enumerate() {\n                let is_last = i == child_count - 1;\n\n                // Construct the prefix for this child\n                let child_prefix = if level == 0 {\n                    if is_last {\n                        format!(\"└─ \")\n                    } else {\n                        format!(\"├─ \")\n                    }\n                } else {\n                    if is_last {\n                        format!(\"{}└─ \", prefix.replace(\"├─ \", \"│  \").replace(\"└─ \", \"   \"))\n                    } else {\n                        format!(\"{}├─ \", prefix.replace(\"├─ \", \"│  \").replace(\"└─ \", \"   \"))\n                    }\n                };\n\n                result.push_str(\u0026child.to_string_with_indent(level + 1, \u0026child_prefix));\n            }\n        }\n\n        result\n    }\n}\n\nimpl Explorer {\n    /// Creates a new Explorer instance\n    ///\n    /// # Arguments\n    /// * `root_dir` - The root directory to explore\n    pub fn new(root_dir: PathBuf) -\u003e Self {\n        Self {\n            root_dir,\n            expanded_paths: HashSet::new(),\n        }\n    }\n\n    fn expand_directory(\n        \u0026mut self,\n        path: \u0026Path,\n        entry: \u0026mut FileTreeEntry,\n        current_depth: usize,\n        max_depth: usize,\n    ) -\u003e Result\u003c()\u003e {\n        // Expand if either:\n        // - Within max_depth during initial load\n        // - The path was explicitly listed before\n        let should_expand = current_depth \u003c max_depth || self.expanded_paths.contains(path);\n\n        if !should_expand {\n            entry.is_expanded = false;\n            return Ok(());\n        }\n\n        let default_ignore = [\n            \"target\",\n            \"node_modules\",\n            \"build\",\n            \"dist\",\n            \".git\",\n            \".idea\",\n            \".vscode\",\n            \"*.pyc\",\n            \"*.pyo\",\n            \"*.class\",\n            \".DS_Store\",\n            \"Thumbs.db\",\n        ];\n\n        let walker = WalkBuilder::new(path)\n            .max_depth(Some(1)) // Only immediate children\n            .hidden(false)\n            .git_ignore(true)\n            .filter_entry(move |e| {\n                let file_name = e.file_name().to_string_lossy();\n                !default_ignore\n                    .iter()\n                    .any(|pattern| match glob::Pattern::new(pattern) {\n                        Ok(pat) =\u003e pat.matches(\u0026file_name),\n                        Err(_) =\u003e file_name.contains(pattern),\n                    })\n            })\n            .build();\n\n        for result in walker {\n            let dir_entry = result?;\n            let entry_path = dir_entry.path();\n\n            // Skip the directory itself\n            if entry_path == path {\n                continue;\n            }\n\n            let name = entry_path\n                .file_name()\n                .and_then(|n| n.to_str())\n                .unwrap_or(\"\")\n                .to_string();\n\n            let is_dir = entry_path.is_dir();\n            let mut child_entry = FileTreeEntry {\n                name,\n                entry_type: if is_dir {\n                    FileSystemEntryType::Directory\n                } else {\n                    FileSystemEntryType::File\n                },\n                children: HashMap::new(),\n                is_expanded: false,\n            };\n\n            if is_dir {\n                self.expand_directory(entry_path, \u0026mut child_entry, current_depth + 1, max_depth)?;\n            }\n\n            entry.children.insert(child_entry.name.clone(), child_entry);\n        }\n\n        entry.is_expanded = true;\n        Ok(())\n    }\n}\n\nimpl CodeExplorer for Explorer {\n    fn root_dir(\u0026self) -\u003e PathBuf {\n        self.root_dir.clone()\n    }\n\n    fn create_initial_tree(\u0026mut self, max_depth: usize) -\u003e Result\u003cFileTreeEntry\u003e {\n        let mut root = FileTreeEntry {\n            name: self\n                .root_dir\n                .file_name()\n                .and_then(|n| n.to_str())\n                .unwrap_or(\"root\")\n                .to_string(),\n            entry_type: FileSystemEntryType::Directory,\n            children: HashMap::new(),\n            is_expanded: true, // Root is always expanded\n        };\n\n        let root_dir = \u0026self.root_dir.clone();\n        self.expand_directory(\u0026root_dir, \u0026mut root, 0, max_depth)?;\n        Ok(root)\n    }\n\n    fn read_file(\u0026self, path: \u0026PathBuf) -\u003e Result\u003cString\u003e {\n        debug!(\"Reading file: {}\", path.display());\n        Ok(std::fs::read_to_string(path)?)\n    }\n\n    fn write_file(\u0026self, path: \u0026PathBuf, content: \u0026String) -\u003e Result\u003c()\u003e {\n        debug!(\"Writing file: {}\", path.display());\n        // Ensure the parent directory exists\n        if let Some(parent) = path.parent() {\n            std::fs::create_dir_all(parent)?;\n        }\n        Ok(std::fs::write(path, content)?)\n    }\n\n    fn delete_file(\u0026self, path: \u0026PathBuf) -\u003e Result\u003c()\u003e {\n        std::fs::remove_file(path)?;\n        Ok(())\n    }\n\n    fn list_files(\u0026mut self, path: \u0026PathBuf, max_depth: Option\u003cusize\u003e) -\u003e Result\u003cFileTreeEntry\u003e {\n        // Remember that this path was explicitly listed\n        self.expanded_paths.insert(path.clone());\n\n        let mut entry = FileTreeEntry {\n            name: path\n                .file_name()\n                .and_then(|n| n.to_str())\n                .unwrap_or(\"\")\n                .to_string(),\n            entry_type: if path.is_dir() {\n                FileSystemEntryType::Directory\n            } else {\n                FileSystemEntryType::File\n            },\n            children: HashMap::new(),\n            is_expanded: true,\n        };\n\n        if path.is_dir() {\n            self.expand_directory(\n                path.as_path(),\n                \u0026mut entry,\n                0,\n                max_depth.unwrap_or(usize::MAX),\n            )?;\n        }\n\n        Ok(entry)\n    }\n\n    fn apply_replacements(\u0026self, path: \u0026Path, replacements: \u0026[FileReplacement]) -\u003e Result\u003cString\u003e {\n        let content = std::fs::read_to_string(path)?;\n        let updated_content = crate::utils::apply_replacements(\u0026content, replacements)?;\n        std::fs::write(path, \u0026updated_content)?;\n        Ok(updated_content)\n    }\n\n    fn search(\u0026self, path: \u0026Path, options: SearchOptions) -\u003e Result\u003cVec\u003cSearchResult\u003e\u003e {\n        let mut results = Vec::new();\n        let max_results = options.max_results.unwrap_or(usize::MAX);\n        let context_lines = 2; // Lines of context before and after\n\n        // Prepare regex for different search modes\n        let regex = match options.mode {\n            SearchMode::Exact =\u003e {\n                let pattern = if options.whole_words {\n                    format!(r\"\\b{}\\b\", regex::escape(\u0026options.query))\n                } else {\n                    regex::escape(\u0026options.query)\n                };\n                RegexBuilder::new(\u0026pattern)\n                    .case_insensitive(!options.case_sensitive)\n                    .build()?\n            }\n            SearchMode::Regex =\u003e {\n                let pattern = if options.whole_words {\n                    format!(r\"\\b{}\\b\", options.query)\n                } else {\n                    options.query.clone()\n                };\n                RegexBuilder::new(\u0026pattern)\n                    .case_insensitive(!options.case_sensitive)\n                    .build()?\n            }\n        };\n\n        let walker = WalkBuilder::new(path)\n            .hidden(false)\n            .git_ignore(true)\n            .build();\n\n        for entry in walker {\n            let entry = entry?;\n            let path = entry.path();\n\n            // Skip directories and non-text files\n            if path.is_dir() || !is_text_file(path) {\n                continue;\n            }\n\n            // Read entire file at once for context lines\n            let content = std::fs::read_to_string(path)?;\n            let lines: Vec\u003c_\u003e = content.lines().collect();\n            let mut current_section: Option\u003cSearchResult\u003e = None;\n\n            for (line_idx, line) in lines.iter().enumerate() {\n                let matches: Vec\u003c_\u003e = regex.find_iter(line).collect();\n                \n                if !matches.is_empty() {\n                    let match_ranges: Vec\u003c_\u003e = matches.iter().map(|m| (m.start(), m.end())).collect();\n                    let section_start = line_idx.saturating_sub(context_lines);\n                    let section_end = (line_idx + context_lines + 1).min(lines.len());\n                    \n                    match \u0026mut current_section {\n                        // Extend section if close enough to previous match\n                        Some(section) if line_idx \u003c= section.start_line + section.line_content.len() + context_lines =\u003e {\n                            while section.line_content.len() \u003c section_end - section.start_line {\n                                section.line_content.push(\n                                    lines[section.start_line + section.line_content.len()].to_string()\n                                );\n                            }\n                            section.match_lines.push(line_idx - section.start_line);\n                            section.match_ranges.push(match_ranges);\n                        }\n                        _ =\u003e {\n                            // Start new section\n                            if let Some(section) = current_section.take() {\n                                results.push(section);\n                                if results.len() \u003e= max_results {\n                                    return Ok(results);\n                                }\n                            }\n                            \n                            let mut section_lines = Vec::new();\n                            for i in section_start..section_end {\n                                section_lines.push(lines[i].to_string());\n                            }\n                            \n                            current_section = Some(SearchResult {\n                                file: path.to_path_buf(),\n                                start_line: section_start,\n                                line_content: section_lines,\n                                match_lines: vec![line_idx - section_start],\n                                match_ranges: vec![match_ranges],\n                            });\n                        }\n                    }\n                }\n            }\n            \n            // Add final section if we have one\n            if let Some(section) = current_section {\n                results.push(section);\n                if results.len() \u003e= max_results {\n                    return Ok(results);\n                }\n            }\n        }\n\n        Ok(results)\n    }\n}\n\n/// Helper function to determine if a file is likely to be a text file\nfn is_text_file(path: \u0026Path) -\u003e bool {\n    let text_extensions = [\n        \"txt\",\n        \"md\",\n        \"rs\",\n        \"js\",\n        \"py\",\n        \"java\",\n        \"c\",\n        \"cpp\",\n        \"h\",\n        \"hpp\",\n        \"css\",\n        \"html\",\n        \"xml\",\n        \"json\",\n        \"yaml\",\n        \"yml\",\n        \"toml\",\n        \"sh\",\n        \"bash\",\n        \"zsh\",\n        \"fish\",\n        \"conf\",\n        \"cfg\",\n        \"ini\",\n        \"properties\",\n        \"env\",\n    ];\n\n    path.extension()\n        .and_then(|ext| ext.to_str())\n        .map(|ext| text_extensions.contains(\u0026ext.to_lowercase().as_str()))\n        .unwrap_or(false)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use anyhow::Result;\n    use std::fs;\n    use tempfile::TempDir;\n\n    // Helper function to setup temporary test environment\n    fn setup_test_directory() -\u003e Result\u003c(TempDir, Explorer)\u003e {\n        let temp_dir = TempDir::new()?;\n        let explorer = Explorer::new(temp_dir.path().to_path_buf());\n        Ok((temp_dir, explorer))\n    }\n\n    // Helper function to create a test file with content\n    fn create_test_file(dir: \u0026Path, name: \u0026str, content: \u0026str) -\u003e Result\u003cPathBuf\u003e {\n        let file_path = dir.join(name);\n        fs::write(\u0026file_path, content)?;\n        Ok(file_path)\n    }\n\n    #[test]\n    fn test_read_file() -\u003e Result\u003c()\u003e {\n        let (temp_dir, explorer) = setup_test_directory()?;\n        let test_content = \"Hello, World!\";\n        let file_path = create_test_file(temp_dir.path(), \"test.txt\", test_content)?;\n\n        let result = explorer.read_file(\u0026file_path)?;\n        assert_eq!(result, test_content);\n        Ok(())\n    }\n\n    #[test]\n    fn test_apply_replacements() -\u003e Result\u003c()\u003e {\n        let temp_dir = TempDir::new()?;\n        let test_file = temp_dir.path().join(\"test.txt\");\n        std::fs::write(\u0026test_file, \"line 1\\nline 2\\nline 3\")?;\n\n        let explorer = Explorer::new(temp_dir.path().to_path_buf());\n\n        let replacements = vec![\n            FileReplacement {\n                search: \"line 1\\n\".to_string(),\n                replace: \"new line 1\\n\".to_string(),\n            },\n            FileReplacement {\n                search: \"line 3\".to_string(),\n                replace: \"new line 3\".to_string(),\n            },\n        ];\n\n        // Apply replacements and verify content\n        let result = explorer.apply_replacements(\u0026test_file, \u0026replacements)?;\n        assert_eq!(result, \"new line 1\\nline 2\\nnew line 3\");\n\n        // Verify file was actually modified\n        let content = std::fs::read_to_string(\u0026test_file)?;\n        assert_eq!(content, \"new line 1\\nline 2\\nnew line 3\");\n\n        // Test error case with ambiguous search\n        let result = explorer.apply_replacements(\n            \u0026test_file,\n            \u0026[FileReplacement {\n                search: \"line\".to_string(),\n                replace: \"test\".to_string(),\n            }],\n        );\n        assert!(result.is_err());\n        assert!(result\n            .unwrap_err()\n            .to_string()\n            .contains(\"Found 3 occurrences\"));\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_search() -\u003e Result\u003c()\u003e {\n        let (temp_dir, explorer) = setup_test_directory()?;\n\n        // Create test files with content\n        create_test_file(\n            temp_dir.path(),\n            \"file1.txt\",\n            \"This is line 1\\nThis is line 2\\nThis is line 3\",\n        )?;\n        create_test_file(\n            temp_dir.path(),\n            \"file2.txt\",\n            \"Another file line 1\\nAnother file line 2\",\n        )?;\n\n        // Create a subdirectory with a file\n        fs::create_dir(temp_dir.path().join(\"subdir\"))?;\n        create_test_file(\n            \u0026temp_dir.path().join(\"subdir\"),\n            \"file3.txt\",\n            \"Subdir line 1\\nSubdir line 2\",\n        )?;\n\n        // Test searching with different queries\n        let results = explorer.search(\n            temp_dir.path(),\n            SearchOptions {\n                query: \"line 2\".to_string(),\n                ..Default::default()\n            },\n        )?;\n        assert_eq!(results.len(), 3);\n        assert!(results\n            .iter()\n            .any(|r| r.line_content.iter().any(|l| l.contains(\"This is line 2\"))));\n        assert!(results\n            .iter()\n            .any(|r| r.line_content.iter().any(|l| l.contains(\"Another file line 2\"))));\n        assert!(results\n            .iter()\n            .any(|r| r.line_content.iter().any(|l| l.contains(\"Subdir line 2\"))));\n\n        // Test with max_results\n        let results = explorer.search(\n            temp_dir.path(),\n            SearchOptions {\n                query: \"line\".to_string(),\n                max_results: Some(2),\n                ..Default::default()\n            },\n        )?;\n        assert_eq!(results.len(), 2);\n\n        // Test with non-matching query\n        let results = explorer.search(\n            temp_dir.path(),\n            SearchOptions {\n                query: \"nonexistent\".to_string(),\n                ..Default::default()\n            },\n        )?;\n        assert_eq!(results.len(), 0);\n\n        Ok(())\n    }\n\n    #[test]\n    fn test_create_initial_tree() -\u003e Result\u003c()\u003e {\n        let (temp_dir, mut explorer) = setup_test_directory()?;\n\n        // Create a simple file system structure\n        fs::create_dir(temp_dir.path().join(\"dir1\"))?;\n        fs::create_dir(temp_dir.path().join(\"dir2\"))?;\n        create_test_file(temp_dir.path(), \"file1.txt\", \"content\")?;\n        create_test_file(\u0026temp_dir.path().join(\"dir1\"), \"file2.txt\", \"content\")?;\n\n        let tree = explorer.create_initial_tree(2)?;\n\n        // Assert basic structure\n        assert!(tree.is_expanded);\n        assert_eq!(tree.entry_type, FileSystemEntryType::Directory);\n\n        // Assert the children\n        let children_names: Vec\u003cString\u003e = tree.children.keys().cloned().collect();\n        assert!(children_names.contains(\u0026\"dir1\".to_string()));\n        assert!(children_names.contains(\u0026\"dir2\".to_string()));\n        assert!(children_names.contains(\u0026\"file1.txt\".to_string()));\n\n        // Assert dir1\n        let dir1 = tree.children.get(\"dir1\").unwrap();\n        assert_eq!(dir1.entry_type, FileSystemEntryType::Directory);\n        assert!(dir1.is_expanded);\n        assert!(dir1.children.contains_key(\"file2.txt\"));\n\n        Ok(())\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":12}},{"line":23,"address":[],"length":0,"stats":{"Line":12}},{"line":26,"address":[],"length":0,"stats":{"Line":12}},{"line":27,"address":[],"length":0,"stats":{"Line":12}},{"line":30,"address":[],"length":0,"stats":{"Line":24}},{"line":31,"address":[],"length":0,"stats":{"Line":12}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":24}},{"line":52,"address":[],"length":0,"stats":{"Line":12}},{"line":53,"address":[],"length":0,"stats":{"Line":12}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":12}},{"line":93,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":4}},{"line":100,"address":[],"length":0,"stats":{"Line":3}},{"line":110,"address":[],"length":0,"stats":{"Line":6}},{"line":112,"address":[],"length":0,"stats":{"Line":3}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":3}},{"line":118,"address":[],"length":0,"stats":{"Line":3}},{"line":119,"address":[],"length":0,"stats":{"Line":3}},{"line":120,"address":[],"length":0,"stats":{"Line":3}},{"line":121,"address":[],"length":0,"stats":{"Line":3}},{"line":122,"address":[],"length":0,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":3}},{"line":124,"address":[],"length":0,"stats":{"Line":3}},{"line":125,"address":[],"length":0,"stats":{"Line":3}},{"line":126,"address":[],"length":0,"stats":{"Line":3}},{"line":127,"address":[],"length":0,"stats":{"Line":3}},{"line":128,"address":[],"length":0,"stats":{"Line":3}},{"line":129,"address":[],"length":0,"stats":{"Line":3}},{"line":132,"address":[],"length":0,"stats":{"Line":3}},{"line":133,"address":[],"length":0,"stats":{"Line":3}},{"line":136,"address":[],"length":0,"stats":{"Line":7}},{"line":137,"address":[],"length":0,"stats":{"Line":4}},{"line":138,"address":[],"length":0,"stats":{"Line":4}},{"line":139,"address":[],"length":0,"stats":{"Line":4}},{"line":140,"address":[],"length":0,"stats":{"Line":52}},{"line":141,"address":[],"length":0,"stats":{"Line":48}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":17}},{"line":148,"address":[],"length":0,"stats":{"Line":7}},{"line":153,"address":[],"length":0,"stats":{"Line":3}},{"line":156,"address":[],"length":0,"stats":{"Line":4}},{"line":158,"address":[],"length":0,"stats":{"Line":8}},{"line":175,"address":[],"length":0,"stats":{"Line":2}},{"line":178,"address":[],"length":0,"stats":{"Line":4}},{"line":181,"address":[],"length":0,"stats":{"Line":3}},{"line":182,"address":[],"length":0,"stats":{"Line":3}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":1}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":1}},{"line":204,"address":[],"length":0,"stats":{"Line":1}},{"line":205,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":1}},{"line":209,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":1}},{"line":211,"address":[],"length":0,"stats":{"Line":1}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":2}},{"line":260,"address":[],"length":0,"stats":{"Line":4}},{"line":261,"address":[],"length":0,"stats":{"Line":2}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":1}},{"line":266,"address":[],"length":0,"stats":{"Line":3}},{"line":267,"address":[],"length":0,"stats":{"Line":3}},{"line":268,"address":[],"length":0,"stats":{"Line":3}},{"line":269,"address":[],"length":0,"stats":{"Line":3}},{"line":272,"address":[],"length":0,"stats":{"Line":6}},{"line":274,"address":[],"length":0,"stats":{"Line":3}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":3}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":28}},{"line":301,"address":[],"length":0,"stats":{"Line":13}},{"line":305,"address":[],"length":0,"stats":{"Line":8}},{"line":306,"address":[],"length":0,"stats":{"Line":5}},{"line":310,"address":[],"length":0,"stats":{"Line":8}},{"line":314,"address":[],"length":0,"stats":{"Line":19}},{"line":315,"address":[],"length":0,"stats":{"Line":19}},{"line":317,"address":[],"length":0,"stats":{"Line":19}},{"line":318,"address":[],"length":0,"stats":{"Line":16}},{"line":322,"address":[],"length":0,"stats":{"Line":3}},{"line":324,"address":[],"length":0,"stats":{"Line":6}},{"line":325,"address":[],"length":0,"stats":{"Line":3}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":3}},{"line":331,"address":[],"length":0,"stats":{"Line":3}},{"line":335,"address":[],"length":0,"stats":{"Line":5}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":5}},{"line":343,"address":[],"length":0,"stats":{"Line":24}},{"line":344,"address":[],"length":0,"stats":{"Line":12}},{"line":347,"address":[],"length":0,"stats":{"Line":5}},{"line":348,"address":[],"length":0,"stats":{"Line":5}},{"line":349,"address":[],"length":0,"stats":{"Line":5}},{"line":350,"address":[],"length":0,"stats":{"Line":5}},{"line":351,"address":[],"length":0,"stats":{"Line":5}},{"line":352,"address":[],"length":0,"stats":{"Line":5}},{"line":360,"address":[],"length":0,"stats":{"Line":13}},{"line":363,"address":[],"length":0,"stats":{"Line":1}},{"line":368,"address":[],"length":0,"stats":{"Line":2}},{"line":373,"address":[],"length":0,"stats":{"Line":8}},{"line":374,"address":[],"length":0,"stats":{"Line":8}},{"line":375,"address":[],"length":0,"stats":{"Line":8}},{"line":376,"address":[],"length":0,"stats":{"Line":8}},{"line":377,"address":[],"length":0,"stats":{"Line":8}},{"line":378,"address":[],"length":0,"stats":{"Line":8}},{"line":379,"address":[],"length":0,"stats":{"Line":8}},{"line":380,"address":[],"length":0,"stats":{"Line":8}},{"line":381,"address":[],"length":0,"stats":{"Line":8}},{"line":382,"address":[],"length":0,"stats":{"Line":8}},{"line":383,"address":[],"length":0,"stats":{"Line":8}},{"line":384,"address":[],"length":0,"stats":{"Line":8}},{"line":385,"address":[],"length":0,"stats":{"Line":8}},{"line":386,"address":[],"length":0,"stats":{"Line":8}},{"line":387,"address":[],"length":0,"stats":{"Line":8}},{"line":388,"address":[],"length":0,"stats":{"Line":8}},{"line":389,"address":[],"length":0,"stats":{"Line":8}},{"line":390,"address":[],"length":0,"stats":{"Line":8}},{"line":391,"address":[],"length":0,"stats":{"Line":8}},{"line":392,"address":[],"length":0,"stats":{"Line":8}},{"line":393,"address":[],"length":0,"stats":{"Line":8}},{"line":394,"address":[],"length":0,"stats":{"Line":8}},{"line":395,"address":[],"length":0,"stats":{"Line":8}},{"line":396,"address":[],"length":0,"stats":{"Line":8}},{"line":397,"address":[],"length":0,"stats":{"Line":8}},{"line":398,"address":[],"length":0,"stats":{"Line":8}},{"line":399,"address":[],"length":0,"stats":{"Line":8}},{"line":400,"address":[],"length":0,"stats":{"Line":8}},{"line":403,"address":[],"length":0,"stats":{"Line":8}},{"line":404,"address":[],"length":0,"stats":{"Line":24}},{"line":405,"address":[],"length":0,"stats":{"Line":24}}],"covered":123,"coverable":176},{"path":["/","Users","stippi","projects","code-assistant","src","llm","anthropic.rs"],"content":"use crate::llm::{\n    types::*, ApiError, ApiErrorContext, LLMProvider, RateLimitHandler, StreamingCallback,\n};\nuse anyhow::Result;\nuse async_trait::async_trait;\nuse chrono::{DateTime, Utc};\nuse reqwest::{Client, Response, StatusCode};\nuse serde::{Deserialize, Serialize};\nuse std::str::{self};\nuse std::time::Duration;\nuse tokio::time::sleep;\nuse tracing::{debug, error, warn};\n\n/// Response structure for Anthropic error messages\n#[derive(Debug, Serialize, serde::Deserialize)]\nstruct AnthropicErrorResponse {\n    #[serde(rename = \"type\")]\n    error_type: String,\n    error: AnthropicErrorPayload,\n}\n\n#[derive(Debug, Serialize, serde::Deserialize)]\nstruct AnthropicErrorPayload {\n    #[serde(rename = \"type\")]\n    error_type: String,\n    message: String,\n}\n\n/// Rate limit information extracted from response headers\n#[derive(Debug)]\nstruct AnthropicRateLimitInfo {\n    requests_limit: Option\u003cu32\u003e,\n    requests_remaining: Option\u003cu32\u003e,\n    requests_reset: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    tokens_limit: Option\u003cu32\u003e,\n    tokens_remaining: Option\u003cu32\u003e,\n    tokens_reset: Option\u003cDateTime\u003cUtc\u003e\u003e,\n    retry_after: Option\u003cDuration\u003e,\n}\n\nimpl RateLimitHandler for AnthropicRateLimitInfo {\n    /// Extract rate limit information from response headers\n    fn from_response(response: \u0026Response) -\u003e Self {\n        let headers = response.headers();\n\n        fn parse_header\u003cT: std::str::FromStr\u003e(\n            headers: \u0026reqwest::header::HeaderMap,\n            name: \u0026str,\n        ) -\u003e Option\u003cT\u003e {\n            headers\n                .get(name)\n                .and_then(|h| h.to_str().ok())\n                .and_then(|s| s.parse().ok())\n        }\n\n        fn parse_datetime(\n            headers: \u0026reqwest::header::HeaderMap,\n            name: \u0026str,\n        ) -\u003e Option\u003cDateTime\u003cUtc\u003e\u003e {\n            headers\n                .get(name)\n                .and_then(|h| h.to_str().ok())\n                .and_then(|s| DateTime::parse_from_rfc3339(s).ok())\n                .map(|dt| dt.into())\n        }\n\n        Self {\n            requests_limit: parse_header(headers, \"anthropic-ratelimit-requests-limit\"),\n            requests_remaining: parse_header(headers, \"anthropic-ratelimit-requests-remaining\"),\n            requests_reset: parse_datetime(headers, \"anthropic-ratelimit-requests-reset\"),\n            tokens_limit: parse_header(headers, \"anthropic-ratelimit-tokens-limit\"),\n            tokens_remaining: parse_header(headers, \"anthropic-ratelimit-tokens-remaining\"),\n            tokens_reset: parse_datetime(headers, \"anthropic-ratelimit-tokens-reset\"),\n            retry_after: parse_header::\u003cu64\u003e(headers, \"retry-after\").map(Duration::from_secs),\n        }\n    }\n\n    /// Calculate how long to wait before retrying based on rate limit information\n    fn get_retry_delay(\u0026self) -\u003e Duration {\n        // If we have a specific retry-after duration, use that\n        if let Some(retry_after) = self.retry_after {\n            return retry_after;\n        }\n\n        // Otherwise, calculate based on reset times\n        let now = Utc::now();\n        let mut shortest_wait = Duration::from_secs(60); // Default to 60 seconds if no information\n\n        // Check requests reset time\n        if let Some(reset_time) = self.requests_reset {\n            if reset_time \u003e now {\n                shortest_wait = shortest_wait.min(Duration::from_secs(\n                    (reset_time - now).num_seconds().max(0) as u64,\n                ));\n            }\n        }\n\n        // Check tokens reset time\n        if let Some(reset_time) = self.tokens_reset {\n            if reset_time \u003e now {\n                shortest_wait = shortest_wait.min(Duration::from_secs(\n                    (reset_time - now).num_seconds().max(0) as u64,\n                ));\n            }\n        }\n\n        // Add a small buffer to avoid hitting the limit exactly at reset time\n        shortest_wait + Duration::from_secs(1)\n    }\n\n    /// Log current rate limit status\n    fn log_status(\u0026self) {\n        debug!(\n            \"Rate limits - Requests: {}/{} (reset: {}), Tokens: {}/{} (reset: {})\",\n            self.requests_remaining\n                .map_or(\"?\".to_string(), |r| r.to_string()),\n            self.requests_limit\n                .map_or(\"?\".to_string(), |l| l.to_string()),\n            self.requests_reset\n                .map_or(\"unknown\".to_string(), |r| r.to_string()),\n            self.tokens_remaining\n                .map_or(\"?\".to_string(), |r| r.to_string()),\n            self.tokens_limit.map_or(\"?\".to_string(), |l| l.to_string()),\n            self.tokens_reset\n                .map_or(\"unknown\".to_string(), |r| r.to_string()),\n        );\n    }\n}\n\n/// Anthropic-specific request structure\n#[derive(Debug, Serialize)]\nstruct AnthropicRequest {\n    model: String,\n    messages: Vec\u003cMessage\u003e,\n    max_tokens: usize,\n    temperature: f32,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    system: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    tools: Option\u003cVec\u003cserde_json::Value\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    tool_choice: Option\u003cserde_json::Value\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    stream: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct StreamEventCommon {\n    index: usize,\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(tag = \"type\")]\nenum StreamEvent {\n    #[allow(dead_code)]\n    #[serde(rename = \"message_start\")]\n    MessageStart { message: MessageStart },\n    #[serde(rename = \"content_block_start\")]\n    ContentBlockStart {\n        #[serde(flatten)]\n        common: StreamEventCommon,\n        content_block: StreamContentBlock,\n    },\n    #[serde(rename = \"content_block_delta\")]\n    ContentBlockDelta {\n        #[serde(flatten)]\n        common: StreamEventCommon,\n        delta: ContentDelta,\n    },\n    #[serde(rename = \"content_block_stop\")]\n    ContentBlockStop {\n        #[serde(flatten)]\n        common: StreamEventCommon,\n    },\n    #[serde(rename = \"message_delta\")]\n    MessageDelta,\n    #[serde(rename = \"message_stop\")]\n    MessageStop,\n    #[serde(rename = \"ping\")]\n    Ping,\n}\n\n#[derive(Debug, Deserialize)]\nstruct MessageStart {\n    #[allow(dead_code)]\n    id: String,\n    #[allow(dead_code)]\n    #[serde(rename = \"type\")]\n    message_type: String,\n    #[allow(dead_code)]\n    role: String,\n    #[allow(dead_code)]\n    model: String,\n}\n\n#[derive(Debug, Deserialize)]\nstruct StreamContentBlock {\n    #[serde(rename = \"type\")]\n    block_type: String,\n    text: Option\u003cString\u003e,\n    // Fields for tool use blocks\n    id: Option\u003cString\u003e,\n    name: Option\u003cString\u003e,\n    input: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(tag = \"type\")]\nenum ContentDelta {\n    #[serde(rename = \"text_delta\")]\n    TextDelta { text: String },\n    #[serde(rename = \"input_json_delta\")]\n    InputJsonDelta { partial_json: String },\n}\n\npub struct AnthropicClient {\n    client: Client,\n    api_key: String,\n    base_url: String,\n    model: String,\n}\n\nimpl AnthropicClient {\n    pub fn new(api_key: String, model: String) -\u003e Self {\n        Self {\n            client: Client::new(),\n            api_key,\n            base_url: \"https://api.anthropic.com/v1\".to_string(),\n            model,\n        }\n    }\n\n    #[cfg(test)]\n    pub fn new_with_base_url(api_key: String, model: String, base_url: String) -\u003e Self {\n        Self {\n            client: Client::new(),\n            api_key,\n            base_url,\n            model,\n        }\n    }\n\n    fn get_url(\u0026self) -\u003e String {\n        format!(\"{}/messages\", self.base_url)\n    }\n\n    async fn send_with_retry(\n        \u0026self,\n        request: \u0026AnthropicRequest,\n        streaming_callback: Option\u003c\u0026StreamingCallback\u003e,\n        max_retries: u32,\n    ) -\u003e Result\u003cLLMResponse\u003e {\n        let mut attempts = 0;\n\n        loop {\n            match self.try_send_request(request, streaming_callback).await {\n                Ok((response, rate_limits)) =\u003e {\n                    // Log rate limit status on successful response\n                    rate_limits.log_status();\n                    return Ok(response);\n                }\n                Err(e) =\u003e {\n                    // Extract rate limit info if available in the error context\n                    let rate_limits = e\n                        .downcast_ref::\u003cApiErrorContext\u003cAnthropicRateLimitInfo\u003e\u003e()\n                        .and_then(|ctx| ctx.rate_limits.as_ref());\n\n                    match e.downcast_ref::\u003cApiError\u003e() {\n                        Some(ApiError::RateLimit(_)) =\u003e {\n                            if let Some(rate_limits) = rate_limits {\n                                if attempts \u003c max_retries {\n                                    attempts += 1;\n                                    let delay = rate_limits.get_retry_delay();\n                                    warn!(\n                                            \"Rate limit hit (attempt {}/{}), waiting {} seconds before retry\",\n                                            attempts,\n                                            max_retries,\n                                            delay.as_secs()\n                                        );\n                                    sleep(delay).await;\n                                    continue;\n                                }\n                            } else {\n                                // Fallback if no rate limit info available\n                                if attempts \u003c max_retries {\n                                    attempts += 1;\n                                    let delay = Duration::from_secs(2u64.pow(attempts - 1));\n                                    warn!(\n                                            \"Rate limit hit but no timing info available (attempt {}/{}), using exponential backoff: {} seconds\",\n                                            attempts,\n                                            max_retries,\n                                            delay.as_secs()\n                                        );\n                                    sleep(delay).await;\n                                    continue;\n                                }\n                            }\n                        }\n                        Some(ApiError::ServiceError(_)) =\u003e {\n                            if attempts \u003c max_retries {\n                                attempts += 1;\n                                let delay = Duration::from_secs(2u64.pow(attempts - 1));\n                                warn!(\n                                    \"Service error (attempt {}/{}), retrying in {} seconds\",\n                                    attempts,\n                                    max_retries,\n                                    delay.as_secs()\n                                );\n                                sleep(delay).await;\n                                continue;\n                            }\n                        }\n                        Some(ApiError::NetworkError(_)) =\u003e {\n                            if attempts \u003c max_retries {\n                                attempts += 1;\n                                let delay = Duration::from_secs(2u64.pow(attempts - 1));\n                                warn!(\n                                    \"Network error (attempt {}/{}), retrying in {} seconds\",\n                                    attempts,\n                                    max_retries,\n                                    delay.as_secs()\n                                );\n                                sleep(delay).await;\n                                continue;\n                            }\n                        }\n                        _ =\u003e {} // Don't retry other types of errors\n                    }\n                    return Err(e);\n                }\n            }\n        }\n    }\n\n    async fn try_send_request(\n        \u0026self,\n        request: \u0026AnthropicRequest,\n        streaming_callback: Option\u003c\u0026StreamingCallback\u003e,\n    ) -\u003e Result\u003c(LLMResponse, AnthropicRateLimitInfo)\u003e {\n        let accept_value = if let Some(_) = streaming_callback {\n            \"text/event-stream\"\n        } else {\n            \"application/json\"\n        };\n\n        let mut response = self\n            .client\n            .post(\u0026self.get_url())\n            .header(\"x-api-key\", \u0026self.api_key)\n            .header(\"anthropic-version\", \"2023-06-01\")\n            .header(\"accept\", accept_value)\n            .json(request)\n            .send()\n            .await\n            .map_err(|e| ApiError::NetworkError(e.to_string()))?;\n\n        // Log raw headers for debugging\n        debug!(\"Response headers: {:?}\", response.headers());\n\n        // Extract rate limit information from response headers\n        let rate_limits = AnthropicRateLimitInfo::from_response(\u0026response);\n\n        // Log parsed rate limits\n        debug!(\"Parsed rate limits: {:?}\", rate_limits);\n\n        let status = response.status();\n        if !status.is_success() {\n            let response_text = response\n                .text()\n                .await\n                .map_err(|e| ApiError::NetworkError(e.to_string()))?;\n\n            // Try to parse the error response\n            let error = if let Ok(error_response) =\n                serde_json::from_str::\u003cAnthropicErrorResponse\u003e(\u0026response_text)\n            {\n                match (status, error_response.error.error_type.as_str()) {\n                    (StatusCode::TOO_MANY_REQUESTS, _) | (_, \"rate_limit_error\") =\u003e {\n                        error!(\n                            \"Rate limit error detected: status={}, type={}, message={}\",\n                            status, error_response.error.error_type, error_response.error.message\n                        );\n                        ApiError::RateLimit(error_response.error.message)\n                    }\n                    (StatusCode::UNAUTHORIZED, _) =\u003e {\n                        ApiError::Authentication(error_response.error.message)\n                    }\n                    (StatusCode::BAD_REQUEST, _) =\u003e {\n                        ApiError::InvalidRequest(error_response.error.message)\n                    }\n                    (status, _) if status.is_server_error() =\u003e {\n                        ApiError::ServiceError(error_response.error.message)\n                    }\n                    _ =\u003e {\n                        error!(\n                            \"Unknown error detected: status={}, type={}, message={}\",\n                            status, error_response.error.error_type, error_response.error.message\n                        );\n                        ApiError::Unknown(error_response.error.message)\n                    }\n                }\n            } else {\n                ApiError::Unknown(format!(\"Status {}: {}\", status, response_text))\n            };\n\n            // Wrap the error with rate limit context\n            return Err(ApiErrorContext {\n                error,\n                rate_limits: Some(rate_limits),\n            }\n            .into());\n        }\n\n        if let Some(callback) = streaming_callback {\n            let mut blocks: Vec\u003cContentBlock\u003e = Vec::new();\n            let mut current_content = String::new();\n            let mut line_buffer = String::new();\n\n            fn process_chunk(\n                chunk: \u0026[u8],\n                line_buffer: \u0026mut String,\n                blocks: \u0026mut Vec\u003cContentBlock\u003e,\n                current_content: \u0026mut String,\n                callback: \u0026StreamingCallback,\n            ) -\u003e Result\u003c()\u003e {\n                let chunk_str = str::from_utf8(chunk)?;\n\n                for c in chunk_str.chars() {\n                    if c == '\\n' {\n                        if !line_buffer.is_empty() {\n                            process_sse_line(line_buffer, blocks, current_content, callback)?;\n                            line_buffer.clear();\n                        }\n                    } else {\n                        line_buffer.push(c);\n                    }\n                }\n                Ok(())\n            }\n\n            fn process_sse_line(\n                line: \u0026str,\n                blocks: \u0026mut Vec\u003cContentBlock\u003e,\n                current_content: \u0026mut String,\n                callback: \u0026StreamingCallback,\n            ) -\u003e Result\u003c()\u003e {\n                if let Some(data) = line.strip_prefix(\"data: \") {\n                    if let Ok(event) = serde_json::from_str::\u003cStreamEvent\u003e(data) {\n                        // Extract and check index for relevant events\n                        match \u0026event {\n                            StreamEvent::ContentBlockStart { common, .. } =\u003e {\n                                if common.index != blocks.len() {\n                                    return Err(anyhow::anyhow!(\n                                        \"Start index {} does not match expected block {}\",\n                                        common.index,\n                                        blocks.len()\n                                    ));\n                                }\n                            }\n                            StreamEvent::ContentBlockDelta { common, .. }\n                            | StreamEvent::ContentBlockStop { common } =\u003e {\n                                // Check if we have any blocks at all\n                                if blocks.is_empty() {\n                                    return Err(anyhow::anyhow!(\n                                        \"Received Delta/Stop but no blocks exist\"\n                                    ));\n                                }\n                                if common.index != blocks.len() - 1 {\n                                    return Err(anyhow::anyhow!(\n                                        \"Delta/Stop index {} does not match current block {}\",\n                                        common.index,\n                                        blocks.len() - 1\n                                    ));\n                                }\n                            }\n                            _ =\u003e return Ok(()), // Early return for events without index\n                        }\n\n                        match event {\n                            StreamEvent::ContentBlockStart { content_block, .. } =\u003e {\n                                current_content.clear();\n                                let block = match content_block.block_type.as_str() {\n                                    \"text\" =\u003e {\n                                        if let Some(text) = content_block.text {\n                                            current_content.push_str(\u0026text);\n                                        }\n                                        ContentBlock::Text {\n                                            text: String::new(),\n                                        }\n                                    }\n                                    \"tool_use\" =\u003e {\n                                        if let Some(input) = content_block.input {\n                                            current_content.push_str(\u0026input);\n                                        }\n                                        ContentBlock::ToolUse {\n                                            id: content_block.id.unwrap_or_default(),\n                                            name: content_block.name.unwrap_or_default(),\n                                            input: serde_json::Value::Null,\n                                        }\n                                    }\n                                    _ =\u003e ContentBlock::Text {\n                                        text: String::new(),\n                                    },\n                                };\n                                blocks.push(block);\n                            }\n                            StreamEvent::ContentBlockDelta { delta, .. } =\u003e {\n                                match \u0026delta {\n                                    ContentDelta::TextDelta { text: delta_text } =\u003e {\n                                        callback(delta_text)?;\n                                        current_content.push_str(delta_text);\n                                    }\n                                    ContentDelta::InputJsonDelta { partial_json } =\u003e {\n                                        // Accumulate JSON parts as string\n                                        current_content.push_str(partial_json);\n                                    }\n                                }\n                            }\n                            StreamEvent::ContentBlockStop { .. } =\u003e {\n                                match blocks.last_mut().unwrap() {\n                                    ContentBlock::Text { text } =\u003e {\n                                        *text = current_content.clone();\n                                    }\n                                    ContentBlock::ToolUse { input, .. } =\u003e {\n                                        if let Ok(json) = serde_json::from_str(current_content) {\n                                            *input = json;\n                                        }\n                                    }\n                                    _ =\u003e {}\n                                }\n                            }\n                            _ =\u003e {}\n                        }\n                    }\n                }\n                Ok(())\n            }\n\n            while let Some(chunk) = response.chunk().await? {\n                process_chunk(\n                    \u0026chunk,\n                    \u0026mut line_buffer,\n                    \u0026mut blocks,\n                    \u0026mut current_content,\n                    callback,\n                )?;\n            }\n\n            // Process any remaining data in the buffer\n            if !line_buffer.is_empty() {\n                process_sse_line(\u0026line_buffer, \u0026mut blocks, \u0026mut current_content, callback)?;\n            }\n\n            Ok((\n                LLMResponse {\n                    content: blocks,\n                    usage: Usage {\n                        input_tokens: 0,\n                        output_tokens: 0,\n                    },\n                },\n                rate_limits,\n            ))\n        } else {\n            let response_text = response\n                .text()\n                .await\n                .map_err(|e| ApiError::NetworkError(e.to_string()))?;\n\n            let llm_response = serde_json::from_str(\u0026response_text)\n                .map_err(|e| ApiError::Unknown(format!(\"Failed to parse response: {}\", e)))?;\n\n            Ok((llm_response, rate_limits))\n        }\n    }\n}\n\n#[async_trait]\nimpl LLMProvider for AnthropicClient {\n    async fn send_message(\n        \u0026self,\n        request: LLMRequest,\n        streaming_callback: Option\u003c\u0026StreamingCallback\u003e,\n    ) -\u003e Result\u003cLLMResponse\u003e {\n        let anthropic_request = AnthropicRequest {\n            model: self.model.clone(),\n            messages: request.messages,\n            max_tokens: 8192,\n            temperature: 0.7,\n            system: Some(request.system_prompt),\n            stream: streaming_callback.map(|_| true),\n            tool_choice: match \u0026request.tools {\n                Some(_) =\u003e Some(serde_json::json!({\n                    \"type\": \"any\",\n                })),\n                _ =\u003e None,\n            },\n            tools: request.tools.map(|tools| {\n                tools\n                    .into_iter()\n                    .map(|tool| {\n                        serde_json::json!({\n                            \"name\": tool.name,\n                            \"description\": tool.description,\n                            \"input_schema\": tool.parameters\n                        })\n                    })\n                    .collect()\n            }),\n        };\n\n        self.send_with_retry(\u0026anthropic_request, streaming_callback, 3)\n            .await\n    }\n}\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":4}},{"line":44,"address":[],"length":0,"stats":{"Line":4}},{"line":46,"address":[],"length":0,"stats":{"Line":20}},{"line":50,"address":[],"length":0,"stats":{"Line":20}},{"line":51,"address":[],"length":0,"stats":{"Line":20}},{"line":52,"address":[],"length":0,"stats":{"Line":40}},{"line":53,"address":[],"length":0,"stats":{"Line":40}},{"line":56,"address":[],"length":0,"stats":{"Line":8}},{"line":60,"address":[],"length":0,"stats":{"Line":8}},{"line":61,"address":[],"length":0,"stats":{"Line":8}},{"line":62,"address":[],"length":0,"stats":{"Line":16}},{"line":63,"address":[],"length":0,"stats":{"Line":16}},{"line":64,"address":[],"length":0,"stats":{"Line":16}},{"line":68,"address":[],"length":0,"stats":{"Line":4}},{"line":69,"address":[],"length":0,"stats":{"Line":4}},{"line":70,"address":[],"length":0,"stats":{"Line":4}},{"line":71,"address":[],"length":0,"stats":{"Line":4}},{"line":72,"address":[],"length":0,"stats":{"Line":4}},{"line":73,"address":[],"length":0,"stats":{"Line":4}},{"line":74,"address":[],"length":0,"stats":{"Line":4}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":4}},{"line":113,"address":[],"length":0,"stats":{"Line":4}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":2}},{"line":236,"address":[],"length":0,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":4}},{"line":244,"address":[],"length":0,"stats":{"Line":4}},{"line":247,"address":[],"length":0,"stats":{"Line":4}},{"line":253,"address":[],"length":0,"stats":{"Line":4}},{"line":256,"address":[],"length":0,"stats":{"Line":26}},{"line":257,"address":[],"length":0,"stats":{"Line":4}},{"line":259,"address":[],"length":0,"stats":{"Line":4}},{"line":260,"address":[],"length":0,"stats":{"Line":4}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":4}},{"line":340,"address":[],"length":0,"stats":{"Line":8}},{"line":341,"address":[],"length":0,"stats":{"Line":2}},{"line":343,"address":[],"length":0,"stats":{"Line":2}},{"line":346,"address":[],"length":0,"stats":{"Line":8}},{"line":347,"address":[],"length":0,"stats":{"Line":4}},{"line":348,"address":[],"length":0,"stats":{"Line":4}},{"line":349,"address":[],"length":0,"stats":{"Line":4}},{"line":351,"address":[],"length":0,"stats":{"Line":4}},{"line":352,"address":[],"length":0,"stats":{"Line":4}},{"line":354,"address":[],"length":0,"stats":{"Line":8}},{"line":355,"address":[],"length":0,"stats":{"Line":8}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":4}},{"line":364,"address":[],"length":0,"stats":{"Line":4}},{"line":366,"address":[],"length":0,"stats":{"Line":4}},{"line":367,"address":[],"length":0,"stats":{"Line":4}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":6}},{"line":419,"address":[],"length":0,"stats":{"Line":14}},{"line":426,"address":[],"length":0,"stats":{"Line":28}},{"line":428,"address":[],"length":0,"stats":{"Line":1793}},{"line":429,"address":[],"length":0,"stats":{"Line":1793}},{"line":430,"address":[],"length":0,"stats":{"Line":42}},{"line":431,"address":[],"length":0,"stats":{"Line":28}},{"line":432,"address":[],"length":0,"stats":{"Line":28}},{"line":435,"address":[],"length":0,"stats":{"Line":1751}},{"line":438,"address":[],"length":0,"stats":{"Line":14}},{"line":441,"address":[],"length":0,"stats":{"Line":28}},{"line":447,"address":[],"length":0,"stats":{"Line":42}},{"line":448,"address":[],"length":0,"stats":{"Line":14}},{"line":451,"address":[],"length":0,"stats":{"Line":2}},{"line":452,"address":[],"length":0,"stats":{"Line":2}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":4}},{"line":461,"address":[],"length":0,"stats":{"Line":2}},{"line":463,"address":[],"length":0,"stats":{"Line":6}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":6}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":6}},{"line":479,"address":[],"length":0,"stats":{"Line":8}},{"line":480,"address":[],"length":0,"stats":{"Line":2}},{"line":481,"address":[],"length":0,"stats":{"Line":2}},{"line":482,"address":[],"length":0,"stats":{"Line":2}},{"line":484,"address":[],"length":0,"stats":{"Line":3}},{"line":485,"address":[],"length":0,"stats":{"Line":1}},{"line":488,"address":[],"length":0,"stats":{"Line":1}},{"line":491,"address":[],"length":0,"stats":{"Line":1}},{"line":492,"address":[],"length":0,"stats":{"Line":1}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":1}},{"line":497,"address":[],"length":0,"stats":{"Line":1}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":4}},{"line":508,"address":[],"length":0,"stats":{"Line":4}},{"line":509,"address":[],"length":0,"stats":{"Line":2}},{"line":510,"address":[],"length":0,"stats":{"Line":2}},{"line":511,"address":[],"length":0,"stats":{"Line":2}},{"line":513,"address":[],"length":0,"stats":{"Line":2}},{"line":515,"address":[],"length":0,"stats":{"Line":2}},{"line":520,"address":[],"length":0,"stats":{"Line":2}},{"line":521,"address":[],"length":0,"stats":{"Line":1}},{"line":522,"address":[],"length":0,"stats":{"Line":1}},{"line":524,"address":[],"length":0,"stats":{"Line":1}},{"line":525,"address":[],"length":0,"stats":{"Line":2}},{"line":526,"address":[],"length":0,"stats":{"Line":1}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":22}},{"line":539,"address":[],"length":0,"stats":{"Line":44}},{"line":541,"address":[],"length":0,"stats":{"Line":14}},{"line":542,"address":[],"length":0,"stats":{"Line":14}},{"line":543,"address":[],"length":0,"stats":{"Line":14}},{"line":544,"address":[],"length":0,"stats":{"Line":14}},{"line":545,"address":[],"length":0,"stats":{"Line":14}},{"line":550,"address":[],"length":0,"stats":{"Line":2}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":2}},{"line":555,"address":[],"length":0,"stats":{"Line":2}},{"line":556,"address":[],"length":0,"stats":{"Line":2}},{"line":557,"address":[],"length":0,"stats":{"Line":2}},{"line":558,"address":[],"length":0,"stats":{"Line":2}},{"line":559,"address":[],"length":0,"stats":{"Line":2}},{"line":562,"address":[],"length":0,"stats":{"Line":2}},{"line":565,"address":[],"length":0,"stats":{"Line":4}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":4}},{"line":570,"address":[],"length":0,"stats":{"Line":2}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":2}},{"line":586,"address":[],"length":0,"stats":{"Line":4}},{"line":587,"address":[],"length":0,"stats":{"Line":4}},{"line":590,"address":[],"length":0,"stats":{"Line":4}},{"line":591,"address":[],"length":0,"stats":{"Line":10}},{"line":592,"address":[],"length":0,"stats":{"Line":4}},{"line":598,"address":[],"length":0,"stats":{"Line":6}},{"line":612,"address":[],"length":0,"stats":{"Line":4}},{"line":613,"address":[],"length":0,"stats":{"Line":22}}],"covered":119,"coverable":227},{"path":["/","Users","stippi","projects","code-assistant","src","llm","mod.rs"],"content":"#[cfg(test)]\nmod tests;\n\npub mod anthropic;\npub mod ollama;\npub mod openai;\npub mod types;\npub mod vertex;\n\npub use anthropic::AnthropicClient;\npub use ollama::OllamaClient;\npub use openai::OpenAIClient;\npub use types::*;\npub use vertex::VertexClient;\n\nuse anyhow::Result;\nuse async_trait::async_trait;\n\npub type StreamingCallback = Box\u003cdyn Fn(\u0026str) -\u003e Result\u003c()\u003e + Send + Sync\u003e;\n\n/// Trait for different LLM provider implementations\n#[async_trait]\npub trait LLMProvider {\n    /// Sends a request to the LLM service\n    async fn send_message(\n        \u0026self,\n        request: LLMRequest,\n        streaming_callback: Option\u003c\u0026StreamingCallback\u003e,\n    ) -\u003e Result\u003cLLMResponse\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","stippi","projects","code-assistant","src","llm","ollama.rs"],"content":"use crate::llm::{types::*, LLMProvider, StreamingCallback};\nuse anyhow::Result;\nuse async_trait::async_trait;\nuse reqwest::Client;\nuse serde::{Deserialize, Serialize};\nuse tracing::debug;\n\n#[derive(Debug, Serialize)]\nstruct OllamaRequest {\n    model: String,\n    messages: Vec\u003cOllamaMessage\u003e,\n    stream: bool,\n    options: OllamaOptions,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    tools: Option\u003cVec\u003cserde_json::Value\u003e\u003e,\n}\n\n#[derive(Debug, Serialize)]\nstruct OllamaOptions {\n    num_ctx: usize,\n}\n\n#[derive(Debug, Serialize)]\nstruct OllamaMessage {\n    role: String,\n    content: String,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OllamaResponse {\n    message: OllamaResponseMessage,\n    #[allow(dead_code)]\n    done_reason: Option\u003cString\u003e,\n    done: bool,\n    #[serde(default)]\n    prompt_eval_count: u32,\n    #[serde(default)]\n    eval_count: u32,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct OllamaToolCall {\n    function: OllamaFunction,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct OllamaFunction {\n    name: String,\n    arguments: serde_json::Value,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OllamaResponseMessage {\n    content: String,\n    tool_calls: Option\u003cVec\u003cOllamaToolCall\u003e\u003e,\n}\n\npub struct OllamaClient {\n    client: Client,\n    base_url: String,\n    model: String,\n    num_ctx: usize,\n}\n\nimpl OllamaClient {\n    pub fn new(model: String, num_ctx: usize) -\u003e Self {\n        Self {\n            client: Client::new(),\n            base_url: \"http://localhost:11434\".to_string(),\n            model,\n            num_ctx,\n        }\n    }\n\n    #[cfg(test)]\n    pub fn new_with_base_url(model: String, num_ctx: usize, base_url: String) -\u003e Self {\n        Self {\n            client: Client::new(),\n            base_url,\n            model,\n            num_ctx,\n        }\n    }\n\n    fn get_url(\u0026self) -\u003e String {\n        format!(\"{}/api/chat\", self.base_url)\n    }\n\n    fn convert_message(message: \u0026Message) -\u003e OllamaMessage {\n        OllamaMessage {\n            role: match message.role {\n                MessageRole::User =\u003e \"user\".to_string(),\n                MessageRole::Assistant =\u003e \"assistant\".to_string(),\n            },\n            content: match \u0026message.content {\n                MessageContent::Text(text) =\u003e text.clone(),\n                MessageContent::Structured(_) =\u003e \"[Structured content not supported]\".to_string(),\n            },\n        }\n    }\n\n    async fn try_send_request(\u0026self, request: \u0026OllamaRequest) -\u003e Result\u003cLLMResponse\u003e {\n        let response = self\n            .client\n            .post(\u0026self.get_url())\n            .json(request)\n            .send()\n            .await\n            .map_err(|e| anyhow::anyhow!(\"Network error: {}\", e))?;\n\n        // Store status code before consuming response\n        let status = response.status();\n\n        if !status.is_success() {\n            let error_text = response\n                .text()\n                .await\n                .unwrap_or_else(|_| \"Unknown error\".to_string());\n            return Err(anyhow::anyhow!(\n                \"Ollama request failed: Status {}, Error: {}\",\n                status,\n                error_text\n            ));\n        }\n\n        let ollama_response: OllamaResponse = response\n            .json()\n            .await\n            .map_err(|e| anyhow::anyhow!(\"Failed to parse Ollama response: {}\", e))?;\n\n        let mut content = Vec::new();\n\n        if !ollama_response.message.content.is_empty() {\n            content.push(ContentBlock::Text {\n                text: ollama_response.message.content,\n            });\n        }\n\n        if let Some(tool_calls) = ollama_response.message.tool_calls {\n            for (index, tool_call) in tool_calls.into_iter().enumerate() {\n                content.push(ContentBlock::ToolUse {\n                    id: format!(\"tool-{}\", index),\n                    name: tool_call.function.name,\n                    input: tool_call.function.arguments,\n                });\n            }\n        }\n\n        Ok(LLMResponse {\n            content,\n            usage: Usage {\n                input_tokens: ollama_response.prompt_eval_count,\n                output_tokens: ollama_response.eval_count,\n            },\n        })\n    }\n\n    async fn try_send_request_streaming(\n        \u0026self,\n        request: \u0026OllamaRequest,\n        streaming_callback: \u0026StreamingCallback,\n    ) -\u003e Result\u003cLLMResponse\u003e {\n        let response = self\n            .client\n            .post(\u0026self.get_url())\n            .json(request)\n            .send()\n            .await\n            .map_err(|e| anyhow::anyhow!(\"Network error: {}\", e))?;\n\n        // Store status code before consuming response\n        let status = response.status();\n        if !status.is_success() {\n            let error_text = response\n                .text()\n                .await\n                .unwrap_or_else(|_| \"Unknown error\".to_string());\n            return Err(anyhow::anyhow!(\n                \"Ollama request failed: Status {}, Error: {}\",\n                status,\n                error_text\n            ));\n        }\n\n        let mut response = response;\n        let mut line_buffer = String::new();\n        let mut accumulated_content = String::new();\n        let mut tool_calls = Vec::new();\n        let mut final_eval_counts = (0u32, 0u32); // (prompt_eval_count, eval_count)\n\n        while let Some(chunk) = response.chunk().await? {\n            for byte in chunk {\n                if byte == b'\\n' {\n                    if !line_buffer.is_empty() {\n                        if let Ok(chunk_response) =\n                            serde_json::from_str::\u003cOllamaResponse\u003e(\u0026line_buffer)\n                        {\n                            // Handle text content\n                            if !chunk_response.message.content.is_empty() {\n                                streaming_callback(\u0026chunk_response.message.content)?;\n                                accumulated_content.push_str(\u0026chunk_response.message.content);\n                            }\n\n                            // Handle tool calls - only collect complete tool calls from the response\n                            if let Some(chunk_tool_calls) = chunk_response.message.tool_calls {\n                                tool_calls.extend(chunk_tool_calls);\n                            }\n\n                            // Update eval counts from the final response\n                            if chunk_response.done {\n                                final_eval_counts =\n                                    (chunk_response.prompt_eval_count, chunk_response.eval_count);\n                            }\n                        }\n                        line_buffer.clear();\n                    }\n                } else {\n                    line_buffer.push(byte as char);\n                }\n            }\n        }\n\n        // Build final response\n        let mut content = Vec::new();\n\n        // Add accumulated text content if present\n        if !accumulated_content.is_empty() {\n            content.push(ContentBlock::Text {\n                text: accumulated_content,\n            });\n        }\n\n        // Add tool calls if present\n        for (index, tool_call) in tool_calls.into_iter().enumerate() {\n            content.push(ContentBlock::ToolUse {\n                id: format!(\"tool-{}\", index),\n                name: tool_call.function.name,\n                input: tool_call.function.arguments,\n            });\n        }\n\n        Ok(LLMResponse {\n            content,\n            usage: Usage {\n                input_tokens: final_eval_counts.0,\n                output_tokens: final_eval_counts.1,\n            },\n        })\n    }\n}\n\n#[async_trait]\nimpl LLMProvider for OllamaClient {\n    async fn send_message(\n        \u0026self,\n        request: LLMRequest,\n        streaming_callback: Option\u003c\u0026StreamingCallback\u003e,\n    ) -\u003e Result\u003cLLMResponse\u003e {\n        let mut messages: Vec\u003cOllamaMessage\u003e = Vec::new();\n\n        // Add system message\n        messages.push(OllamaMessage {\n            role: \"system\".to_string(),\n            content: request.system_prompt,\n        });\n\n        // Add conversation messages\n        messages.extend(request.messages.iter().map(Self::convert_message));\n\n        let mut ollama_request = OllamaRequest {\n            model: self.model.clone(),\n            messages,\n            stream: false,\n            options: OllamaOptions {\n                num_ctx: self.num_ctx,\n            },\n            tools: request.tools.map(|tools| {\n                tools\n                    .into_iter()\n                    .map(|tool| {\n                        serde_json::json!({\n                            \"type\": \"function\",\n                            \"function\": {\n                                \"name\": tool.name,\n                                \"description\": tool.description,\n                                \"parameters\": tool.parameters\n                            }\n                        })\n                    })\n                    .collect()\n            }),\n        };\n\n        debug!(\"Sending request to Ollama: {:?}\", ollama_request);\n\n        if let Some(callback) = streaming_callback {\n            ollama_request.stream = true;\n            self.try_send_request_streaming(\u0026ollama_request, callback)\n                .await\n        } else {\n            self.try_send_request(\u0026ollama_request).await\n        }\n    }\n}\n","traces":[{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":2}},{"line":85,"address":[],"length":0,"stats":{"Line":4}},{"line":86,"address":[],"length":0,"stats":{"Line":4}},{"line":89,"address":[],"length":0,"stats":{"Line":4}},{"line":91,"address":[],"length":0,"stats":{"Line":4}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":102,"address":[],"length":0,"stats":{"Line":4}},{"line":103,"address":[],"length":0,"stats":{"Line":4}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":6}},{"line":109,"address":[],"length":0,"stats":{"Line":4}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":4}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":1}},{"line":140,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":142,"address":[],"length":0,"stats":{"Line":1}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":2}},{"line":150,"address":[],"length":0,"stats":{"Line":2}},{"line":151,"address":[],"length":0,"stats":{"Line":2}},{"line":152,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[],"length":0,"stats":{"Line":2}},{"line":158,"address":[],"length":0,"stats":{"Line":2}},{"line":163,"address":[],"length":0,"stats":{"Line":4}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":168,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":4}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":2}},{"line":186,"address":[],"length":0,"stats":{"Line":2}},{"line":187,"address":[],"length":0,"stats":{"Line":2}},{"line":188,"address":[],"length":0,"stats":{"Line":2}},{"line":189,"address":[],"length":0,"stats":{"Line":2}},{"line":191,"address":[],"length":0,"stats":{"Line":11}},{"line":192,"address":[],"length":0,"stats":{"Line":699}},{"line":194,"address":[],"length":0,"stats":{"Line":3}},{"line":195,"address":[],"length":0,"stats":{"Line":3}},{"line":196,"address":[],"length":0,"stats":{"Line":3}},{"line":200,"address":[],"length":0,"stats":{"Line":2}},{"line":201,"address":[],"length":0,"stats":{"Line":2}},{"line":205,"address":[],"length":0,"stats":{"Line":4}},{"line":210,"address":[],"length":0,"stats":{"Line":2}},{"line":211,"address":[],"length":0,"stats":{"Line":2}},{"line":212,"address":[],"length":0,"stats":{"Line":2}},{"line":215,"address":[],"length":0,"stats":{"Line":3}},{"line":218,"address":[],"length":0,"stats":{"Line":345}},{"line":224,"address":[],"length":0,"stats":{"Line":2}},{"line":227,"address":[],"length":0,"stats":{"Line":3}},{"line":228,"address":[],"length":0,"stats":{"Line":1}},{"line":229,"address":[],"length":0,"stats":{"Line":1}},{"line":234,"address":[],"length":0,"stats":{"Line":4}},{"line":235,"address":[],"length":0,"stats":{"Line":1}},{"line":236,"address":[],"length":0,"stats":{"Line":1}},{"line":237,"address":[],"length":0,"stats":{"Line":1}},{"line":238,"address":[],"length":0,"stats":{"Line":1}},{"line":242,"address":[],"length":0,"stats":{"Line":2}},{"line":243,"address":[],"length":0,"stats":{"Line":2}},{"line":244,"address":[],"length":0,"stats":{"Line":2}},{"line":245,"address":[],"length":0,"stats":{"Line":2}},{"line":246,"address":[],"length":0,"stats":{"Line":2}},{"line":259,"address":[],"length":0,"stats":{"Line":4}},{"line":262,"address":[],"length":0,"stats":{"Line":4}},{"line":263,"address":[],"length":0,"stats":{"Line":4}},{"line":264,"address":[],"length":0,"stats":{"Line":4}},{"line":268,"address":[],"length":0,"stats":{"Line":4}},{"line":271,"address":[],"length":0,"stats":{"Line":4}},{"line":274,"address":[],"length":0,"stats":{"Line":4}},{"line":277,"address":[],"length":0,"stats":{"Line":6}},{"line":294,"address":[],"length":0,"stats":{"Line":4}},{"line":296,"address":[],"length":0,"stats":{"Line":6}},{"line":299,"address":[],"length":0,"stats":{"Line":5}},{"line":301,"address":[],"length":0,"stats":{"Line":8}}],"covered":81,"coverable":99},{"path":["/","Users","stippi","projects","code-assistant","src","llm","openai.rs"],"content":"use crate::llm::{\n    types::*, ApiError, ApiErrorContext, LLMProvider, RateLimitHandler, StreamingCallback,\n};\nuse anyhow::Result;\nuse async_trait::async_trait;\nuse reqwest::{Client, Response, StatusCode};\nuse serde::{Deserialize, Serialize};\nuse std::time::Duration;\nuse tokio::time::sleep;\nuse tracing::{debug, warn};\n\n#[derive(Debug, Serialize, Clone)]\nstruct OpenAIRequest {\n    model: String,\n    messages: Vec\u003cOpenAIChatMessage\u003e,\n    temperature: f32,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    stream: Option\u003cbool\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    tools: Option\u003cVec\u003cserde_json::Value\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    tool_choice: Option\u003cserde_json::Value\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    stream_options: Option\u003cStreamOptions\u003e,\n}\n\n#[derive(Debug, Serialize, Clone)]\nstruct StreamOptions {\n    include_usage: bool,\n}\n\nimpl OpenAIRequest {\n    fn into_streaming(mut self) -\u003e Self {\n        self.stream = Some(true);\n        self.stream_options = Some(StreamOptions {\n            include_usage: true,\n        });\n        self\n    }\n\n    fn into_non_streaming(mut self) -\u003e Self {\n        self.stream = None;\n        self.stream_options = None;\n        self\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\nstruct OpenAIChatMessage {\n    role: String,\n    #[serde(default)]\n    content: String,\n    #[serde(default)]\n    tool_calls: Option\u003cVec\u003cOpenAIToolCall\u003e\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\nstruct OpenAIToolCall {\n    id: String,\n    #[serde(rename = \"type\")]\n    call_type: String,\n    function: OpenAIFunction,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\nstruct OpenAIFunction {\n    name: String,\n    arguments: String,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OpenAIResponse {\n    choices: Vec\u003cOpenAIChoice\u003e,\n    usage: OpenAIUsage,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OpenAIChoice {\n    message: OpenAIChatMessage,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OpenAIStreamResponse {\n    choices: Vec\u003cOpenAIStreamChoice\u003e,\n    #[serde(default)]\n    usage: Option\u003cOpenAIUsage\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OpenAIStreamChoice {\n    delta: OpenAIDelta,\n    #[serde(rename = \"finish_reason\")]\n    finish_reason: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OpenAIDelta {\n    #[serde(default)]\n    content: Option\u003cString\u003e,\n    #[allow(dead_code)]\n    #[serde(default)]\n    role: Option\u003cString\u003e,\n    #[serde(default)]\n    tool_calls: Option\u003cVec\u003cOpenAIToolCallDelta\u003e\u003e,\n}\n\n#[derive(Debug, Deserialize, Clone)]\nstruct OpenAIToolCallDelta {\n    #[allow(dead_code)]\n    #[serde(default)]\n    index: usize,\n    #[serde(default)]\n    id: Option\u003cString\u003e,\n    #[allow(dead_code)]\n    #[serde(rename = \"type\")]\n    #[serde(default)]\n    call_type: Option\u003cString\u003e,\n    #[serde(default)]\n    function: Option\u003cOpenAIFunctionDelta\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OpenAIUsage {\n    prompt_tokens: u32,\n    completion_tokens: u32,\n    #[allow(dead_code)]\n    total_tokens: u32,\n}\n\n#[derive(Debug, Deserialize, Clone)]\nstruct OpenAIFunctionDelta {\n    #[serde(default)]\n    name: Option\u003cString\u003e,\n    #[serde(default)]\n    arguments: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OpenAIErrorResponse {\n    error: OpenAIError,\n}\n\n#[derive(Debug, Deserialize)]\nstruct OpenAIError {\n    message: String,\n    #[serde(rename = \"type\")]\n    code: Option\u003cString\u003e,\n}\n\n/// Rate limit information extracted from response headers\n#[derive(Debug)]\nstruct OpenAIRateLimitInfo {\n    requests_limit: Option\u003cu32\u003e,\n    requests_remaining: Option\u003cu32\u003e,\n    requests_reset: Option\u003cDuration\u003e,\n    tokens_limit: Option\u003cu32\u003e,\n    tokens_remaining: Option\u003cu32\u003e,\n    tokens_reset: Option\u003cDuration\u003e,\n}\n\nimpl RateLimitHandler for OpenAIRateLimitInfo {\n    fn from_response(response: \u0026Response) -\u003e Self {\n        let headers = response.headers();\n\n        fn parse_header\u003cT: std::str::FromStr\u003e(\n            headers: \u0026reqwest::header::HeaderMap,\n            name: \u0026str,\n        ) -\u003e Option\u003cT\u003e {\n            headers\n                .get(name)\n                .and_then(|h| h.to_str().ok())\n                .and_then(|s| s.parse().ok())\n        }\n\n        fn parse_duration(headers: \u0026reqwest::header::HeaderMap, name: \u0026str) -\u003e Option\u003cDuration\u003e {\n            headers\n                .get(name)\n                .and_then(|h| h.to_str().ok())\n                .and_then(|s| {\n                    // Parse OpenAI's duration format (e.g., \"1s\", \"6m0s\")\n                    let mut seconds = 0u64;\n                    let mut current_num = String::new();\n\n                    for c in s.chars() {\n                        match c {\n                            '0'..='9' =\u003e current_num.push(c),\n                            'm' =\u003e {\n                                if let Ok(mins) = current_num.parse::\u003cu64\u003e() {\n                                    seconds += mins * 60;\n                                }\n                                current_num.clear();\n                            }\n                            's' =\u003e {\n                                if let Ok(secs) = current_num.parse::\u003cu64\u003e() {\n                                    seconds += secs;\n                                }\n                                current_num.clear();\n                            }\n                            _ =\u003e current_num.clear(),\n                        }\n                    }\n                    Some(Duration::from_secs(seconds))\n                })\n        }\n\n        Self {\n            requests_limit: parse_header(headers, \"x-ratelimit-limit-requests\"),\n            requests_remaining: parse_header(headers, \"x-ratelimit-remaining-requests\"),\n            requests_reset: parse_duration(headers, \"x-ratelimit-reset-requests\"),\n            tokens_limit: parse_header(headers, \"x-ratelimit-limit-tokens\"),\n            tokens_remaining: parse_header(headers, \"x-ratelimit-remaining-tokens\"),\n            tokens_reset: parse_duration(headers, \"x-ratelimit-reset-tokens\"),\n        }\n    }\n\n    fn get_retry_delay(\u0026self) -\u003e Duration {\n        // Take the longer of the two reset times if both are present\n        let mut delay = Duration::from_secs(2); // Default fallback\n\n        if let Some(requests_reset) = self.requests_reset {\n            delay = delay.max(requests_reset);\n        }\n\n        if let Some(tokens_reset) = self.tokens_reset {\n            delay = delay.max(tokens_reset);\n        }\n\n        // Add a small buffer\n        delay + Duration::from_secs(1)\n    }\n\n    fn log_status(\u0026self) {\n        debug!(\n            \"OpenAI Rate limits - Requests: {}/{} (reset in: {}s), Tokens: {}/{} (reset in: {}s)\",\n            self.requests_remaining\n                .map_or(\"?\".to_string(), |r| r.to_string()),\n            self.requests_limit\n                .map_or(\"?\".to_string(), |l| l.to_string()),\n            self.requests_reset.map_or(0, |d| d.as_secs()),\n            self.tokens_remaining\n                .map_or(\"?\".to_string(), |r| r.to_string()),\n            self.tokens_limit.map_or(\"?\".to_string(), |l| l.to_string()),\n            self.tokens_reset.map_or(0, |d| d.as_secs()),\n        );\n    }\n}\n\npub struct OpenAIClient {\n    client: Client,\n    api_key: String,\n    base_url: String,\n    model: String,\n}\n\nimpl OpenAIClient {\n    pub fn new(api_key: String, model: String) -\u003e Self {\n        Self {\n            client: Client::new(),\n            api_key,\n            base_url: \"https://api.openai.com/v1\".to_string(),\n            model,\n        }\n    }\n\n    #[cfg(test)]\n    pub fn new_with_base_url(api_key: String, model: String, base_url: String) -\u003e Self {\n        Self {\n            client: Client::new(),\n            api_key,\n            base_url,\n            model,\n        }\n    }\n\n    fn get_url(\u0026self) -\u003e String {\n        format!(\"{}/chat/completions\", self.base_url)\n    }\n\n    fn convert_message(message: \u0026Message) -\u003e OpenAIChatMessage {\n        OpenAIChatMessage {\n            role: match message.role {\n                MessageRole::User =\u003e \"user\".to_string(),\n                MessageRole::Assistant =\u003e \"assistant\".to_string(),\n            },\n            content: match \u0026message.content {\n                MessageContent::Text(text) =\u003e text.clone(),\n                MessageContent::Structured(_) =\u003e {\n                    // For now, we'll just convert structured content to a simple text message\n                    // This could be enhanced to handle OpenAI's specific formats\n                    \"[Structured content not supported]\".to_string()\n                }\n            },\n            tool_calls: None,\n        }\n    }\n\n    async fn send_with_retry(\n        \u0026self,\n        request: \u0026OpenAIRequest,\n        streaming_callback: Option\u003c\u0026StreamingCallback\u003e,\n        max_retries: u32,\n    ) -\u003e Result\u003cLLMResponse\u003e {\n        let mut attempts = 0;\n\n        loop {\n            match if let Some(callback) = streaming_callback {\n                self.try_send_request_streaming(request, callback).await\n            } else {\n                self.try_send_request(request).await\n            } {\n                Ok((response, rate_limits)) =\u003e {\n                    rate_limits.log_status();\n                    return Ok(response);\n                }\n                Err(e) =\u003e {\n                    let rate_limits = e\n                        .downcast_ref::\u003cApiErrorContext\u003cOpenAIRateLimitInfo\u003e\u003e()\n                        .and_then(|ctx| ctx.rate_limits.as_ref());\n\n                    match e.downcast_ref::\u003cApiError\u003e() {\n                        Some(ApiError::RateLimit(_)) =\u003e {\n                            if let Some(rate_limits) = rate_limits {\n                                if attempts \u003c max_retries {\n                                    attempts += 1;\n                                    let delay = rate_limits.get_retry_delay();\n                                    warn!(\n                                        \"OpenAI rate limit hit (attempt {}/{}), waiting {} seconds before retry\",\n                                        attempts,\n                                        max_retries,\n                                        delay.as_secs()\n                                    );\n                                    sleep(delay).await;\n                                    continue;\n                                }\n                            }\n                        }\n                        Some(ApiError::ServiceError(_)) | Some(ApiError::NetworkError(_)) =\u003e {\n                            if attempts \u003c max_retries {\n                                attempts += 1;\n                                let delay = Duration::from_secs(2u64.pow(attempts - 1));\n                                warn!(\n                                    \"Error: {} (attempt {}/{}), retrying in {} seconds\",\n                                    e,\n                                    attempts,\n                                    max_retries,\n                                    delay.as_secs()\n                                );\n                                sleep(delay).await;\n                                continue;\n                            }\n                        }\n                        _ =\u003e {} // Don't retry other types of errors\n                    }\n                    return Err(e);\n                }\n            }\n        }\n    }\n\n    async fn check_response_error(response: Response) -\u003e Result\u003cResponse\u003e {\n        let status = response.status();\n        if status.is_success() {\n            debug!(\"Response status is success\");\n            return Ok(response);\n        }\n\n        let rate_limits = OpenAIRateLimitInfo::from_response(\u0026response);\n        let response_text = response\n            .text()\n            .await\n            .map_err(|e| ApiError::NetworkError(e.to_string()))?;\n\n        let error = if let Ok(error_response) =\n            serde_json::from_str::\u003cOpenAIErrorResponse\u003e(\u0026response_text)\n        {\n            match (status, error_response.error.code.as_deref()) {\n                (StatusCode::TOO_MANY_REQUESTS, _) =\u003e {\n                    ApiError::RateLimit(error_response.error.message)\n                }\n                (StatusCode::UNAUTHORIZED, _) =\u003e {\n                    ApiError::Authentication(error_response.error.message)\n                }\n                (StatusCode::BAD_REQUEST, _) =\u003e {\n                    ApiError::InvalidRequest(error_response.error.message)\n                }\n                (status, _) if status.is_server_error() =\u003e {\n                    ApiError::ServiceError(error_response.error.message)\n                }\n                _ =\u003e ApiError::Unknown(error_response.error.message),\n            }\n        } else {\n            ApiError::Unknown(format!(\"Status {}: {}\", status, response_text))\n        };\n\n        Err(ApiErrorContext {\n            error,\n            rate_limits: Some(rate_limits),\n        }\n        .into())\n    }\n\n    async fn try_send_request(\n        \u0026self,\n        request: \u0026OpenAIRequest,\n    ) -\u003e Result\u003c(LLMResponse, OpenAIRateLimitInfo)\u003e {\n        let request = request.clone().into_non_streaming();\n        let response = self\n            .client\n            .post(\u0026self.get_url())\n            .header(\"Authorization\", format!(\"Bearer {}\", self.api_key))\n            .header(\"Content-Type\", \"application/json\")\n            .json(\u0026request)\n            .send()\n            .await\n            .map_err(|e| ApiError::NetworkError(e.to_string()))?;\n\n        let response = Self::check_response_error(response).await?;\n        let rate_limits = OpenAIRateLimitInfo::from_response(\u0026response);\n\n        let response_text = response\n            .text()\n            .await\n            .map_err(|e| ApiError::NetworkError(e.to_string()))?;\n\n        // Parse the successful response\n        let openai_response: OpenAIResponse = serde_json::from_str(\u0026response_text)\n            .map_err(|e| ApiError::Unknown(format!(\"Failed to parse response: {}\", e)))?;\n\n        // Convert to our generic LLMResponse format\n        Ok((\n            LLMResponse {\n                content: {\n                    let mut blocks = Vec::new();\n\n                    // Add text content if present\n                    if !openai_response.choices[0].message.content.is_empty() {\n                        blocks.push(ContentBlock::Text {\n                            text: openai_response.choices[0].message.content.clone(),\n                        });\n                    }\n\n                    // Add tool calls if present\n                    if let Some(ref tool_calls) = openai_response.choices[0].message.tool_calls {\n                        for call in tool_calls {\n                            let input =\n                                serde_json::from_str(\u0026call.function.arguments).map_err(|e| {\n                                    ApiError::Unknown(format!(\n                                        \"Failed to parse tool arguments: {}\",\n                                        e\n                                    ))\n                                })?;\n                            blocks.push(ContentBlock::ToolUse {\n                                id: call.id.clone(),\n                                name: call.function.name.clone(),\n                                input,\n                            });\n                        }\n                    }\n\n                    blocks\n                },\n                usage: Usage {\n                    input_tokens: openai_response.usage.prompt_tokens,\n                    output_tokens: openai_response.usage.completion_tokens,\n                },\n            },\n            rate_limits,\n        ))\n    }\n\n    async fn try_send_request_streaming(\n        \u0026self,\n        request: \u0026OpenAIRequest,\n        streaming_callback: \u0026StreamingCallback,\n    ) -\u003e Result\u003c(LLMResponse, OpenAIRateLimitInfo)\u003e {\n        debug!(\"Sending streaming request\");\n        let request = request.clone().into_streaming();\n        let response = self\n            .client\n            .post(\u0026self.get_url())\n            .header(\"Authorization\", format!(\"Bearer {}\", self.api_key))\n            .header(\"Content-Type\", \"application/json\")\n            .json(\u0026request)\n            .send()\n            .await\n            .map_err(|e| ApiError::NetworkError(e.to_string()))?;\n\n        let mut response = Self::check_response_error(response).await?;\n\n        let mut accumulated_content: Option\u003cString\u003e = None;\n        let mut accumulated_tool_calls: Vec\u003cContentBlock\u003e = Vec::new();\n        let mut current_tool: Option\u003cOpenAIToolCallDelta\u003e = None;\n\n        let mut line_buffer = String::new();\n        let mut usage = None;\n\n        fn process_chunk(\n            chunk: \u0026[u8],\n            line_buffer: \u0026mut String,\n            accumulated_content: \u0026mut Option\u003cString\u003e,\n            current_tool: \u0026mut Option\u003cOpenAIToolCallDelta\u003e,\n            accumulated_tool_calls: \u0026mut Vec\u003cContentBlock\u003e,\n            callback: \u0026StreamingCallback,\n            usage: \u0026mut Option\u003cOpenAIUsage\u003e,\n        ) -\u003e Result\u003c()\u003e {\n            let chunk_str = std::str::from_utf8(chunk)?;\n\n            for c in chunk_str.chars() {\n                if c == '\\n' {\n                    if !line_buffer.is_empty() {\n                        process_sse_line(\n                            line_buffer,\n                            accumulated_content,\n                            current_tool,\n                            accumulated_tool_calls,\n                            callback,\n                            usage,\n                        )?;\n                        line_buffer.clear();\n                    }\n                } else {\n                    line_buffer.push(c);\n                }\n            }\n            Ok(())\n        }\n\n        fn process_sse_line(\n            line: \u0026str,\n            accumulated_content: \u0026mut Option\u003cString\u003e,\n            current_tool: \u0026mut Option\u003cOpenAIToolCallDelta\u003e,\n            accumulated_tool_calls: \u0026mut Vec\u003cContentBlock\u003e,\n            callback: \u0026StreamingCallback,\n            usage: \u0026mut Option\u003cOpenAIUsage\u003e,\n        ) -\u003e Result\u003c()\u003e {\n            if let Some(data) = line.strip_prefix(\"data: \") {\n                // Skip \"[DONE]\" message\n                if data == \"[DONE]\" {\n                    return Ok(());\n                }\n\n                if let Ok(chunk_response) = serde_json::from_str::\u003cOpenAIStreamResponse\u003e(data) {\n                    if let Some(delta) = chunk_response.choices.get(0) {\n                        // Handle content streaming\n                        if let Some(content) = \u0026delta.delta.content {\n                            callback(content)?;\n                            *accumulated_content = Some(\n                                accumulated_content\n                                    .as_ref()\n                                    .unwrap_or(\u0026String::new())\n                                    .clone()\n                                    + content,\n                            );\n                        }\n\n                        // Handle tool calls\n                        if let Some(tool_calls) = \u0026delta.delta.tool_calls {\n                            for tool_call in tool_calls {\n                                if let Some(function) = \u0026tool_call.function {\n                                    if tool_call.id.is_some() {\n                                        // New tool call\n                                        if let Some(prev_tool) = current_tool.take() {\n                                            accumulated_tool_calls\n                                                .push(OpenAIClient::build_tool_block(prev_tool)?);\n                                        }\n                                        *current_tool = Some(tool_call.clone());\n                                    } else if let Some(curr_tool) = current_tool {\n                                        // Update existing tool\n                                        if let Some(args) = \u0026function.arguments {\n                                            if let Some(ref mut curr_func) = curr_tool.function {\n                                                curr_func.arguments = Some(\n                                                    curr_func\n                                                        .arguments\n                                                        .as_ref()\n                                                        .unwrap_or(\u0026String::new())\n                                                        .clone()\n                                                        + args,\n                                                );\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        // Handle completion\n                        if delta.finish_reason.is_some() {\n                            if let Some(tool) = current_tool.take() {\n                                accumulated_tool_calls.push(OpenAIClient::build_tool_block(tool)?);\n                            }\n                        }\n                    }\n                    // Capture usage data from final chunk\n                    if let Some(chunk_usage) = chunk_response.usage {\n                        *usage = Some(chunk_usage);\n                    }\n                }\n            }\n            Ok(())\n        }\n\n        while let Some(chunk) = response.chunk().await? {\n            process_chunk(\n                \u0026chunk,\n                \u0026mut line_buffer,\n                \u0026mut accumulated_content,\n                \u0026mut current_tool,\n                \u0026mut accumulated_tool_calls,\n                streaming_callback,\n                \u0026mut usage,\n            )?;\n        }\n\n        // Process any remaining data in the buffer\n        if !line_buffer.is_empty() {\n            process_sse_line(\n                \u0026line_buffer,\n                \u0026mut accumulated_content,\n                \u0026mut current_tool,\n                \u0026mut accumulated_tool_calls,\n                streaming_callback,\n                \u0026mut usage,\n            )?;\n        }\n\n        let mut content = Vec::new();\n        if let Some(text) = accumulated_content {\n            content.push(ContentBlock::Text { text });\n        }\n        content.extend(accumulated_tool_calls);\n\n        Ok((\n            LLMResponse {\n                content,\n                usage: usage\n                    .map(|u| Usage {\n                        input_tokens: u.prompt_tokens,\n                        output_tokens: u.completion_tokens,\n                    })\n                    .unwrap_or(Usage {\n                        input_tokens: 0,\n                        output_tokens: 0,\n                    }),\n            },\n            OpenAIRateLimitInfo::from_response(\u0026response),\n        ))\n    }\n\n    fn build_tool_block(tool: OpenAIToolCallDelta) -\u003e Result\u003cContentBlock\u003e {\n        let function = tool\n            .function\n            .ok_or_else(|| anyhow::anyhow!(\"Tool call without function\"))?;\n        let name = function\n            .name\n            .ok_or_else(|| anyhow::anyhow!(\"Function without name\"))?;\n        let args = function.arguments.unwrap_or_default();\n\n        Ok(ContentBlock::ToolUse {\n            id: tool.id.unwrap_or_default(),\n            name,\n            input: serde_json::from_str(\u0026args)\n                .map_err(|e| anyhow::anyhow!(\"Invalid JSON in arguments: {}\", e))?,\n        })\n    }\n}\n\n#[async_trait]\nimpl LLMProvider for OpenAIClient {\n    async fn send_message(\n        \u0026self,\n        request: LLMRequest,\n        streaming_callback: Option\u003c\u0026StreamingCallback\u003e,\n    ) -\u003e Result\u003cLLMResponse\u003e {\n        let mut messages: Vec\u003cOpenAIChatMessage\u003e = Vec::new();\n\n        // Add system message\n        messages.push(OpenAIChatMessage {\n            role: \"system\".to_string(),\n            content: request.system_prompt,\n            tool_calls: None,\n        });\n\n        // Add conversation messages\n        messages.extend(request.messages.iter().map(Self::convert_message));\n\n        let openai_request = OpenAIRequest {\n            model: self.model.clone(),\n            messages,\n            temperature: 1.0,\n            stream: None,\n            stream_options: None,\n            tool_choice: match \u0026request.tools {\n                Some(_) =\u003e Some(serde_json::json!(\"required\")),\n                _ =\u003e None,\n            },\n            tools: request.tools.map(|tools| {\n                tools\n                    .into_iter()\n                    .map(|tool| {\n                        serde_json::json!({\n                            \"type\": \"function\",\n                            \"function\": {\n                                \"name\": tool.name,\n                                \"description\": tool.description,\n                                \"parameters\": tool.parameters\n                            }\n                        })\n                    })\n                    .collect()\n            }),\n        };\n\n        self.send_with_retry(\u0026openai_request, streaming_callback, 3)\n            .await\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":34,"address":[],"length":0,"stats":{"Line":2}},{"line":35,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":2}},{"line":38,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":2}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":4}},{"line":163,"address":[],"length":0,"stats":{"Line":4}},{"line":165,"address":[],"length":0,"stats":{"Line":16}},{"line":169,"address":[],"length":0,"stats":{"Line":16}},{"line":170,"address":[],"length":0,"stats":{"Line":16}},{"line":171,"address":[],"length":0,"stats":{"Line":32}},{"line":172,"address":[],"length":0,"stats":{"Line":32}},{"line":175,"address":[],"length":0,"stats":{"Line":8}},{"line":176,"address":[],"length":0,"stats":{"Line":8}},{"line":177,"address":[],"length":0,"stats":{"Line":8}},{"line":178,"address":[],"length":0,"stats":{"Line":16}},{"line":179,"address":[],"length":0,"stats":{"Line":8}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":4}},{"line":208,"address":[],"length":0,"stats":{"Line":4}},{"line":209,"address":[],"length":0,"stats":{"Line":4}},{"line":210,"address":[],"length":0,"stats":{"Line":4}},{"line":211,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":4}},{"line":233,"address":[],"length":0,"stats":{"Line":4}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":2}},{"line":268,"address":[],"length":0,"stats":{"Line":2}},{"line":275,"address":[],"length":0,"stats":{"Line":4}},{"line":276,"address":[],"length":0,"stats":{"Line":4}},{"line":279,"address":[],"length":0,"stats":{"Line":4}},{"line":281,"address":[],"length":0,"stats":{"Line":4}},{"line":285,"address":[],"length":0,"stats":{"Line":4}},{"line":297,"address":[],"length":0,"stats":{"Line":4}},{"line":303,"address":[],"length":0,"stats":{"Line":4}},{"line":306,"address":[],"length":0,"stats":{"Line":6}},{"line":307,"address":[],"length":0,"stats":{"Line":14}},{"line":309,"address":[],"length":0,"stats":{"Line":8}},{"line":311,"address":[],"length":0,"stats":{"Line":4}},{"line":312,"address":[],"length":0,"stats":{"Line":4}},{"line":313,"address":[],"length":0,"stats":{"Line":4}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":8}},{"line":361,"address":[],"length":0,"stats":{"Line":4}},{"line":362,"address":[],"length":0,"stats":{"Line":4}},{"line":363,"address":[],"length":0,"stats":{"Line":4}},{"line":364,"address":[],"length":0,"stats":{"Line":4}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":2}},{"line":406,"address":[],"length":0,"stats":{"Line":2}},{"line":407,"address":[],"length":0,"stats":{"Line":4}},{"line":408,"address":[],"length":0,"stats":{"Line":2}},{"line":409,"address":[],"length":0,"stats":{"Line":2}},{"line":410,"address":[],"length":0,"stats":{"Line":2}},{"line":412,"address":[],"length":0,"stats":{"Line":2}},{"line":414,"address":[],"length":0,"stats":{"Line":6}},{"line":415,"address":[],"length":0,"stats":{"Line":4}},{"line":417,"address":[],"length":0,"stats":{"Line":2}},{"line":418,"address":[],"length":0,"stats":{"Line":2}},{"line":420,"address":[],"length":0,"stats":{"Line":4}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":4}},{"line":426,"address":[],"length":0,"stats":{"Line":2}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":1}},{"line":437,"address":[],"length":0,"stats":{"Line":1}},{"line":438,"address":[],"length":0,"stats":{"Line":1}},{"line":443,"address":[],"length":0,"stats":{"Line":1}},{"line":444,"address":[],"length":0,"stats":{"Line":3}},{"line":445,"address":[],"length":0,"stats":{"Line":1}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":1}},{"line":453,"address":[],"length":0,"stats":{"Line":1}},{"line":454,"address":[],"length":0,"stats":{"Line":1}},{"line":455,"address":[],"length":0,"stats":{"Line":1}},{"line":460,"address":[],"length":0,"stats":{"Line":2}},{"line":462,"address":[],"length":0,"stats":{"Line":2}},{"line":463,"address":[],"length":0,"stats":{"Line":2}},{"line":464,"address":[],"length":0,"stats":{"Line":2}},{"line":467,"address":[],"length":0,"stats":{"Line":2}},{"line":471,"address":[],"length":0,"stats":{"Line":2}},{"line":476,"address":[],"length":0,"stats":{"Line":2}},{"line":477,"address":[],"length":0,"stats":{"Line":2}},{"line":478,"address":[],"length":0,"stats":{"Line":2}},{"line":485,"address":[],"length":0,"stats":{"Line":2}},{"line":486,"address":[],"length":0,"stats":{"Line":4}},{"line":488,"address":[],"length":0,"stats":{"Line":2}},{"line":490,"address":[],"length":0,"stats":{"Line":2}},{"line":491,"address":[],"length":0,"stats":{"Line":2}},{"line":492,"address":[],"length":0,"stats":{"Line":2}},{"line":494,"address":[],"length":0,"stats":{"Line":2}},{"line":495,"address":[],"length":0,"stats":{"Line":2}},{"line":497,"address":[],"length":0,"stats":{"Line":12}},{"line":506,"address":[],"length":0,"stats":{"Line":24}},{"line":508,"address":[],"length":0,"stats":{"Line":1091}},{"line":509,"address":[],"length":0,"stats":{"Line":1091}},{"line":510,"address":[],"length":0,"stats":{"Line":24}},{"line":512,"address":[],"length":0,"stats":{"Line":12}},{"line":513,"address":[],"length":0,"stats":{"Line":12}},{"line":514,"address":[],"length":0,"stats":{"Line":12}},{"line":515,"address":[],"length":0,"stats":{"Line":12}},{"line":516,"address":[],"length":0,"stats":{"Line":12}},{"line":517,"address":[],"length":0,"stats":{"Line":12}},{"line":519,"address":[],"length":0,"stats":{"Line":12}},{"line":522,"address":[],"length":0,"stats":{"Line":1067}},{"line":525,"address":[],"length":0,"stats":{"Line":12}},{"line":528,"address":[],"length":0,"stats":{"Line":12}},{"line":536,"address":[],"length":0,"stats":{"Line":24}},{"line":539,"address":[],"length":0,"stats":{"Line":2}},{"line":542,"address":[],"length":0,"stats":{"Line":10}},{"line":543,"address":[],"length":0,"stats":{"Line":10}},{"line":545,"address":[],"length":0,"stats":{"Line":2}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":2}},{"line":548,"address":[],"length":0,"stats":{"Line":2}},{"line":549,"address":[],"length":0,"stats":{"Line":2}},{"line":550,"address":[],"length":0,"stats":{"Line":2}},{"line":551,"address":[],"length":0,"stats":{"Line":2}},{"line":552,"address":[],"length":0,"stats":{"Line":2}},{"line":557,"address":[],"length":0,"stats":{"Line":16}},{"line":558,"address":[],"length":0,"stats":{"Line":18}},{"line":559,"address":[],"length":0,"stats":{"Line":6}},{"line":562,"address":[],"length":0,"stats":{"Line":1}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":1}},{"line":567,"address":[],"length":0,"stats":{"Line":10}},{"line":569,"address":[],"length":0,"stats":{"Line":5}},{"line":570,"address":[],"length":0,"stats":{"Line":10}},{"line":571,"address":[],"length":0,"stats":{"Line":5}},{"line":572,"address":[],"length":0,"stats":{"Line":5}},{"line":573,"address":[],"length":0,"stats":{"Line":5}},{"line":574,"address":[],"length":0,"stats":{"Line":5}},{"line":575,"address":[],"length":0,"stats":{"Line":5}},{"line":576,"address":[],"length":0,"stats":{"Line":5}},{"line":577,"address":[],"length":0,"stats":{"Line":5}},{"line":587,"address":[],"length":0,"stats":{"Line":10}},{"line":588,"address":[],"length":0,"stats":{"Line":3}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":12}},{"line":595,"address":[],"length":0,"stats":{"Line":1}},{"line":599,"address":[],"length":0,"stats":{"Line":10}},{"line":602,"address":[],"length":0,"stats":{"Line":38}},{"line":604,"address":[],"length":0,"stats":{"Line":12}},{"line":605,"address":[],"length":0,"stats":{"Line":12}},{"line":606,"address":[],"length":0,"stats":{"Line":12}},{"line":607,"address":[],"length":0,"stats":{"Line":12}},{"line":608,"address":[],"length":0,"stats":{"Line":12}},{"line":609,"address":[],"length":0,"stats":{"Line":12}},{"line":610,"address":[],"length":0,"stats":{"Line":12}},{"line":615,"address":[],"length":0,"stats":{"Line":2}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":2}},{"line":627,"address":[],"length":0,"stats":{"Line":2}},{"line":628,"address":[],"length":0,"stats":{"Line":1}},{"line":630,"address":[],"length":0,"stats":{"Line":2}},{"line":632,"address":[],"length":0,"stats":{"Line":2}},{"line":633,"address":[],"length":0,"stats":{"Line":2}},{"line":634,"address":[],"length":0,"stats":{"Line":2}},{"line":635,"address":[],"length":0,"stats":{"Line":2}},{"line":636,"address":[],"length":0,"stats":{"Line":3}},{"line":637,"address":[],"length":0,"stats":{"Line":1}},{"line":638,"address":[],"length":0,"stats":{"Line":1}},{"line":649,"address":[],"length":0,"stats":{"Line":1}},{"line":650,"address":[],"length":0,"stats":{"Line":2}},{"line":651,"address":[],"length":0,"stats":{"Line":1}},{"line":652,"address":[],"length":0,"stats":{"Line":2}},{"line":653,"address":[],"length":0,"stats":{"Line":1}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":4}},{"line":677,"address":[],"length":0,"stats":{"Line":4}},{"line":678,"address":[],"length":0,"stats":{"Line":4}},{"line":679,"address":[],"length":0,"stats":{"Line":4}},{"line":680,"address":[],"length":0,"stats":{"Line":4}},{"line":684,"address":[],"length":0,"stats":{"Line":4}},{"line":687,"address":[],"length":0,"stats":{"Line":4}},{"line":692,"address":[],"length":0,"stats":{"Line":4}},{"line":696,"address":[],"length":0,"stats":{"Line":6}},{"line":713,"address":[],"length":0,"stats":{"Line":4}},{"line":714,"address":[],"length":0,"stats":{"Line":20}}],"covered":172,"coverable":257},{"path":["/","Users","stippi","projects","code-assistant","src","llm","tests.rs"],"content":"use super::*;\nuse crate::types::ToolDefinition;\nuse crate::{AnthropicClient, LLMProvider, OpenAIClient};\nuse anyhow::Result;\nuse axum::extract::Path;\nuse axum::{response::IntoResponse, routing::post, Router};\nuse bytes::Bytes;\nuse futures::stream;\nuse serde_json::json;\nuse std::net::SocketAddr;\nuse std::sync::Arc;\nuse std::sync::Mutex;\nuse tokio::net::TcpListener;\n\n// Test scenario definition\n#[derive(Clone)]\nstruct TestCase {\n    name: String,\n    request: LLMRequest,\n    expected_chunks: Vec\u003cString\u003e,\n    expected_response: LLMResponse,\n}\n\nimpl TestCase {\n    fn text_only() -\u003e Self {\n        Self {\n            name: \"Simple text response\".to_string(),\n            request: LLMRequest {\n                messages: vec![Message {\n                    role: MessageRole::User,\n                    content: MessageContent::Text(\"Hello\".to_string()),\n                }],\n                system_prompt: \"You are a helpful assistant.\".to_string(),\n                tools: None,\n            },\n            expected_chunks: vec![\"Hi!\".to_string(), \" How can I help you today?\".to_string()],\n            expected_response: LLMResponse {\n                content: vec![ContentBlock::Text {\n                    text: \"Hi! How can I help you today?\".to_string(),\n                }],\n                usage: Usage {\n                    input_tokens: 10,\n                    output_tokens: 8,\n                },\n            },\n        }\n    }\n\n    fn with_tool() -\u003e Self {\n        Self {\n            name: \"Function calling response\".to_string(),\n            request: LLMRequest {\n                messages: vec![Message {\n                    role: MessageRole::User,\n                    content: MessageContent::Text(\"What's the weather?\".to_string()),\n                }],\n                system_prompt: \"Use the weather tool.\".to_string(),\n                tools: Some(vec![ToolDefinition {\n                    name: \"get_weather\".to_string(),\n                    description: \"Get current weather\".to_string(),\n                    parameters: json!({\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"location\": {\n                                \"type\": \"string\",\n                                \"description\": \"Location\"\n                            }\n                        },\n                        \"required\": [\"location\"]\n                    }),\n                }]),\n            },\n            expected_chunks: vec![],\n            expected_response: LLMResponse {\n                content: vec![ContentBlock::ToolUse {\n                    id: \"tool-0\".to_string(),\n                    name: \"get_weather\".to_string(),\n                    input: json!({\"location\": \"current\"}),\n                }],\n                usage: Usage {\n                    input_tokens: 15,\n                    output_tokens: 12,\n                },\n            },\n        }\n    }\n}\n\n// Chunk collector for streaming tests\n#[derive(Clone)]\nstruct ChunkCollector {\n    chunks: Arc\u003cMutex\u003cVec\u003cString\u003e\u003e\u003e,\n}\n\nimpl ChunkCollector {\n    fn new() -\u003e Self {\n        Self {\n            chunks: Arc::new(Mutex::new(Vec::new())),\n        }\n    }\n\n    fn callback(\u0026self) -\u003e StreamingCallback {\n        let chunks = self.chunks.clone();\n        Box::new(move |chunk: \u0026str| {\n            chunks.lock().unwrap().push(chunk.to_string());\n            Ok(())\n        })\n    }\n\n    fn get_chunks(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.chunks.lock().unwrap().clone()\n    }\n}\n\n// Response generator trait for provider-specific implementations\ntrait MockResponseGenerator: Send + Sync {\n    // Generates complete response for non-streaming case\n    fn generate_response(\u0026self, case: \u0026TestCase) -\u003e String;\n    // Generates chunks for streaming case\n    fn generate_chunks(\u0026self, case: \u0026TestCase) -\u003e Vec\u003cVec\u003cu8\u003e\u003e;\n}\n\n// OpenAI implementation\n#[derive(Clone)]\nstruct OpenAIMockGenerator;\n\nimpl MockResponseGenerator for OpenAIMockGenerator {\n    fn generate_response(\u0026self, case: \u0026TestCase) -\u003e String {\n        match case.request.tools {\n            None =\u003e json!({\n                \"choices\": [{\n                    \"message\": {\n                        \"role\": \"assistant\",\n                        \"content\": \"Hi! How can I help you today?\"\n                    }\n                }],\n                \"usage\": {\n                    \"prompt_tokens\": 10,\n                    \"completion_tokens\": 8,\n                    \"total_tokens\": 18\n                }\n            }),\n            Some(_) =\u003e json!({\n                \"choices\": [{\n                    \"message\": {\n                        \"role\": \"assistant\",\n                        \"tool_calls\": [{\n                            \"id\": \"tool-0\",\n                            \"type\": \"function\",\n                            \"function\": {\n                                \"name\": \"get_weather\",\n                                \"arguments\": \"{\\\"location\\\":\\\"current\\\"}\"\n                            }\n                        }]\n                    }\n                }],\n                \"usage\": {\n                    \"prompt_tokens\": 15,\n                    \"completion_tokens\": 12,\n                    \"total_tokens\": 27\n                }\n            }),\n        }\n        .to_string()\n    }\n\n    fn generate_chunks(\u0026self, case: \u0026TestCase) -\u003e Vec\u003cVec\u003cu8\u003e\u003e {\n        match case.request.tools {\n            None =\u003e vec![\n                // Initial content\n                b\"data: {\\\"choices\\\":[{\\\"delta\\\":{\\\"content\\\":\\\"Hi!\\\"},\\\"finish_reason\\\":null}]}\\n\\n\".to_vec(),\n                // More content\n                b\"data: {\\\"choices\\\":[{\\\"delta\\\":{\\\"content\\\":\\\" How can I help you today?\\\"},\\\"finish_reason\\\":null}]}\\n\\n\".to_vec(),\n                // Final message with usage\n                b\"data: {\\\"choices\\\":[{\\\"delta\\\":{},\\\"finish_reason\\\":\\\"stop\\\"}],\\\"usage\\\":{\\\"prompt_tokens\\\":10,\\\"completion_tokens\\\":8,\\\"total_tokens\\\":18}}\\n\\n\".to_vec(),\n                b\"data: [DONE]\\n\\n\".to_vec(),\n            ],\n            Some(_) =\u003e vec![\n                // Initial delta with function declaration\n                format!(\n                    \"data: {{\\\"choices\\\":[{{\\\"index\\\":0,\\\"delta\\\":{{\\\"role\\\":\\\"assistant\\\",\\\"content\\\":null,\\\"tool_calls\\\":[{{\\\"index\\\":0,\\\"id\\\":\\\"tool-0\\\",\\\"type\\\":\\\"function\\\",\\\"function\\\":{{\\\"name\\\":\\\"get_weather\\\",\\\"arguments\\\":\\\"\\\"}}}}]}}}}]}}\\n\\n\"\n                ).into_bytes(),\n                // Arguments streaming in chunks\n                format!(\n                    \"data: {{\\\"choices\\\":[{{\\\"index\\\":0,\\\"delta\\\":{{\\\"tool_calls\\\":[{{\\\"index\\\":0,\\\"function\\\":{{\\\"arguments\\\":\\\"{{\\\\\\\"\\\"}}}}]}}}}]}}\\n\\n\"\n                ).into_bytes(),\n                format!(\n                    \"data: {{\\\"choices\\\":[{{\\\"index\\\":0,\\\"delta\\\":{{\\\"tool_calls\\\":[{{\\\"index\\\":0,\\\"function\\\":{{\\\"arguments\\\":\\\"location\\\\\\\"\\\"}}}}]}}}}]}}\\n\\n\"\n                ).into_bytes(),\n                format!(\n                    \"data: {{\\\"choices\\\":[{{\\\"index\\\":0,\\\"delta\\\":{{\\\"tool_calls\\\":[{{\\\"index\\\":0,\\\"function\\\":{{\\\"arguments\\\":\\\":\\\\\\\"\\\"}}}}]}}}}]}}\\n\\n\"\n                ).into_bytes(),\n                format!(\n                    \"data: {{\\\"choices\\\":[{{\\\"index\\\":0,\\\"delta\\\":{{\\\"tool_calls\\\":[{{\\\"index\\\":0,\\\"function\\\":{{\\\"arguments\\\":\\\"current\\\"}}}}]}}}}]}}\\n\\n\"\n                ).into_bytes(),\n                format!(\n                    \"data: {{\\\"choices\\\":[{{\\\"index\\\":0,\\\"delta\\\":{{\\\"tool_calls\\\":[{{\\\"index\\\":0,\\\"function\\\":{{\\\"arguments\\\":\\\"\\\\\\\"}}\\\"}}}}]}}}}]}}\\n\\n\"\n                ).into_bytes(),\n                // Empty delta with finish reason\n                format!(\n                    \"data: {{\\\"choices\\\":[{{\\\"index\\\":0,\\\"delta\\\":{{}},\\\"finish_reason\\\":\\\"tool_calls\\\"}}]}}\\n\\n\"\n                ).into_bytes(),\n                b\"data: [DONE]\\n\\n\".to_vec(),\n            ],\n        }\n    }\n}\n\n// Anthropic implementation\n#[derive(Clone)]\nstruct AnthropicMockGenerator;\n\nimpl MockResponseGenerator for AnthropicMockGenerator {\n    fn generate_response(\u0026self, case: \u0026TestCase) -\u003e String {\n        match case.request.tools {\n            None =\u003e json!({\n                \"content\": [{\n                    \"type\": \"text\",\n                    \"text\": \"Hi! How can I help you today?\"\n                }],\n                \"usage\": {\n                    \"input_tokens\": 10,\n                    \"output_tokens\": 8\n                }\n            }),\n            Some(_) =\u003e json!({\n                \"content\": [{\n                    \"type\": \"tool_use\",\n                    \"id\": \"tool-0\",\n                    \"name\": \"get_weather\",\n                    \"input\": {\"location\": \"current\"}\n                }],\n                \"usage\": {\n                    \"input_tokens\": 15,\n                    \"output_tokens\": 12\n                }\n            }),\n        }\n        .to_string()\n    }\n\n    fn generate_chunks(\u0026self, case: \u0026TestCase) -\u003e Vec\u003cVec\u003cu8\u003e\u003e {\n        match case.request.tools {\n            None =\u003e vec![\n                b\"event: message_start\\ndata: {\\\"type\\\":\\\"message_start\\\",\\\"message\\\":{\\\"id\\\":\\\"msg_1\\\",\\\"type\\\":\\\"message\\\",\\\"role\\\":\\\"assistant\\\",\\\"model\\\":\\\"claude-3\\\",\\\"content\\\":[],\\\"stop_reason\\\":null,\\\"stop_sequence\\\":null,\\\"usage\\\":{\\\"input_tokens\\\":10,\\\"output_tokens\\\":8}}}\\n\\n\".to_vec(),\n                b\"event: content_block_start\\ndata: {\\\"type\\\":\\\"content_block_start\\\",\\\"index\\\":0,\\\"content_block\\\":{\\\"type\\\":\\\"text\\\",\\\"text\\\":\\\"\\\"}}\\n\\n\".to_vec(),\n                b\"event: content_block_delta\\ndata: {\\\"type\\\":\\\"content_block_delta\\\",\\\"index\\\":0,\\\"delta\\\":{\\\"type\\\":\\\"text_delta\\\",\\\"text\\\":\\\"Hi!\\\"}}\\n\\n\".to_vec(),\n                b\"event: content_block_delta\\ndata: {\\\"type\\\":\\\"content_block_delta\\\",\\\"index\\\":0,\\\"delta\\\":{\\\"type\\\":\\\"text_delta\\\",\\\"text\\\":\\\" How can I help you today?\\\"}}\\n\\n\".to_vec(),\n                b\"event: content_block_stop\\ndata: {\\\"type\\\":\\\"content_block_stop\\\",\\\"index\\\":0}\\n\\n\".to_vec(),\n                b\"event: message_delta\\ndata: {\\\"type\\\":\\\"message_delta\\\",\\\"delta\\\":{\\\"stop_reason\\\":\\\"end_turn\\\",\\\"stop_sequence\\\":null},\\\"usage\\\":{\\\"output_tokens\\\":8}}\\n\\n\".to_vec(),\n                b\"event: message_stop\\ndata: {\\\"type\\\":\\\"message_stop\\\"}\\n\\n\".to_vec(),\n            ],\n            Some(_) =\u003e vec![\n                b\"event: message_start\\ndata: {\\\"type\\\":\\\"message_start\\\",\\\"message\\\":{\\\"id\\\":\\\"msg_1\\\",\\\"type\\\":\\\"message\\\",\\\"role\\\":\\\"assistant\\\",\\\"model\\\":\\\"claude-3\\\",\\\"content\\\":[],\\\"stop_reason\\\":null,\\\"stop_sequence\\\":null,\\\"usage\\\":{\\\"input_tokens\\\":15,\\\"output_tokens\\\":2}}}\\n\\n\".to_vec(),\n                b\"event: content_block_start\\ndata: {\\\"type\\\":\\\"content_block_start\\\",\\\"index\\\":0,\\\"content_block\\\":{\\\"type\\\":\\\"tool_use\\\",\\\"id\\\":\\\"tool-0\\\",\\\"name\\\":\\\"get_weather\\\"}}\\n\\n\".to_vec(),\n                b\"event: content_block_delta\\ndata: {\\\"type\\\":\\\"content_block_delta\\\",\\\"index\\\":0,\\\"delta\\\":{\\\"type\\\":\\\"input_json_delta\\\",\\\"partial_json\\\":\\\"{\\\\\\\"location\\\\\\\":\\\"}}\\n\\n\".to_vec(),\n                b\"event: content_block_delta\\ndata: {\\\"type\\\":\\\"content_block_delta\\\",\\\"index\\\":0,\\\"delta\\\":{\\\"type\\\":\\\"input_json_delta\\\",\\\"partial_json\\\":\\\"\\\\\\\"current\\\\\\\"}\\\"}}\\n\\n\".to_vec(),\n                b\"event: content_block_stop\\ndata: {\\\"type\\\":\\\"content_block_stop\\\",\\\"index\\\":0}\\n\\n\".to_vec(),\n                b\"event: message_delta\\ndata: {\\\"type\\\":\\\"message_delta\\\",\\\"delta\\\":{\\\"stop_reason\\\":\\\"tool_use\\\",\\\"stop_sequence\\\":null},\\\"usage\\\":{\\\"output_tokens\\\":12}}\\n\\n\".to_vec(),\n                b\"event: message_stop\\ndata: {\\\"type\\\":\\\"message_stop\\\"}\\n\\n\".to_vec(),\n            ],\n        }\n    }\n}\n\n// Vertex implementation\n#[derive(Clone)]\nstruct VertexMockGenerator;\n\nimpl MockResponseGenerator for VertexMockGenerator {\n    fn generate_response(\u0026self, case: \u0026TestCase) -\u003e String {\n        match case.request.tools {\n            None =\u003e json!({\n                \"candidates\": [{\n                    \"content\": {\n                        \"parts\": [{\n                            \"text\": \"Hi! How can I help you today?\"\n                        }],\n                        \"role\": \"model\"\n                    }\n                }],\n                \"usageMetadata\": {\n                    \"promptTokenCount\": 10,\n                    \"candidatesTokenCount\": 8,\n                    \"totalTokenCount\": 18\n                }\n            }),\n            Some(_) =\u003e json!({\n                \"candidates\": [{\n                    \"content\": {\n                        \"parts\": [{\n                            \"functionCall\": {\n                                \"name\": \"get_weather\",\n                                \"args\": {\"location\": \"current\"}\n                            }\n                        }],\n                        \"role\": \"model\"\n                    }\n                }],\n                \"usageMetadata\": {\n                    \"promptTokenCount\": 15,\n                    \"candidatesTokenCount\": 12,\n                    \"totalTokenCount\": 27\n                }\n            }),\n        }\n        .to_string()\n    }\n\n    fn generate_chunks(\u0026self, case: \u0026TestCase) -\u003e Vec\u003cVec\u003cu8\u003e\u003e {\n        match case.request.tools {\n            None =\u003e vec![\n                format!(\n                    \"data: {}\\n\\n\",\n                    json!({\n                        \"candidates\": [{\n                            \"content\": {\n                                \"parts\": [{\"text\": \"Hi!\"}],\n                                \"role\": \"model\"\n                            }\n                        }]\n                    })\n                )\n                .into_bytes(),\n                format!(\n                    \"data: {}\\n\\n\",\n                    json!({\n                        \"candidates\": [{\n                            \"content\": {\n                                \"parts\": [{\"text\": \" How can I help you today?\"}],\n                                \"role\": \"model\"\n                            }\n                        }],\n                        \"usageMetadata\": {\n                            \"promptTokenCount\": 10,\n                            \"candidatesTokenCount\": 8,\n                            \"totalTokenCount\": 18\n                        }\n                    })\n                )\n                .into_bytes(),\n            ],\n            Some(_) =\u003e vec![format!(\n                \"data: {}\\n\\n\",\n                json!({\n                    \"candidates\": [{\n                        \"content\": {\n                            \"parts\": [{\n                                \"functionCall\": {\n                                    \"name\": \"get_weather\",\n                                    \"args\": {\"location\": \"current\"}\n                                }\n                            }],\n                            \"role\": \"model\"\n                        }\n                    }],\n                    \"usageMetadata\": {\n                        \"promptTokenCount\": 15,\n                        \"candidatesTokenCount\": 12,\n                        \"totalTokenCount\": 27\n                    }\n                })\n            )\n            .into_bytes()],\n        }\n    }\n}\n\n// Ollama implementation\n#[derive(Clone)]\nstruct OllamaMockGenerator;\n\nimpl MockResponseGenerator for OllamaMockGenerator {\n    fn generate_response(\u0026self, case: \u0026TestCase) -\u003e String {\n        match case.request.tools {\n            None =\u003e json!({\n                \"message\": {\n                    \"content\": \"Hi! How can I help you today?\"\n                },\n                \"done\": true,\n                \"prompt_eval_count\": 10,\n                \"eval_count\": 8\n            }),\n            Some(_) =\u003e json!({\n                \"message\": {\n                    \"content\": \"\",\n                    \"tool_calls\": [{\n                        \"function\": {\n                            \"name\": \"get_weather\",\n                            \"arguments\": { \"location\": \"current\" }\n                        }\n                    }]\n                },\n                \"done\": true,\n                \"prompt_eval_count\": 15,\n                \"eval_count\": 12\n            }),\n        }\n        .to_string()\n    }\n\n    fn generate_chunks(\u0026self, case: \u0026TestCase) -\u003e Vec\u003cVec\u003cu8\u003e\u003e {\n        match case.request.tools {\n            None =\u003e vec![\n                format!(\n                    \"{}\\n\",\n                    json!({\n                        \"message\": {\n                            \"content\": \"Hi!\"\n                        },\n                        \"done\": false,\n                        \"prompt_eval_count\": 10,\n                        \"eval_count\": 4\n                    })\n                )\n                .into_bytes(),\n                format!(\n                    \"{}\\n\",\n                    json!({\n                        \"message\": {\n                            \"content\": \" How can I help you today?\"\n                        },\n                        \"done\": true,\n                        \"prompt_eval_count\": 10,\n                        \"eval_count\": 8\n                    })\n                )\n                .into_bytes(),\n            ],\n            Some(_) =\u003e vec![format!(\n                \"{}\\n\",\n                json!({\n                    \"message\": {\n                        \"content\": \"\",\n                        \"tool_calls\": [{\n                            \"function\": {\n                                \"name\": \"get_weather\",\n                                \"arguments\": { \"location\": \"current\" }\n                            }\n                        }]\n                    },\n                    \"done\": true,\n                    \"prompt_eval_count\": 15,\n                    \"eval_count\": 12\n                })\n            )\n            .into_bytes()],\n        }\n    }\n}\n\n// Helper to create a mock server\nasync fn create_mock_server(\n    test_case: TestCase,\n    generator: impl MockResponseGenerator + Clone + 'static,\n) -\u003e String {\n    let app = Router::new().route(\n        \"/*path\",\n        post(\n            move |Path(path): Path\u003cString\u003e, req: axum::extract::Json\u003cserde_json::Value\u003e| {\n                let generator = generator.clone();\n                let test_case = test_case.clone();\n                async move {\n                    let is_streaming = path.contains(\"stream\")\n                        || req.get(\"stream\").and_then(|v| v.as_bool()).unwrap_or(false);\n\n                    if is_streaming {\n                        let chunks = generator.generate_chunks(\u0026test_case);\n                        let stream = stream::iter(\n                            chunks\n                                .into_iter()\n                                .map(|chunk| Ok::\u003c_, std::io::Error\u003e(Bytes::from(chunk))),\n                        );\n\n                        axum::response::Response::builder()\n                            .status(axum::http::StatusCode::OK)\n                            .header(\"content-type\", \"text/event-stream\")\n                            .body(axum::body::Body::from_stream(stream))\n                            .unwrap()\n                    } else {\n                        (\n                            axum::http::StatusCode::OK,\n                            axum::Json(\n                                serde_json::from_str::\u003cserde_json::Value\u003e(\n                                    \u0026generator.generate_response(\u0026test_case),\n                                )\n                                .unwrap(),\n                            ),\n                        )\n                            .into_response()\n                    }\n                }\n            },\n        ),\n    );\n\n    let addr = SocketAddr::from(([127, 0, 0, 1], 0));\n    let listener = TcpListener::bind(addr).await.unwrap();\n    let server_addr = listener.local_addr().unwrap();\n\n    tokio::spawn(async move {\n        axum::serve(listener, app).await.unwrap();\n    });\n\n    format!(\"http://{}\", server_addr)\n}\n\n// Run all test cases for a given provider configuration\nasync fn run_provider_tests\u003cT: MockResponseGenerator + Clone + 'static\u003e(\n    provider_name: \u0026str,\n    create_client: impl Fn(\u0026str) -\u003e Box\u003cdyn LLMProvider\u003e,\n    generator: T,\n) -\u003e Result\u003c()\u003e {\n    let test_cases = vec![TestCase::text_only(), TestCase::with_tool()];\n\n    for case in test_cases {\n        println!(\"Running {} test case: {}\", provider_name, case.name);\n\n        let base_url = create_mock_server(case.clone(), generator.clone()).await;\n        let client = create_client(\u0026base_url);\n\n        // Test non-streaming\n        let response = client.send_message(case.request.clone(), None).await?;\n\n        assert_eq!(\n            response.content, case.expected_response.content,\n            \"Non-streaming content mismatch\"\n        );\n        assert_eq!(\n            response.usage, case.expected_response.usage,\n            \"Non-streaming usage mismatch\"\n        );\n\n        // Test streaming\n        let collector = ChunkCollector::new();\n        let callback = collector.callback();\n\n        let response = client\n            .send_message(case.request.clone(), Some(\u0026callback))\n            .await?;\n\n        assert_eq!(\n            response.content, case.expected_response.content,\n            \"Streaming content mismatch\"\n        );\n        assert_eq!(\n            collector.get_chunks(),\n            case.expected_chunks,\n            \"Streaming chunks mismatch\"\n        );\n    }\n\n    Ok(())\n}\n\n#[tokio::test]\nasync fn test_openai_provider() -\u003e Result\u003c()\u003e {\n    run_provider_tests(\n        \"OpenAI\",\n        |url| {\n            Box::new(OpenAIClient::new_with_base_url(\n                \"test-key\".to_string(),\n                \"gpt-4\".to_string(),\n                url.to_string(),\n            ))\n        },\n        OpenAIMockGenerator,\n    )\n    .await\n}\n\n#[tokio::test]\nasync fn test_anthropic_provider() -\u003e Result\u003c()\u003e {\n    run_provider_tests(\n        \"Anthropic\",\n        |url| {\n            Box::new(AnthropicClient::new_with_base_url(\n                \"test-key\".to_string(),\n                \"claude-3\".to_string(),\n                url.to_string(),\n            ))\n        },\n        AnthropicMockGenerator,\n    )\n    .await\n}\n\n#[tokio::test]\nasync fn test_vertex_provider() -\u003e Result\u003c()\u003e {\n    run_provider_tests(\n        \"Vertex\",\n        |url| {\n            Box::new(VertexClient::new_with_base_url(\n                \"test-key\".to_string(),\n                \"gemini-pro\".to_string(),\n                url.to_string(),\n            ))\n        },\n        VertexMockGenerator,\n    )\n    .await\n}\n\n#[tokio::test]\nasync fn test_ollama_provider() -\u003e Result\u003c()\u003e {\n    run_provider_tests(\n        \"Ollama\",\n        |url| {\n            Box::new(OllamaClient::new_with_base_url(\n                \"llama2\".to_string(),\n                4096,\n                url.to_string(),\n            ))\n        },\n        OllamaMockGenerator,\n    )\n    .await\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","stippi","projects","code-assistant","src","llm","types.rs"],"content":"use crate::types::ToolDefinition;\nuse reqwest::Response;\nuse serde::{Deserialize, Serialize};\nuse std::time::Duration;\n\n/// Tracks token usage for a request/response pair\n#[derive(Debug, Deserialize, PartialEq, Clone)]\npub struct Usage {\n    /// Number of tokens in the input (prompt)\n    pub input_tokens: u32,\n    /// Number of tokens in the output (completion)\n    pub output_tokens: u32,\n}\n\n/// Generic request structure that can be mapped to different providers\n#[derive(Debug, Clone)]\npub struct LLMRequest {\n    pub messages: Vec\u003cMessage\u003e,\n    pub system_prompt: String,\n    pub tools: Option\u003cVec\u003cToolDefinition\u003e\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Message {\n    pub role: MessageRole,\n    pub content: MessageContent,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\n#[serde(rename_all = \"lowercase\")]\npub enum MessageRole {\n    User,\n    Assistant,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\n#[serde(untagged)]\npub enum MessageContent {\n    Text(String),\n    Structured(Vec\u003cContentBlock\u003e),\n}\n\n#[derive(Debug, Serialize, Deserialize, PartialEq, Clone)]\n#[serde(tag = \"type\")]\npub enum ContentBlock {\n    #[serde(rename = \"text\")]\n    Text { text: String },\n    #[serde(rename = \"tool_use\")]\n    ToolUse {\n        id: String,\n        name: String,\n        input: serde_json::Value,\n    },\n    #[serde(rename = \"tool_result\")]\n    ToolResult {\n        tool_use_id: String,\n        content: String,\n    },\n}\n\n/// Generic response structure\n#[derive(Debug, Deserialize, Clone)]\npub struct LLMResponse {\n    pub content: Vec\u003cContentBlock\u003e,\n    pub usage: Usage,\n}\n\n/// Common error types for all LLM providers\n#[derive(Debug, thiserror::Error)]\npub enum ApiError {\n    #[error(\"Rate limit exceeded: {0}\")]\n    RateLimit(String),\n\n    #[error(\"Authentication failed: {0}\")]\n    Authentication(String),\n\n    #[error(\"Invalid request: {0}\")]\n    InvalidRequest(String),\n\n    #[error(\"Service error: {0}\")]\n    ServiceError(String),\n\n    #[error(\"Network error: {0}\")]\n    NetworkError(String),\n\n    #[error(\"Unknown error: {0}\")]\n    Unknown(String),\n}\n\n/// Context wrapper for API errors that includes rate limit information\n#[derive(Debug, thiserror::Error)]\n#[error(\"{error}\")]\npub struct ApiErrorContext\u003cT\u003e {\n    pub error: ApiError,\n    pub rate_limits: Option\u003cT\u003e,\n}\n\n/// Base trait for rate limit information\npub trait RateLimitHandler: Sized {\n    /// Create a new instance from response headers\n    fn from_response(response: \u0026Response) -\u003e Self;\n\n    /// Get the delay duration before the next retry\n    fn get_retry_delay(\u0026self) -\u003e Duration;\n\n    /// Log the current rate limit status\n    fn log_status(\u0026self);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","stippi","projects","code-assistant","src","llm","vertex.rs"],"content":"use crate::llm::{\n    types::*, ApiError, ApiErrorContext, LLMProvider, RateLimitHandler, StreamingCallback,\n};\nuse anyhow::Result;\nuse async_trait::async_trait;\nuse reqwest::{Client, Response, StatusCode};\nuse serde::{Deserialize, Serialize};\nuse serde_json::json;\nuse std::time::Duration;\nuse tokio::time::sleep;\nuse tracing::{debug, trace, warn};\n\n#[derive(Debug, Serialize)]\nstruct VertexRequest {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    system_instruction: Option\u003cSystemInstruction\u003e,\n    contents: Vec\u003cVertexMessage\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    generation_config: Option\u003cGenerationConfig\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    tools: Option\u003cVec\u003cserde_json::Value\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    tool_config: Option\u003cserde_json::Value\u003e,\n}\n\n#[derive(Debug, Serialize)]\nstruct SystemInstruction {\n    parts: Parts,\n}\n\n#[derive(Debug, Serialize)]\nstruct Parts {\n    text: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct VertexMessage {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    role: Option\u003cString\u003e,\n    parts: Vec\u003cVertexPart\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct VertexPart {\n    #[serde(rename = \"functionCall\")]\n    function_call: Option\u003cVertexFunctionCall\u003e,\n    // Optional text field could be added if we get text responses\n    text: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize)]\nstruct GenerationConfig {\n    temperature: f32,\n    max_output_tokens: usize,\n}\n\n#[derive(Debug, Deserialize)]\nstruct VertexResponse {\n    candidates: Vec\u003cVertexCandidate\u003e,\n    #[serde(rename = \"usageMetadata\")]\n    usage_metadata: Option\u003cVertexUsageMetadata\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct VertexUsageMetadata {\n    #[serde(rename = \"promptTokenCount\")]\n    prompt_token_count: u32,\n    #[serde(rename = \"candidatesTokenCount\")]\n    candidates_token_count: u32,\n    #[allow(dead_code)]\n    #[serde(rename = \"totalTokenCount\")]\n    total_token_count: u32,\n}\n\n#[derive(Debug, Deserialize)]\nstruct VertexCandidate {\n    content: VertexContent,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct VertexContent {\n    parts: Vec\u003cVertexPart\u003e,\n    role: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct VertexFunctionCall {\n    name: String,\n    args: serde_json::Value,\n}\n\n#[derive(Debug, Deserialize)]\nstruct VertexErrorResponse {\n    error: VertexError,\n}\n\n#[derive(Debug, Deserialize)]\nstruct VertexError {\n    message: String,\n    code: Option\u003ci32\u003e,\n}\n\n/// Rate limit information extracted from response headers\n#[derive(Debug)]\nstruct VertexRateLimitInfo {\n    // TODO: Add actual rate limit fields once we know what headers Vertex AI uses\n    requests_remaining: Option\u003cu32\u003e,\n    #[allow(dead_code)]\n    requests_reset: Option\u003cDuration\u003e,\n}\n\nimpl RateLimitHandler for VertexRateLimitInfo {\n    fn from_response(_response: \u0026Response) -\u003e Self {\n        // TODO: Parse actual rate limit headers once we know what Vertex AI provides\n        Self {\n            requests_remaining: None,\n            requests_reset: None,\n        }\n    }\n\n    fn get_retry_delay(\u0026self) -\u003e Duration {\n        // Default exponential backoff strategy\n        Duration::from_secs(2)\n    }\n\n    fn log_status(\u0026self) {\n        debug!(\n            \"Vertex AI Rate limits - Requests remaining: {}\",\n            self.requests_remaining\n                .map_or(\"unknown\".to_string(), |r| r.to_string())\n        );\n    }\n}\n\npub struct VertexClient {\n    client: Client,\n    api_key: String,\n    model: String,\n    base_url: String,\n}\n\nimpl VertexClient {\n    pub fn new(api_key: String, model: String) -\u003e Self {\n        Self {\n            client: Client::new(),\n            api_key,\n            model,\n            base_url: \"https://generativelanguage.googleapis.com/v1beta\".to_string(),\n        }\n    }\n\n    #[cfg(test)]\n    pub fn new_with_base_url(api_key: String, model: String, base_url: String) -\u003e Self {\n        Self {\n            client: Client::new(),\n            api_key,\n            model,\n            base_url,\n        }\n    }\n\n    fn get_url(\u0026self, streaming: bool) -\u003e String {\n        if streaming {\n            format!(\n                \"{}/models/{}:streamGenerateContent\",\n                self.base_url, self.model\n            )\n        } else {\n            format!(\"{}/models/{}:generateContent\", self.base_url, self.model)\n        }\n    }\n\n    fn convert_message(message: \u0026Message) -\u003e VertexMessage {\n        let text = match \u0026message.content {\n            MessageContent::Text(text) =\u003e text.clone(),\n            MessageContent::Structured(_) =\u003e \"[Structured content not supported]\".to_string(),\n        };\n\n        VertexMessage {\n            role: Some(match message.role {\n                MessageRole::User =\u003e \"user\".to_string(),\n                MessageRole::Assistant =\u003e \"model\".to_string(),\n            }),\n            parts: vec![VertexPart {\n                text: Some(text),\n                function_call: None,\n            }],\n        }\n    }\n\n    async fn send_with_retry(\n        \u0026self,\n        request: \u0026VertexRequest,\n        streaming_callback: Option\u003c\u0026StreamingCallback\u003e,\n        max_retries: u32,\n    ) -\u003e Result\u003cLLMResponse\u003e {\n        let mut attempts = 0;\n\n        loop {\n            match if let Some(callback) = streaming_callback {\n                self.try_send_request_streaming(request, callback).await\n            } else {\n                self.try_send_request(request).await\n            } {\n                Ok((response, rate_limits)) =\u003e {\n                    rate_limits.log_status();\n                    return Ok(response);\n                }\n                Err(e) =\u003e {\n                    let rate_limits = e\n                        .downcast_ref::\u003cApiErrorContext\u003cVertexRateLimitInfo\u003e\u003e()\n                        .and_then(|ctx| ctx.rate_limits.as_ref());\n\n                    match e.downcast_ref::\u003cApiError\u003e() {\n                        Some(ApiError::RateLimit(_)) =\u003e {\n                            if attempts \u003c max_retries {\n                                attempts += 1;\n                                let delay = rate_limits\n                                    .map(|r| r.get_retry_delay())\n                                    .unwrap_or_else(|| Duration::from_secs(2u64.pow(attempts)));\n                                warn!(\n                                    \"Vertex AI rate limit hit (attempt {}/{}), waiting {} seconds before retry\",\n                                    attempts,\n                                    max_retries,\n                                    delay.as_secs()\n                                );\n                                sleep(delay).await;\n                                continue;\n                            }\n                        }\n                        Some(ApiError::ServiceError(_)) | Some(ApiError::NetworkError(_)) =\u003e {\n                            if attempts \u003c max_retries {\n                                attempts += 1;\n                                let delay = Duration::from_secs(2u64.pow(attempts - 1));\n                                warn!(\n                                    \"Error: {} (attempt {}/{}), retrying in {} seconds\",\n                                    e,\n                                    attempts,\n                                    max_retries,\n                                    delay.as_secs()\n                                );\n                                sleep(delay).await;\n                                continue;\n                            }\n                        }\n                        _ =\u003e {} // Don't retry other types of errors\n                    }\n                    return Err(e);\n                }\n            }\n        }\n    }\n\n    async fn handle_error_response(\n        \u0026self,\n        response: Response,\n    ) -\u003e Result\u003c(LLMResponse, VertexRateLimitInfo)\u003e {\n        let rate_limits = VertexRateLimitInfo::from_response(\u0026response);\n        let status = response.status();\n        let response_text = response\n            .text()\n            .await\n            .map_err(|e| ApiError::NetworkError(e.to_string()))?;\n\n        let error = if let Ok(error_response) =\n            serde_json::from_str::\u003cVertexErrorResponse\u003e(\u0026response_text)\n        {\n            match (status, error_response.error.code) {\n                (StatusCode::TOO_MANY_REQUESTS, _) =\u003e {\n                    ApiError::RateLimit(error_response.error.message)\n                }\n                (StatusCode::UNAUTHORIZED, _) =\u003e {\n                    ApiError::Authentication(error_response.error.message)\n                }\n                (StatusCode::BAD_REQUEST, _) =\u003e {\n                    ApiError::InvalidRequest(error_response.error.message)\n                }\n                (status, _) if status.is_server_error() =\u003e {\n                    ApiError::ServiceError(error_response.error.message)\n                }\n                _ =\u003e ApiError::Unknown(error_response.error.message),\n            }\n        } else {\n            ApiError::Unknown(format!(\"Status {}: {}\", status, response_text))\n        };\n\n        Err(ApiErrorContext {\n            error,\n            rate_limits: Some(rate_limits),\n        }\n        .into())\n    }\n\n    async fn try_send_request(\n        \u0026self,\n        request: \u0026VertexRequest,\n    ) -\u003e Result\u003c(LLMResponse, VertexRateLimitInfo)\u003e {\n        let url = self.get_url(false);\n\n        trace!(\n            \"Sending Vertex request to {}:\\n{}\",\n            self.model,\n            serde_json::to_string_pretty(request)?\n        );\n\n        let response = self\n            .client\n            .post(\u0026url)\n            .query(\u0026[(\"key\", \u0026self.api_key)])\n            .header(\"Content-Type\", \"application/json\")\n            .json(request)\n            .send()\n            .await\n            .map_err(|e| ApiError::NetworkError(e.to_string()))?;\n\n        if !response.status().is_success() {\n            return self.handle_error_response(response).await;\n        }\n\n        let rate_limits = VertexRateLimitInfo::from_response(\u0026response);\n\n        trace!(\"Response headers: {:?}\", response.headers());\n\n        let response_text = response\n            .text()\n            .await\n            .map_err(|e| ApiError::NetworkError(e.to_string()))?;\n\n        trace!(\n            \"Vertex response: {}\",\n            serde_json::to_string_pretty(\u0026serde_json::from_str::\u003cserde_json::Value\u003e(\n                \u0026response_text\n            )?)?\n        );\n\n        let vertex_response: VertexResponse = serde_json::from_str(\u0026response_text)\n            .map_err(|e| ApiError::Unknown(format!(\"Failed to parse response: {}\", e)))?;\n\n        // Convert to our generic LLMResponse format\n        let response = LLMResponse {\n            content: vertex_response\n                .candidates\n                .into_iter()\n                .flat_map(|candidate| {\n                    candidate\n                        .content\n                        .parts\n                        .into_iter()\n                        .enumerate()\n                        .map(|(index, part)| {\n                            if let Some(function_call) = part.function_call {\n                                ContentBlock::ToolUse {\n                                    id: format!(\"tool-{}\", index), // Generate a unique ID\n                                    name: function_call.name,\n                                    input: function_call.args,\n                                }\n                            } else if let Some(text) = part.text {\n                                ContentBlock::Text { text }\n                            } else {\n                                // Fallback if neither function_call nor text is present\n                                ContentBlock::Text {\n                                    text: \"Empty response part\".to_string(),\n                                }\n                            }\n                        })\n                        .collect::\u003cVec\u003c_\u003e\u003e()\n                })\n                .collect(),\n            usage: Usage {\n                input_tokens: vertex_response\n                    .usage_metadata\n                    .as_ref()\n                    .map(|u| u.prompt_token_count)\n                    .unwrap_or(0),\n                output_tokens: vertex_response\n                    .usage_metadata\n                    .as_ref()\n                    .map(|u| u.candidates_token_count)\n                    .unwrap_or(0),\n            },\n        };\n\n        Ok((response, rate_limits))\n    }\n\n    async fn try_send_request_streaming(\n        \u0026self,\n        request: \u0026VertexRequest,\n        streaming_callback: \u0026StreamingCallback,\n    ) -\u003e Result\u003c(LLMResponse, VertexRateLimitInfo)\u003e {\n        let mut response = self\n            .client\n            .post(\u0026self.get_url(true))\n            .query(\u0026[(\"key\", \u0026self.api_key), (\"alt\", \u0026\"sse\".to_string())])\n            .header(\"Content-Type\", \"application/json\")\n            .json(request)\n            .send()\n            .await\n            .map_err(|e| ApiError::NetworkError(e.to_string()))?;\n\n        if !response.status().is_success() {\n            return self.handle_error_response(response).await;\n        }\n\n        let rate_limits = VertexRateLimitInfo::from_response(\u0026response);\n\n        let mut content_blocks = Vec::new();\n        let mut current_text = String::new();\n        let mut last_usage: Option\u003cVertexUsageMetadata\u003e = None;\n        let mut line_buffer = String::new();\n\n        while let Some(chunk) = response.chunk().await? {\n            let chunk_str = std::str::from_utf8(\u0026chunk)?;\n\n            for c in chunk_str.chars() {\n                if c == '\\n' {\n                    if !line_buffer.is_empty() {\n                        if let Some(data) = line_buffer.strip_prefix(\"data: \") {\n                            if let Ok(response) = serde_json::from_str::\u003cVertexResponse\u003e(data) {\n                                if let Some(candidate) = response.candidates.first() {\n                                    for part in \u0026candidate.content.parts {\n                                        if let Some(text) = \u0026part.text {\n                                            streaming_callback(text)?;\n                                            current_text.push_str(text);\n                                        } else if let Some(function_call) = \u0026part.function_call {\n                                            // If we have accumulated text, push it as a content block\n                                            if !current_text.is_empty() {\n                                                content_blocks.push(ContentBlock::Text {\n                                                    text: current_text.clone(),\n                                                });\n                                                current_text.clear();\n                                            }\n\n                                            content_blocks.push(ContentBlock::ToolUse {\n                                                id: format!(\"tool-{}\", content_blocks.len()),\n                                                name: function_call.name.clone(),\n                                                input: function_call.args.clone(),\n                                            });\n                                        }\n                                    }\n                                }\n                                if let Some(usage) = response.usage_metadata {\n                                    last_usage = Some(usage);\n                                }\n                            }\n                        }\n                        line_buffer.clear();\n                    }\n                } else {\n                    line_buffer.push(c);\n                }\n            }\n        }\n\n        // Process any remaining data in the buffer\n        if !line_buffer.is_empty() {\n            if let Some(data) = line_buffer.strip_prefix(\"data: \") {\n                if let Ok(response) = serde_json::from_str::\u003cVertexResponse\u003e(data) {\n                    if let Some(usage) = response.usage_metadata {\n                        last_usage = Some(usage);\n                    }\n                }\n            }\n        }\n\n        // Push any remaining text as a final content block\n        if !current_text.is_empty() {\n            content_blocks.push(ContentBlock::Text { text: current_text });\n        }\n\n        Ok((\n            LLMResponse {\n                content: content_blocks,\n                usage: Usage {\n                    input_tokens: last_usage\n                        .as_ref()\n                        .map(|u| u.prompt_token_count)\n                        .unwrap_or(0),\n                    output_tokens: last_usage\n                        .as_ref()\n                        .map(|u| u.candidates_token_count)\n                        .unwrap_or(0),\n                },\n            },\n            rate_limits,\n        ))\n    }\n}\n\n#[async_trait]\nimpl LLMProvider for VertexClient {\n    async fn send_message(\n        \u0026self,\n        request: LLMRequest,\n        streaming_callback: Option\u003c\u0026StreamingCallback\u003e,\n    ) -\u003e Result\u003cLLMResponse\u003e {\n        let mut contents = Vec::new();\n\n        // Convert messages\n        contents.extend(request.messages.iter().map(Self::convert_message));\n\n        let vertex_request = VertexRequest {\n            system_instruction: Some(SystemInstruction {\n                parts: Parts {\n                    text: request.system_prompt,\n                },\n            }),\n            contents,\n            generation_config: Some(GenerationConfig {\n                temperature: 0.7,\n                max_output_tokens: 8192,\n            }),\n            tools: request.tools.map(|tools| {\n                vec![json!({\n                    \"function_declarations\": tools.into_iter().map(|tool| {\n                        json!({\n                            \"name\": tool.name,\n                            \"description\": tool.description,\n                            \"parameters\": tool.parameters,\n                        })\n                    }).collect::\u003cVec\u003c_\u003e\u003e()\n                })]\n            }),\n            tool_config: Some(json!({\n                \"function_calling_config\": {\n                    \"mode\": \"ANY\",\n                }\n            })),\n        };\n\n        self.send_with_retry(\u0026vertex_request, streaming_callback, 3)\n            .await\n    }\n}\n\n/*\nCommunicating tool call results back to LLM (including parallel function calls):\nNote, there is no ID associated with each function call/result, only the order.\n\n```json\n{\n    \"role\": \"user\",\n    \"parts\": {\n        \"text\": \"What is difference in temperature in New Delhi and San Francisco?\"\n    }\n},\n{\n    \"role\": \"model\",\n    \"parts\": [\n        {\n            \"functionCall\": {\n                \"name\": \"get_current_weather\",\n                \"args\": {\n                    \"location\": \"New Delhi\"\n                }\n            }\n        },\n        {\n            \"functionCall\": {\n                \"name\": \"get_current_weather\",\n                \"args\": {\n                    \"location\": \"San Francisco\"\n                }\n            }\n        }\n    ]\n},\n{\n    \"role\": \"user\",\n    \"parts\": [\n        {\n            \"functionResponse\": {\n                \"name\": \"get_current_weather\",\n                \"response\": {\n                    \"temperature\": 30.5,\n                    \"unit\": \"C\"\n                }\n            }\n        },\n        {\n            \"functionResponse\": {\n                \"name\": \"get_current_weather\",\n                \"response\": {\n                    \"temperature\": 20,\n                    \"unit\": \"C\"\n                }\n            }\n        }\n    ]\n}\n```\n*/\n","traces":[{"line":113,"address":[],"length":0,"stats":{"Line":4}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":127,"address":[],"length":0,"stats":{"Line":4}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":4}},{"line":163,"address":[],"length":0,"stats":{"Line":4}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":169,"address":[],"length":0,"stats":{"Line":2}},{"line":173,"address":[],"length":0,"stats":{"Line":4}},{"line":174,"address":[],"length":0,"stats":{"Line":8}},{"line":175,"address":[],"length":0,"stats":{"Line":4}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":4}},{"line":184,"address":[],"length":0,"stats":{"Line":4}},{"line":191,"address":[],"length":0,"stats":{"Line":4}},{"line":197,"address":[],"length":0,"stats":{"Line":4}},{"line":200,"address":[],"length":0,"stats":{"Line":6}},{"line":201,"address":[],"length":0,"stats":{"Line":5}},{"line":203,"address":[],"length":0,"stats":{"Line":8}},{"line":205,"address":[],"length":0,"stats":{"Line":4}},{"line":206,"address":[],"length":0,"stats":{"Line":4}},{"line":207,"address":[],"length":0,"stats":{"Line":4}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":2}},{"line":298,"address":[],"length":0,"stats":{"Line":2}},{"line":300,"address":[],"length":0,"stats":{"Line":2}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":4}},{"line":307,"address":[],"length":0,"stats":{"Line":2}},{"line":308,"address":[],"length":0,"stats":{"Line":2}},{"line":309,"address":[],"length":0,"stats":{"Line":2}},{"line":311,"address":[],"length":0,"stats":{"Line":2}},{"line":313,"address":[],"length":0,"stats":{"Line":6}},{"line":314,"address":[],"length":0,"stats":{"Line":4}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":2}},{"line":322,"address":[],"length":0,"stats":{"Line":2}},{"line":324,"address":[],"length":0,"stats":{"Line":4}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":4}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":4}},{"line":337,"address":[],"length":0,"stats":{"Line":2}},{"line":341,"address":[],"length":0,"stats":{"Line":2}},{"line":369,"address":[],"length":0,"stats":{"Line":2}},{"line":383,"address":[],"length":0,"stats":{"Line":2}},{"line":386,"address":[],"length":0,"stats":{"Line":2}},{"line":391,"address":[],"length":0,"stats":{"Line":4}},{"line":392,"address":[],"length":0,"stats":{"Line":2}},{"line":393,"address":[],"length":0,"stats":{"Line":2}},{"line":394,"address":[],"length":0,"stats":{"Line":2}},{"line":396,"address":[],"length":0,"stats":{"Line":2}},{"line":398,"address":[],"length":0,"stats":{"Line":2}},{"line":399,"address":[],"length":0,"stats":{"Line":4}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":2}},{"line":407,"address":[],"length":0,"stats":{"Line":2}},{"line":408,"address":[],"length":0,"stats":{"Line":2}},{"line":409,"address":[],"length":0,"stats":{"Line":2}},{"line":410,"address":[],"length":0,"stats":{"Line":2}},{"line":412,"address":[],"length":0,"stats":{"Line":11}},{"line":413,"address":[],"length":0,"stats":{"Line":6}},{"line":415,"address":[],"length":0,"stats":{"Line":485}},{"line":416,"address":[],"length":0,"stats":{"Line":485}},{"line":417,"address":[],"length":0,"stats":{"Line":6}},{"line":418,"address":[],"length":0,"stats":{"Line":6}},{"line":419,"address":[],"length":0,"stats":{"Line":3}},{"line":420,"address":[],"length":0,"stats":{"Line":3}},{"line":421,"address":[],"length":0,"stats":{"Line":9}},{"line":422,"address":[],"length":0,"stats":{"Line":2}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":2}},{"line":425,"address":[],"length":0,"stats":{"Line":2}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":1}},{"line":435,"address":[],"length":0,"stats":{"Line":1}},{"line":436,"address":[],"length":0,"stats":{"Line":1}},{"line":437,"address":[],"length":0,"stats":{"Line":1}},{"line":442,"address":[],"length":0,"stats":{"Line":7}},{"line":443,"address":[],"length":0,"stats":{"Line":2}},{"line":447,"address":[],"length":0,"stats":{"Line":3}},{"line":450,"address":[],"length":0,"stats":{"Line":479}},{"line":456,"address":[],"length":0,"stats":{"Line":2}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":3}},{"line":468,"address":[],"length":0,"stats":{"Line":1}},{"line":471,"address":[],"length":0,"stats":{"Line":2}},{"line":472,"address":[],"length":0,"stats":{"Line":2}},{"line":473,"address":[],"length":0,"stats":{"Line":2}},{"line":474,"address":[],"length":0,"stats":{"Line":2}},{"line":475,"address":[],"length":0,"stats":{"Line":2}},{"line":476,"address":[],"length":0,"stats":{"Line":2}},{"line":477,"address":[],"length":0,"stats":{"Line":4}},{"line":481,"address":[],"length":0,"stats":{"Line":2}},{"line":497,"address":[],"length":0,"stats":{"Line":4}},{"line":500,"address":[],"length":0,"stats":{"Line":4}},{"line":503,"address":[],"length":0,"stats":{"Line":4}},{"line":509,"address":[],"length":0,"stats":{"Line":4}},{"line":513,"address":[],"length":0,"stats":{"Line":6}},{"line":524,"address":[],"length":0,"stats":{"Line":4}},{"line":531,"address":[],"length":0,"stats":{"Line":4}},{"line":532,"address":[],"length":0,"stats":{"Line":11}}],"covered":94,"coverable":163},{"path":["/","Users","stippi","projects","code-assistant","src","main.rs"],"content":"mod agent;\nmod config;\nmod explorer;\nmod llm;\nmod mcp;\nmod persistence;\nmod tools;\nmod types;\nmod ui;\nmod utils;\n\nuse crate::agent::{Agent, ToolMode};\nuse crate::explorer::Explorer;\nuse crate::llm::{AnthropicClient, LLMProvider, OllamaClient, OpenAIClient, VertexClient};\nuse crate::mcp::MCPServer;\nuse crate::ui::terminal::TerminalUI;\nuse crate::utils::DefaultCommandExecutor;\nuse anyhow::{Context, Result};\nuse clap::{Parser, Subcommand, ValueEnum};\nuse persistence::FileStatePersistence;\nuse std::io;\nuse std::path::PathBuf;\nuse tracing_subscriber::fmt::SubscriberBuilder;\n\n#[derive(ValueEnum, Debug, Clone)]\nenum LLMProviderType {\n    Anthropic,\n    OpenAI,\n    Ollama,\n    Vertex,\n}\n\n#[derive(ValueEnum, Debug, Clone)]\nenum ToolsType {\n    Native,\n    Xml,\n}\n\n#[derive(Parser, Debug)]\n#[command(version, about, long_about = None)]\nstruct Args {\n    #[command(subcommand)]\n    mode: Mode,\n}\n\n#[derive(Subcommand, Debug)]\nenum Mode {\n    /// Run as autonomous agent with LLM support\n    Agent {\n        /// Path to the code directory to analyze\n        #[arg(long, default_value = \".\")]\n        path: PathBuf,\n\n        /// Task to perform on the codebase (required unless --continue is used)\n        #[arg(short, long, required_unless_present = \"continue_task\")]\n        task: Option\u003cString\u003e,\n\n        /// Continue from previous state\n        #[arg(long)]\n        continue_task: bool,\n\n        /// Enable verbose logging\n        #[arg(short, long)]\n        verbose: bool,\n\n        /// LLM provider to use\n        #[arg(short = 'p', long, default_value = \"anthropic\")]\n        provider: LLMProviderType,\n\n        /// Model name to use (provider-specific)\n        #[arg(short = 'm', long)]\n        model: Option\u003cString\u003e,\n\n        /// Context window size (in tokens, only relevant for Ollama)\n        #[arg(long, default_value = \"8192\")]\n        num_ctx: usize,\n\n        /// Type of tool declaration ('native' = tools via API, 'xml' = custom system message)\n        #[arg(long)]\n        tools_type: ToolsType,\n    },\n    /// Run as MCP server\n    Server {\n        /// Enable verbose logging\n        #[arg(short, long)]\n        verbose: bool,\n    },\n}\n\nfn create_llm_client(\n    provider: LLMProviderType,\n    model: Option\u003cString\u003e,\n    num_ctx: usize,\n) -\u003e Result\u003cBox\u003cdyn LLMProvider\u003e\u003e {\n    match provider {\n        LLMProviderType::Anthropic =\u003e {\n            let api_key = std::env::var(\"ANTHROPIC_API_KEY\")\n                .context(\"ANTHROPIC_API_KEY environment variable not set\")?;\n\n            Ok(Box::new(AnthropicClient::new(\n                api_key,\n                model\n                    .clone()\n                    .unwrap_or_else(|| \"claude-3-5-sonnet-20241022\".to_string()),\n            )))\n        }\n\n        LLMProviderType::OpenAI =\u003e {\n            let api_key = std::env::var(\"OPENAI_API_KEY\")\n                .context(\"OPENAI_API_KEY environment variable not set\")?;\n\n            Ok(Box::new(OpenAIClient::new(\n                api_key,\n                model.clone().unwrap_or_else(|| \"gpt-4o\".to_string()),\n            )))\n        }\n\n        LLMProviderType::Vertex =\u003e {\n            let api_key = std::env::var(\"GOOGLE_API_KEY\")\n                .context(\"GOOGLE_API_KEY environment variable not set\")?;\n\n            Ok(Box::new(VertexClient::new(\n                api_key,\n                model\n                    .clone()\n                    .unwrap_or_else(|| \"gemini-1.5-pro-latest\".to_string()),\n            )))\n        }\n\n        LLMProviderType::Ollama =\u003e Ok(Box::new(OllamaClient::new(\n            model\n                .clone()\n                .context(\"Model name is required for Ollama provider\")?,\n            num_ctx,\n        ))),\n    }\n}\n\nfn setup_logging(verbose: bool, use_stdout: bool) {\n    let filter = {\n        if verbose {\n            \"code_assistant=debug,info\".to_string()\n        } else {\n            \"code_assistant=info,warn\".to_string()\n        }\n    };\n\n    let subscriber = tracing_subscriber::fmt()\n        .with_env_filter(filter)\n        .with_target(false)\n        .with_thread_ids(false)\n        .with_file(true)\n        .with_line_number(true)\n        .with_level(true);\n\n    // For server mode, write only to stderr to keep stdout clean for JSON-RPC\n    let subscriber: SubscriberBuilder\u003c_, _, _, fn() -\u003e Box\u003cdyn io::Write + Send\u003e\u003e = if use_stdout {\n        subscriber.with_writer(|| Box::new(std::io::stdout()) as Box\u003cdyn io::Write + Send\u003e)\n    } else {\n        subscriber.with_writer(|| Box::new(std::io::stderr()) as Box\u003cdyn io::Write + Send\u003e)\n    };\n\n    subscriber.init();\n}\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    // Parse command line arguments\n    let args = Args::parse();\n\n    match args.mode {\n        Mode::Agent {\n            path,\n            task,\n            continue_task,\n            verbose,\n            provider,\n            model,\n            num_ctx,\n            tools_type,\n        } =\u003e {\n            // Setup logging based on verbose flag\n            setup_logging(verbose, true);\n\n            // Ensure the path exists and is a directory\n            if !path.is_dir() {\n                anyhow::bail!(\"Path '{}' is not a directory\", path.display());\n            }\n\n            // Setup LLM client with the specified provider\n            let llm_client = create_llm_client(provider, model, num_ctx)\n                .context(\"Failed to initialize LLM client\")?;\n\n            // Setup dynamic types\n            let root_path = path.canonicalize()?;\n            let explorer = Box::new(Explorer::new(root_path.clone()));\n            let terminal_ui = Box::new(TerminalUI::new());\n            let command_executor = Box::new(DefaultCommandExecutor);\n            let state_persistence = Box::new(FileStatePersistence::new(root_path.clone()));\n\n            // Validate parameters\n            if continue_task \u0026\u0026 task.is_some() {\n                anyhow::bail!(\n                    \"Cannot specify both --task and --continue. The task will be loaded from the saved state.\"\n                );\n            }\n\n            if !continue_task \u0026\u0026 task.is_none() {\n                anyhow::bail!(\"Either --task or --continue must be specified\");\n            }\n\n            // Initialize agent\n            let mut agent = Agent::new(\n                llm_client,\n                match \u0026tools_type {\n                    ToolsType::Native =\u003e ToolMode::Native,\n                    ToolsType::Xml =\u003e ToolMode::Xml,\n                },\n                explorer,\n                command_executor,\n                terminal_ui,\n                state_persistence,\n            );\n\n            // Get task either from state file or argument\n            if continue_task {\n                agent.start_from_state().await?;\n            } else {\n                agent.start_with_task(task.unwrap()).await?;\n            }\n        }\n\n        Mode::Server { verbose } =\u003e {\n            // Setup logging based on verbose flag\n            setup_logging(verbose, false);\n\n            // Initialize server\n            let mut server = MCPServer::new()?;\n            server.run().await?;\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":76},{"path":["/","Users","stippi","projects","code-assistant","src","mcp","handler.rs"],"content":"use super::resources::ResourceManager;\nuse super::types::*;\nuse crate::explorer::Explorer;\nuse crate::tools::{parse_tool_json, MCPToolHandler, ToolExecutor};\nuse crate::types::{CodeExplorer, ToolResult, Tools};\nuse crate::utils::{CommandExecutor, DefaultCommandExecutor};\nuse anyhow::Result;\nuse tokio::io::{AsyncWriteExt, Stdout};\nuse tracing::{debug, error, trace};\n\npub struct MessageHandler {\n    explorer: Option\u003cBox\u003cdyn CodeExplorer\u003e\u003e,\n    command_executor: Box\u003cdyn CommandExecutor\u003e,\n    resources: ResourceManager,\n    stdout: Stdout,\n}\n\nimpl MessageHandler {\n    pub fn new(stdout: Stdout) -\u003e Result\u003cSelf\u003e {\n        Ok(Self {\n            explorer: None,\n            command_executor: Box::new(DefaultCommandExecutor),\n            resources: ResourceManager::new(),\n            stdout,\n        })\n    }\n\n    /// Sends a JSON-RPC response\n    async fn send_response\u003cT: serde::Serialize\u003e(\u0026mut self, id: RequestId, result: T) -\u003e Result\u003c()\u003e {\n        let response = JSONRPCResponse {\n            jsonrpc: \"2.0\".to_string(),\n            id,\n            result,\n        };\n        self.send_message(\u0026serde_json::to_value(response)?).await\n    }\n\n    /// Sends a JSON-RPC error response\n    async fn send_error(\n        \u0026mut self,\n        id: RequestId,\n        code: i32,\n        message: String,\n        data: Option\u003cserde_json::Value\u003e,\n    ) -\u003e Result\u003c()\u003e {\n        let error = JSONRPCError {\n            jsonrpc: \"2.0\".to_string(),\n            id,\n            error: ErrorObject {\n                code,\n                message,\n                data,\n            },\n        };\n        self.send_message(\u0026serde_json::to_value(error)?).await\n    }\n\n    /// Helper method to send any JSON message\n    async fn send_message(\u0026mut self, message: \u0026serde_json::Value) -\u003e Result\u003c()\u003e {\n        let message_str = serde_json::to_string(message)?;\n\n        // Skip logging for certain message types\n        let skip_logging = [\"\\\"result\\\":{\\\"prompts\\\":\", \"\\\"result\\\":{\\\"resources\\\":\"]\n            .iter()\n            .any(|s| message_str.contains(s));\n\n        if !skip_logging {\n            debug!(\"Sending message: {}\", message_str);\n        }\n\n        self.stdout.write_all(message_str.as_bytes()).await?;\n        self.stdout.write_all(b\"\\n\").await?;\n        self.stdout.flush().await?;\n        Ok(())\n    }\n\n    /// Sends a notification\n    async fn send_notification(\n        \u0026mut self,\n        method: \u0026str,\n        params: Option\u003cserde_json::Value\u003e,\n    ) -\u003e Result\u003c()\u003e {\n        let notification = if let Some(params) = params {\n            serde_json::json!({\n                \"jsonrpc\": \"2.0\",\n                \"method\": method,\n                \"params\": params\n            })\n        } else {\n            serde_json::json!({\n                \"jsonrpc\": \"2.0\",\n                \"method\": method\n            })\n        };\n        self.send_message(\u0026notification).await\n    }\n\n    /// Handle initialize request\n    async fn handle_initialize(\u0026mut self, id: RequestId, params: InitializeParams) -\u003e Result\u003c()\u003e {\n        debug!(\"Initialize params: {:?}\", params);\n\n        self.send_response(\n            id,\n            InitializeResult {\n                capabilities: ServerCapabilities {\n                    resources: Some(ResourcesCapability {\n                        list_changed: Some(true),\n                        subscribe: Some(true),\n                    }),\n                    tools: Some(ToolsCapability {\n                        list_changed: Some(true),\n                    }),\n                    experimental: None,\n                },\n                protocol_version: params.protocol_version,\n                server_info: Implementation {\n                    name: \"code-assistant\".to_string(),\n                    version: \"0.1.0\".to_string(),\n                },\n                instructions: Some(\"Code Assistant helps you analyze and modify code.\".to_string()),\n            },\n        )\n        .await\n    }\n\n    /// Notify clients that a specific resource has been updated\n    async fn send_resource_updated_notification(\u0026mut self, uri: \u0026str) -\u003e Result\u003c()\u003e {\n        if !self.resources.is_subscribed(uri) {\n            debug!(\"Resource changed, but is not subscribed: {}\", uri);\n            return Ok(());\n        }\n        self.send_notification(\n            \"notifications/resources/updated\",\n            Some(serde_json::json!({ \"uri\": uri })),\n        )\n        .await\n    }\n\n    /// Handle resources/list request\n    async fn handle_resources_list(\u0026mut self, id: RequestId) -\u003e Result\u003c()\u003e {\n        trace!(\"Handling resources/list request\");\n        self.send_response(\n            id,\n            ListResourcesResult {\n                resources: self.resources.list_resources(),\n                next_cursor: None,\n            },\n        )\n        .await\n    }\n\n    /// Handle resources/read request\n    async fn handle_resources_read(\u0026mut self, id: RequestId, uri: String) -\u003e Result\u003c()\u003e {\n        debug!(\"Handling resources/read request for {}\", uri);\n        match self.resources.read_resource(\u0026uri) {\n            Some(content) =\u003e {\n                self.send_response(\n                    id,\n                    ReadResourceResult {\n                        contents: vec![content],\n                    },\n                )\n                .await\n            }\n            None =\u003e {\n                self.send_error(id, -32001, format!(\"Resource not found: {}\", uri), None)\n                    .await\n            }\n        }\n    }\n\n    /// Handle resources/subscribe request\n    async fn handle_resources_subscribe(\u0026mut self, id: RequestId, uri: String) -\u003e Result\u003c()\u003e {\n        debug!(\"Handling resources/subscribe request for {}\", uri);\n        if self.resources.read_resource(\u0026uri).is_none() {\n            return self\n                .send_error(id, -32001, format!(\"Resource not found: {}\", uri), None)\n                .await;\n        }\n        self.resources.subscribe(\u0026uri);\n        self.send_response(id, EmptyResult { meta: None }).await\n    }\n\n    /// Handle resources/unsubscribe request\n    async fn handle_resources_unsubscribe(\u0026mut self, id: RequestId, uri: String) -\u003e Result\u003c()\u003e {\n        debug!(\"Handling resources/unsubscribe request for {}\", uri);\n        self.resources.unsubscribe(\u0026uri);\n        self.send_response(id, EmptyResult { meta: None }).await\n    }\n\n    /// Handle tools/list request\n    async fn handle_tools_list(\u0026mut self, id: RequestId) -\u003e Result\u003c()\u003e {\n        debug!(\"Handling tools/list request\");\n        self.send_response(\n            id,\n            ListToolsResult {\n                tools: Tools::mcp()\n                    .into_iter()\n                    .map(|tool| {\n                        serde_json::json!({\n                            \"name\": tool.name,\n                            \"description\": tool.description,\n                            \"inputSchema\": tool.parameters\n                        })\n                    })\n                    .collect(),\n                next_cursor: None,\n            },\n        )\n        .await\n    }\n\n    /// Notify clients that the tools list has changed\n    async fn send_tools_changed_notification(\u0026mut self) -\u003e Result\u003c()\u003e {\n        self.send_notification(\"notifications/tools/list_changed\", None)\n            .await\n    }\n\n    /// Handle tools/call request\n    async fn handle_tool_call(\u0026mut self, id: RequestId, params: ToolCallParams) -\u003e Result\u003c()\u003e {\n        debug!(\"Handling tool call for {}\", params.name);\n\n        let result = async {\n            let arguments = params\n                .arguments\n                .as_ref()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing parameters\"))?;\n\n            let tool = parse_tool_json(\u0026params.name, arguments)?;\n            let mut handler = MCPToolHandler::new();\n\n            let (output, result) = ToolExecutor::execute(\n                \u0026mut handler,\n                self.explorer.as_mut(),\n                \u0026self.command_executor,\n                None,\n                \u0026tool,\n            )\n            .await?;\n\n            // Handle special tool results\n            if let ToolResult::OpenProject { path, .. } = \u0026result {\n                if let Some(path) = path {\n                    self.explorer = Some(Box::new(Explorer::new(path.clone())));\n                    self.send_tools_changed_notification().await?;\n                    self.update_file_tree().await?;\n                }\n            }\n\n            if let ToolResult::ListFiles { .. } = \u0026result {\n                self.update_file_tree().await?;\n            }\n\n            Ok::\u003c_, anyhow::Error\u003e(output)\n        }\n        .await;\n\n        // Convert the result into a ToolCallResult response\n        match result {\n            Ok(output) =\u003e {\n                self.send_response(\n                    id,\n                    ToolCallResult {\n                        content: vec![ToolResultContent::Text { text: output }],\n                        is_error: None,\n                    },\n                )\n                .await\n            }\n            Err(e) =\u003e {\n                self.send_response(\n                    id,\n                    ToolCallResult {\n                        content: vec![ToolResultContent::Text {\n                            text: e.to_string(),\n                        }],\n                        is_error: Some(true),\n                    },\n                )\n                .await\n            }\n        }\n    }\n\n    async fn update_file_tree(\u0026mut self) -\u003e Result\u003c()\u003e {\n        if let Some(ref mut explorer) = self.explorer {\n            if let Ok(tree) = explorer.create_initial_tree(2) {\n                self.resources.update_file_tree(tree);\n                self.send_resource_updated_notification(\"tree:///\").await?;\n            }\n        }\n        Ok(())\n    }\n\n    /// Handle prompts/list request\n    async fn handle_prompts_list(\u0026mut self, id: RequestId) -\u003e Result\u003c()\u003e {\n        trace!(\"Handling prompts/list request\");\n        self.send_response(\n            id,\n            ListPromptsResult {\n                prompts: vec![],\n                next_cursor: None,\n            },\n        )\n        .await\n    }\n\n    /// Main message handling entry point\n    pub async fn handle_message(\u0026mut self, message: \u0026str) -\u003e Result\u003c()\u003e {\n        // Parse the message first\n        let message: JSONRPCMessage = match serde_json::from_str(message) {\n            Ok(msg) =\u003e msg,\n            Err(e) =\u003e {\n                error!(\"Invalid JSON-RPC message: {}\", e);\n                return Ok(());\n            }\n        };\n\n        match message {\n            JSONRPCMessage::Request(request) =\u003e {\n                trace!(\"Processing request: {:?}\", request);\n                match (request.method.as_str(), request.id) {\n                    (\"initialize\", Some(id)) =\u003e {\n                        let params: InitializeParams = serde_json::from_value(request.params)?;\n                        self.handle_initialize(id, params).await?;\n                    }\n\n                    (\"resources/list\", Some(id)) =\u003e {\n                        self.handle_resources_list(id).await?;\n                    }\n                    (\"resources/read\", Some(id)) =\u003e {\n                        let params: ReadResourceRequest = serde_json::from_value(request.params)?;\n                        self.handle_resources_read(id, params.uri).await?;\n                    }\n                    (\"resources/subscribe\", Some(id)) =\u003e {\n                        let params: SubscribeResourceRequest =\n                            serde_json::from_value(request.params)?;\n                        self.handle_resources_subscribe(id, params.uri).await?;\n                    }\n                    (\"resources/unsubscribe\", Some(id)) =\u003e {\n                        let params: UnsubscribeResourceRequest =\n                            serde_json::from_value(request.params)?;\n                        self.handle_resources_unsubscribe(id, params.uri).await?;\n                    }\n\n                    (\"tools/list\", Some(id)) =\u003e {\n                        self.handle_tools_list(id).await?;\n                    }\n\n                    (\"tools/call\", Some(id)) =\u003e {\n                        match serde_json::from_value::\u003cToolCallParams\u003e(request.params) {\n                            Ok(params) =\u003e {\n                                self.handle_tool_call(id, params).await?;\n                            }\n                            Err(e) =\u003e {\n                                self.send_response(\n                                    id,\n                                    ToolCallResult {\n                                        content: vec![ToolResultContent::Text {\n                                            text: format!(\"Invalid tool parameters: {}\", e),\n                                        }],\n                                        is_error: Some(true),\n                                    },\n                                )\n                                .await?;\n                            }\n                        }\n                    }\n\n                    (\"prompts/list\", Some(id)) =\u003e {\n                        self.handle_prompts_list(id).await?;\n                    }\n\n                    (method, Some(id)) =\u003e {\n                        self.send_error(id, -32601, format!(\"Method not found: {}\", method), None)\n                            .await?;\n                    }\n\n                    (_, None) =\u003e {\n                        debug!(\"Received notification request - ignoring\");\n                    }\n                }\n            }\n\n            JSONRPCMessage::Notification { method, params, .. } =\u003e match method.as_str() {\n                \"notifications/initialized\" =\u003e {\n                    if let Some(params) = params {\n                        debug!(\"Client initialized with params: {:?}\", params);\n                    } else {\n                        debug!(\"Client initialized\");\n                    }\n                }\n                _ =\u003e {\n                    debug!(\"Unknown notification: {}\", method);\n                }\n            },\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":213},{"path":["/","Users","stippi","projects","code-assistant","src","mcp","mod.rs"],"content":"mod handler;\nmod resources;\nmod server;\nmod types;\n\npub use server::MCPServer;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","stippi","projects","code-assistant","src","mcp","resources.rs"],"content":"use super::types::{Resource, ResourceContent};\nuse crate::types::FileTreeEntry;\nuse std::collections::HashSet;\n\npub struct ResourceManager {\n    file_tree: Option\u003cFileTreeEntry\u003e,\n    subscriptions: HashSet\u003cString\u003e,\n}\n\nimpl ResourceManager {\n    pub fn new() -\u003e Self {\n        Self {\n            file_tree: None,\n            subscriptions: HashSet::new(),\n        }\n    }\n\n    /// Lists all available resources\n    pub fn list_resources(\u0026self) -\u003e Vec\u003cResource\u003e {\n        let mut resources = Vec::new();\n        // Add file tree resource if available\n        if self.file_tree.is_some() {\n            resources.push(Resource {\n                uri: \"tree:///\".to_string(),\n                name: \"Repository Structure\".to_string(),\n                description: Some(\"The repository file tree structure\".to_string()),\n                mime_type: Some(\"text/plain\".to_string()),\n            });\n        }\n        resources\n    }\n\n    /// Reads a specific resource content\n    pub fn read_resource(\u0026self, uri: \u0026str) -\u003e Option\u003cResourceContent\u003e {\n        match uri {\n            \"tree:///\" =\u003e self.file_tree.as_ref().map(|t| ResourceContent {\n                uri: uri.to_string(),\n                mime_type: Some(\"text/plain\".to_string()),\n                text: Some(t.to_string()),\n            }),\n            _ =\u003e None,\n        }\n    }\n\n    /// Subscribes to a resource\n    pub fn subscribe(\u0026mut self, uri: \u0026str) {\n        self.subscriptions.insert(uri.to_string());\n    }\n\n    /// Unsubscribes from a resource\n    pub fn unsubscribe(\u0026mut self, uri: \u0026str) {\n        self.subscriptions.remove(uri);\n    }\n\n    /// Checks if a resource is subscribed\n    pub fn is_subscribed(\u0026self, uri: \u0026str) -\u003e bool {\n        self.subscriptions.contains(uri)\n    }\n\n    /// Updates the file tree\n    pub fn update_file_tree(\u0026mut self, tree: FileTreeEntry) {\n        self.file_tree = Some(tree);\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":26},{"path":["/","Users","stippi","projects","code-assistant","src","mcp","server.rs"],"content":"use crate::mcp::handler::MessageHandler;\nuse anyhow::Result;\nuse tokio::io::{stdin, AsyncBufReadExt, BufReader};\nuse tracing::{debug, error, trace};\n\npub struct MCPServer {\n    handler: MessageHandler,\n}\n\nimpl MCPServer {\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        Ok(Self {\n            handler: MessageHandler::new(tokio::io::stdout())?,\n        })\n    }\n\n    pub async fn run(\u0026mut self) -\u003e Result\u003c()\u003e {\n        debug!(\"Starting MCP server using stdio transport\");\n\n        let stdin = stdin();\n        let mut reader = BufReader::new(stdin);\n\n        let mut line = String::new();\n        while let Ok(n) = reader.read_line(\u0026mut line).await {\n            if n == 0 {\n                break; // EOF\n            }\n\n            let trimmed = line.trim();\n            trace!(\"Received message: {}\", trimmed);\n\n            // Process the message\n            match self.handler.handle_message(trimmed).await {\n                Ok(()) =\u003e {\n                    trace!(\"Message processed successfully\");\n                }\n                Err(e) =\u003e {\n                    error!(\"Error handling message: {}\", e);\n                }\n            }\n\n            line.clear();\n        }\n\n        debug!(\"MCP server shutting down\");\n        Ok(())\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":20},{"path":["/","Users","stippi","projects","code-assistant","src","mcp","types.rs"],"content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum RequestId {\n    String(String),\n    Number(i64),\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct JSONRPCRequest {\n    pub jsonrpc: String,\n    pub id: Option\u003cRequestId\u003e,\n    pub method: String,\n    pub params: serde_json::Value,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum JSONRPCMessage {\n    Request(JSONRPCRequest),\n    Notification {\n        jsonrpc: String,\n        method: String,\n        #[serde(default)]\n        params: Option\u003cserde_json::Value\u003e,\n    },\n}\n\n#[derive(Debug, Serialize)]\npub struct JSONRPCResponse\u003cT\u003e {\n    pub jsonrpc: String,\n    pub id: RequestId,\n    pub result: T,\n}\n\n#[derive(Debug, Serialize)]\npub struct JSONRPCError {\n    pub jsonrpc: String,\n    pub id: RequestId,\n    pub error: ErrorObject,\n}\n\n#[derive(Debug, Serialize)]\npub struct ErrorObject {\n    pub code: i32,\n    pub message: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub data: Option\u003cserde_json::Value\u003e,\n}\n\n#[derive(Debug, Serialize)]\npub struct EmptyResult {\n    #[serde(skip_serializing_if = \"Option::is_none\", rename = \"_meta\")]\n    pub meta: Option\u003cserde_json::Value\u003e,\n}\n\n// Client capabilities types\n#[derive(Debug, Serialize, Deserialize)]\npub struct ClientCapabilities {\n    pub tools: Option\u003cToolsCapability\u003e,\n    #[serde(default)]\n    pub experimental: Option\u003cserde_json::Map\u003cString, serde_json::Value\u003e\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ToolsCapability {\n    #[serde(rename = \"listChanged\")]\n    pub list_changed: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ResourcesCapability {\n    #[serde(rename = \"listChanged\")]\n    pub list_changed: Option\u003cbool\u003e,\n    pub subscribe: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Implementation {\n    pub name: String,\n    pub version: String,\n}\n\n// Initialize request/response types\n#[derive(Debug, Serialize, Deserialize)]\npub struct InitializeParams {\n    pub capabilities: ClientCapabilities,\n    #[serde(rename = \"clientInfo\")]\n    pub client_info: Implementation,\n    #[serde(rename = \"protocolVersion\")]\n    pub protocol_version: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ServerCapabilities {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub tools: Option\u003cToolsCapability\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub resources: Option\u003cResourcesCapability\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub experimental: Option\u003cserde_json::Map\u003cString, serde_json::Value\u003e\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct InitializeResult {\n    pub capabilities: ServerCapabilities,\n    #[serde(rename = \"protocolVersion\")]\n    pub protocol_version: String,\n    #[serde(rename = \"serverInfo\")]\n    pub server_info: Implementation,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub instructions: Option\u003cString\u003e,\n}\n\n// Resource types\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Resource {\n    pub uri: String,\n    pub name: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    #[serde(rename = \"mimeType\", skip_serializing_if = \"Option::is_none\")]\n    pub mime_type: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ListResourcesResult {\n    pub resources: Vec\u003cResource\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub next_cursor: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Deserialize)]\npub struct ReadResourceRequest {\n    pub uri: String,\n}\n\n#[derive(Debug, Deserialize)]\npub struct SubscribeResourceRequest {\n    pub uri: String,\n}\n\n#[derive(Debug, Deserialize)]\npub struct UnsubscribeResourceRequest {\n    pub uri: String,\n}\n\n#[derive(Debug, Serialize)]\npub struct ReadResourceResult {\n    pub contents: Vec\u003cResourceContent\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ResourceContent {\n    pub uri: String,\n    #[serde(rename = \"mimeType\", skip_serializing_if = \"Option::is_none\")]\n    pub mime_type: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub text: Option\u003cString\u003e,\n}\n\n// Tool types\n#[derive(Debug, Serialize, Deserialize)]\npub struct ListToolsResult {\n    pub tools: Vec\u003cserde_json::Value\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub next_cursor: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ToolCallParams {\n    pub name: String,\n    pub arguments: Option\u003cserde_json::Value\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct ToolCallResult {\n    pub content: Vec\u003cToolResultContent\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub is_error: Option\u003cbool\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(tag = \"type\")]\npub enum ToolResultContent {\n    #[serde(rename = \"text\")]\n    Text { text: String },\n}\n\n// Prompt types\n#[derive(Debug, Serialize, Deserialize)]\npub struct ListPromptsResult {\n    pub prompts: Vec\u003cPrompt\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub next_cursor: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Prompt {\n    pub name: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub arguments: Option\u003cVec\u003cPromptArgument\u003e\u003e,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct PromptArgument {\n    pub name: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub description: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub required: Option\u003cbool\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","stippi","projects","code-assistant","src","persistence.rs"],"content":"use crate::types::ActionResult;\nuse anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\nuse tracing::debug;\n\n/// Persistent state of the agent\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct AgentState {\n    /// Original task description\n    pub task: String,\n    /// Memory of all previous actions and their results\n    pub actions: Vec\u003cActionResult\u003e,\n}\n\npub trait StatePersistence: Send + Sync {\n    fn save_state(\u0026mut self, task: String, actions: Vec\u003cActionResult\u003e) -\u003e Result\u003c()\u003e;\n    fn load_state(\u0026mut self) -\u003e Result\u003cOption\u003cAgentState\u003e\u003e;\n    fn cleanup(\u0026mut self) -\u003e Result\u003c()\u003e;\n}\n\npub struct FileStatePersistence {\n    root_dir: PathBuf,\n}\n\nimpl FileStatePersistence {\n    pub fn new(root_dir: PathBuf) -\u003e Self {\n        Self { root_dir }\n    }\n}\n\nconst STATE_FILE: \u0026str = \".code-assistant.state.json\";\n\nimpl StatePersistence for FileStatePersistence {\n    fn save_state(\u0026mut self, task: String, actions: Vec\u003cActionResult\u003e) -\u003e Result\u003c()\u003e {\n        let state = AgentState { task, actions };\n        let state_path = self.root_dir.join(STATE_FILE);\n        debug!(\"Saving state to {}\", state_path.display());\n        let json = serde_json::to_string_pretty(\u0026state)?;\n        std::fs::write(state_path, json)?;\n        Ok(())\n    }\n\n    fn load_state(\u0026mut self) -\u003e Result\u003cOption\u003cAgentState\u003e\u003e {\n        let state_path = self.root_dir.join(STATE_FILE);\n        if !state_path.exists() {\n            return Ok(None);\n        }\n\n        debug!(\"Loading state from {}\", state_path.display());\n        let json = std::fs::read_to_string(state_path)?;\n        let state = serde_json::from_str(\u0026json)?;\n        Ok(Some(state))\n    }\n\n    fn cleanup(\u0026mut self) -\u003e Result\u003c()\u003e {\n        let state_path = self.root_dir.join(STATE_FILE);\n        if state_path.exists() {\n            debug!(\"Removing state file {}\", state_path.display());\n            std::fs::remove_file(state_path)?;\n        }\n        Ok(())\n    }\n}\n\n#[cfg(test)]\npub struct MockStatePersistence {\n    state: Option\u003cAgentState\u003e,\n}\n\n#[cfg(test)]\nimpl MockStatePersistence {\n    pub fn new() -\u003e Self {\n        Self { state: None }\n    }\n}\n\n#[cfg(test)]\nimpl StatePersistence for MockStatePersistence {\n    fn save_state(\u0026mut self, task: String, actions: Vec\u003cActionResult\u003e) -\u003e Result\u003c()\u003e {\n        // In-Memory state\n        let state = AgentState { task, actions };\n        self.state = Some(state);\n        Ok(())\n    }\n\n    fn load_state(\u0026mut self) -\u003e Result\u003cOption\u003cAgentState\u003e\u003e {\n        Ok(self.state.clone())\n    }\n\n    fn cleanup(\u0026mut self) -\u003e Result\u003c()\u003e {\n        self.state = None;\n        Ok(())\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":22},{"path":["/","Users","stippi","projects","code-assistant","src","tools","definitions.rs"],"content":"use crate::types::{ToolDefinition, Tools};\nuse serde_json::json;\n\nimpl Tools {\n    /// Returns all available tool definitions\n    pub fn all() -\u003e Vec\u003cToolDefinition\u003e {\n        vec![\n            Self::execute_command(),\n            Self::search_files(),\n            Self::list_files(),\n            Self::read_files(),\n            Self::summarize(),\n            Self::replace_in_file(),\n            Self::write_file(),\n            Self::delete_files(),\n            Self::ask_user(),\n            Self::message_user(),\n            Self::complete_task(),\n        ]\n    }\n\n    pub fn mcp() -\u003e Vec\u003cToolDefinition\u003e {\n        vec![\n            Self::list_projects(),\n            Self::open_project(),\n            Self::execute_command(),\n            Self::search_files(),\n            Self::list_files(),\n            Self::read_files(),\n            Self::summarize(),\n            Self::replace_in_file(),\n            Self::write_file(),\n            Self::delete_files(),\n        ]\n    }\n\n    pub fn list_projects() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"list_projects\".to_string(),\n            description: \"List all available projects\".to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {},\n                \"required\": []\n            }),\n        }\n    }\n\n    pub fn open_project() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"open_project\".to_string(),\n            description: \"Open a specific project\".to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"name\": {\n                        \"type\": \"string\",\n                        \"description\": \"Name of the project to open\"\n                    }\n                },\n                \"required\": [\"name\"]\n            }),\n        }\n    }\n\n    pub fn execute_command() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"execute_command\".to_string(),\n            description: \"Execute a command line program\".to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"command_line\": {\n                        \"type\": \"string\",\n                        \"description\": \"The complete command to execute\"\n                    },\n                    \"working_dir\": {\n                        \"type\": \"string\",\n                        \"description\": \"Optional: working directory for the command\"\n                    }\n                },\n                \"required\": [\"command_line\"]\n            }),\n        }\n    }\n\n    pub fn search_files() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"search_files\".to_string(),\n            description: \"Search for text in files with advanced options\".to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"query\": {\n                        \"type\": \"string\",\n                        \"description\": \"The text to search for. Supports regular expressions.\"\n                    },\n                    \"path\": {\n                        \"type\": \"string\",\n                        \"description\": \"Optional: directory path to search in (relative to project root)\"\n                    },\n                    \"max_results\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Optional: maximum number of results to return\"\n                    },\n                    \"case_sensitive\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"Optional: whether the search should be case-sensitive (default: false)\"\n                    },\n                    \"whole_words\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"Optional: match whole words only (default: false)\"\n                    },\n                    \"mode\": {\n                        \"type\": \"string\",\n                        \"description\": \"Optional: search mode - 'exact' (default) for standard text search, or 'regex' for regular expressions\",\n                        \"enum\": [\"exact\", \"regex\"]\n                    }\n                },\n                \"required\": [\"query\"]\n            }),\n        }\n    }\n\n    pub fn list_files() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"list_files\".to_string(),\n            description: \"List files in a directory\".to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"paths\": {\n                        \"type\": \"array\",\n                        \"description\": \"Directory paths relative to project root\",\n                        \"items\": {\n                            \"type\": \"string\"\n                        }\n                    },\n                    \"max_depth\": {\n                        \"type\": \"integer\",\n                        \"description\": \"Maximum directory depth\"\n                    }\n                },\n                \"required\": [\"paths\"]\n            }),\n        }\n    }\n\n    pub fn read_files() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"read_files\".to_string(),\n            description: \"Load files into working memory\".to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"paths\": {\n                        \"type\": \"array\",\n                        \"description\": \"Paths to the files relative to the workspace root directory\",\n                        \"items\": {\n                            \"type\": \"string\"\n                        }\n                    }\n                },\n                \"required\": [\"paths\"]\n            }),\n        }\n    }\n\n    pub fn summarize() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"summarize\".to_string(),\n            description:\n                \"Replace file content with a summary in working memory, unloading the full content.\"\n                    .to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"files\": {\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"type\": \"object\",\n                            \"properties\": {\n                                \"path\": {\n                                    \"type\": \"string\",\n                                    \"description\": \"Path to the file to summarize\"\n                                },\n                                \"summary\": {\n                                    \"type\": \"string\",\n                                    \"description\": \"Your summary of the file contents\"\n                                }\n                            },\n                            \"required\": [\"path\", \"summary\"]\n                        }\n                    }\n                },\n                \"required\": [\"files\"]\n            }),\n        }\n    }\n\n    pub fn replace_in_file() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"replace_in_file\".to_string(),\n            description: \"Replace sections in a file using search/replace blocks. Each search text must appear exactly once in the file - otherwise the operation will fail.\".to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"path\": {\n                        \"type\": \"string\",\n                        \"description\": \"Path to the file to modify\"\n                    },\n                    \"replacements\": {\n                        \"type\": \"array\",\n                        \"description\": \"List of search/replace pairs\",\n                        \"items\": {\n                            \"type\": \"object\",\n                            \"properties\": {\n                                \"search\": {\n                                    \"type\": \"string\",\n                                    \"description\": \"Exact content to find. Make sure it is unique in the file by providing a large enough search string!\"\n                                },\n                                \"replace\": {\n                                    \"type\": \"string\",\n                                    \"description\": \"Content to replace with\"\n                                }\n                            },\n                            \"required\": [\"search\", \"replace\"]\n                        }\n                    }\n                },\n                \"required\": [\"path\", \"replacements\"]\n            }),\n        }\n    }\n\n    pub fn write_file() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"write_file\".to_string(),\n            description:\n                \"Creates or overwrites a file. Use for new files or when updating most of a file. \\\n                         For smaller updates prefer to use update-file.\"\n                    .to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"path\": {\n                        \"type\": \"string\",\n                        \"description\": \"Path to create or overwrite\"\n                    },\n                    \"content\": {\n                        \"type\": \"string\",\n                        \"description\": \"Content to write\"\n                    }\n                },\n                \"required\": [\"path\", \"content\"]\n            }),\n        }\n    }\n\n    pub fn delete_files() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"delete_files\".to_string(),\n            description: \"Delete files from the workspace. This operation cannot be undone!\"\n                .to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"paths\": {\n                        \"type\": \"array\",\n                        \"description\": \"Paths to the files relative to the workspace root directory\",\n                        \"items\": {\n                            \"type\": \"string\"\n                        }\n                    }\n                },\n                \"required\": [\"paths\"]\n            }),\n        }\n    }\n\n    pub fn ask_user() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"ask_user\".to_string(),\n            description:\n                \"Ask the user a question. Use for clarifications, feedback or confirmation.\"\n                    .to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"question\": {\n                        \"type\": \"string\",\n                        \"description\": \"The question for the user\"\n                    }\n                },\n                \"required\": [\"question\"]\n            }),\n        }\n    }\n\n    pub fn message_user() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"message_user\".to_string(),\n            description: \"Complete the task\".to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"message\": {\n                        \"type\": \"string\",\n                        \"description\": \"A final message for the user\"\n                    }\n                },\n                \"required\": [\"message\"]\n            }),\n        }\n    }\n\n    pub fn complete_task() -\u003e ToolDefinition {\n        ToolDefinition {\n            name: \"complete_task\".to_string(),\n            description: \"Complete the task\".to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"message\": {\n                        \"type\": \"string\",\n                        \"description\": \"A final message for the user\"\n                    }\n                },\n                \"required\": [\"message\"]\n            }),\n        }\n    }\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":13}},{"line":7,"address":[],"length":0,"stats":{"Line":13}},{"line":8,"address":[],"length":0,"stats":{"Line":13}},{"line":9,"address":[],"length":0,"stats":{"Line":13}},{"line":10,"address":[],"length":0,"stats":{"Line":13}},{"line":11,"address":[],"length":0,"stats":{"Line":13}},{"line":12,"address":[],"length":0,"stats":{"Line":13}},{"line":13,"address":[],"length":0,"stats":{"Line":13}},{"line":14,"address":[],"length":0,"stats":{"Line":13}},{"line":15,"address":[],"length":0,"stats":{"Line":13}},{"line":16,"address":[],"length":0,"stats":{"Line":13}},{"line":17,"address":[],"length":0,"stats":{"Line":13}},{"line":18,"address":[],"length":0,"stats":{"Line":13}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":13}},{"line":68,"address":[],"length":0,"stats":{"Line":13}},{"line":69,"address":[],"length":0,"stats":{"Line":13}},{"line":70,"address":[],"length":0,"stats":{"Line":13}},{"line":87,"address":[],"length":0,"stats":{"Line":13}},{"line":89,"address":[],"length":0,"stats":{"Line":13}},{"line":90,"address":[],"length":0,"stats":{"Line":13}},{"line":91,"address":[],"length":0,"stats":{"Line":13}},{"line":125,"address":[],"length":0,"stats":{"Line":13}},{"line":127,"address":[],"length":0,"stats":{"Line":13}},{"line":128,"address":[],"length":0,"stats":{"Line":13}},{"line":129,"address":[],"length":0,"stats":{"Line":13}},{"line":149,"address":[],"length":0,"stats":{"Line":13}},{"line":151,"address":[],"length":0,"stats":{"Line":13}},{"line":152,"address":[],"length":0,"stats":{"Line":13}},{"line":153,"address":[],"length":0,"stats":{"Line":13}},{"line":169,"address":[],"length":0,"stats":{"Line":13}},{"line":171,"address":[],"length":0,"stats":{"Line":13}},{"line":172,"address":[],"length":0,"stats":{"Line":13}},{"line":175,"address":[],"length":0,"stats":{"Line":13}},{"line":201,"address":[],"length":0,"stats":{"Line":13}},{"line":203,"address":[],"length":0,"stats":{"Line":13}},{"line":204,"address":[],"length":0,"stats":{"Line":13}},{"line":205,"address":[],"length":0,"stats":{"Line":13}},{"line":236,"address":[],"length":0,"stats":{"Line":13}},{"line":238,"address":[],"length":0,"stats":{"Line":13}},{"line":239,"address":[],"length":0,"stats":{"Line":13}},{"line":243,"address":[],"length":0,"stats":{"Line":13}},{"line":260,"address":[],"length":0,"stats":{"Line":13}},{"line":262,"address":[],"length":0,"stats":{"Line":13}},{"line":263,"address":[],"length":0,"stats":{"Line":13}},{"line":265,"address":[],"length":0,"stats":{"Line":13}},{"line":281,"address":[],"length":0,"stats":{"Line":13}},{"line":283,"address":[],"length":0,"stats":{"Line":13}},{"line":284,"address":[],"length":0,"stats":{"Line":13}},{"line":287,"address":[],"length":0,"stats":{"Line":13}},{"line":300,"address":[],"length":0,"stats":{"Line":13}},{"line":302,"address":[],"length":0,"stats":{"Line":13}},{"line":303,"address":[],"length":0,"stats":{"Line":13}},{"line":304,"address":[],"length":0,"stats":{"Line":13}},{"line":317,"address":[],"length":0,"stats":{"Line":13}},{"line":319,"address":[],"length":0,"stats":{"Line":13}},{"line":320,"address":[],"length":0,"stats":{"Line":13}},{"line":321,"address":[],"length":0,"stats":{"Line":13}}],"covered":57,"coverable":77},{"path":["/","Users","stippi","projects","code-assistant","src","tools","executor.rs"],"content":"use super::ToolResultHandler;\nuse crate::config;\nuse crate::types::{CodeExplorer, SearchMode, SearchOptions, Tool, ToolResult};\nuse crate::ui::{UIMessage, UserInterface};\nuse crate::utils::CommandExecutor;\nuse anyhow::Result;\nuse std::collections::HashMap;\nuse std::path::Path;\n\npub struct ToolExecutor {}\n\nfn check_absolute_path(path: \u0026Path) -\u003e Option\u003cToolResult\u003e {\n    if path.is_absolute() {\n        Some(ToolResult::AbsolutePathError {\n            path: path.to_path_buf(),\n        })\n    } else {\n        None\n    }\n}\n\nimpl ToolExecutor {\n    pub async fn execute\u003cH: ToolResultHandler\u003e(\n        handler: \u0026mut H,\n        explorer: Option\u003c\u0026mut Box\u003cdyn CodeExplorer\u003e\u003e,\n        command_executor: \u0026Box\u003cdyn CommandExecutor\u003e,\n        ui: Option\u003c\u0026Box\u003cdyn UserInterface\u003e\u003e,\n        tool: \u0026Tool,\n    ) -\u003e Result\u003c(String, ToolResult)\u003e {\n        let result = match tool {\n            Tool::ListProjects =\u003e {\n                let projects = config::load_projects()?;\n                ToolResult::ListProjects { projects }\n            }\n\n            Tool::OpenProject { name } =\u003e {\n                let projects = config::load_projects()?;\n                match projects.get(name) {\n                    Some(project) =\u003e ToolResult::OpenProject {\n                        name: name.clone(),\n                        path: Some(project.path.to_path_buf()),\n                        error: None,\n                    },\n                    None =\u003e ToolResult::OpenProject {\n                        name: name.clone(),\n                        path: None,\n                        error: Some(\"Project not found\".to_string()),\n                    },\n                }\n            }\n\n            Tool::Summarize { files } =\u003e ToolResult::Summarize {\n                files: files.clone(),\n            },\n\n            Tool::MessageUser { message } =\u003e match \u0026ui {\n                Some(ui) =\u003e match ui.display(UIMessage::Action(message.clone())).await {\n                    Ok(_) =\u003e ToolResult::MessageUser {\n                        result: \"Message delivered\".to_string(),\n                    },\n                    Err(e) =\u003e ToolResult::MessageUser {\n                        result: format!(\"Failed to deliver message: {}\", e),\n                    },\n                },\n                None =\u003e ToolResult::MessageUser {\n                    result: \"Messaging user not available\".to_string(),\n                },\n            },\n\n            Tool::AskUser { question } =\u003e match \u0026ui {\n                Some(ui) =\u003e {\n                    // Display the question\n                    ui.display(UIMessage::Question(question.clone())).await?;\n\n                    // Get the input\n                    match ui.get_input(\"\u003e \").await {\n                        Ok(response) =\u003e ToolResult::AskUser { response },\n                        Err(e) =\u003e ToolResult::AskUser {\n                            response: format!(\"Failed to get user input: {}\", e),\n                        },\n                    }\n                }\n                None =\u003e ToolResult::AskUser {\n                    response: \"User input not available\".to_string(),\n                },\n            },\n\n            Tool::CompleteTask { message } =\u003e match \u0026ui {\n                Some(ui) =\u003e match ui.display(UIMessage::Action(message.clone())).await {\n                    Ok(_) =\u003e ToolResult::CompleteTask {\n                        result: \"Message delivered\".to_string(),\n                    },\n                    Err(e) =\u003e ToolResult::CompleteTask {\n                        result: format!(\"Failed to deliver message: {}\", e),\n                    },\n                },\n                None =\u003e ToolResult::CompleteTask {\n                    result: \"Messaging user not available\".to_string(),\n                },\n            },\n\n            _ =\u003e {\n                let explorer = explorer.ok_or_else(|| {\n                    anyhow::anyhow!(\"This tool requires an active project. Use open_project first.\")\n                })?;\n                match tool {\n                    Tool::ReadFiles { paths } =\u003e {\n                        // Check for absolute paths\n                        for path in paths {\n                            if let Some(error) = check_absolute_path(path) {\n                                return Ok((String::new(), error));\n                            }\n                        }\n                        let mut loaded_files = HashMap::new();\n                        let mut failed_files = Vec::new();\n\n                        for path in paths {\n                            let full_path = explorer.root_dir().join(path);\n                            match explorer.read_file(\u0026full_path) {\n                                Ok(content) =\u003e {\n                                    loaded_files.insert(path.clone(), content);\n                                }\n                                Err(e) =\u003e {\n                                    failed_files.push((path.clone(), e.to_string()));\n                                }\n                            }\n                        }\n\n                        ToolResult::ReadFiles {\n                            loaded_files,\n                            failed_files,\n                        }\n                    }\n\n                    Tool::ListFiles { paths, max_depth } =\u003e {\n                        // Check for absolute paths\n                        for path in paths {\n                            if let Some(error) = check_absolute_path(path) {\n                                return Ok((String::new(), error));\n                            }\n                        }\n                        let explorer = explorer; // Shadow with non-ref binding\n                        let mut expanded_paths = Vec::new();\n                        let mut failed_paths = Vec::new();\n\n                        for path in paths {\n                            let full_path = explorer.root_dir().join(path);\n                            match explorer.list_files(\u0026full_path, *max_depth) {\n                                Ok(tree_entry) =\u003e {\n                                    expanded_paths.push((path.clone(), tree_entry));\n                                }\n                                Err(e) =\u003e {\n                                    failed_paths.push((path.display().to_string(), e.to_string()));\n                                }\n                            }\n                        }\n\n                        ToolResult::ListFiles {\n                            expanded_paths,\n                            failed_paths,\n                        }\n                    }\n\n                    Tool::SearchFiles {\n                        query,\n                        path,\n                        case_sensitive,\n                        whole_words,\n                        regex_mode,\n                        max_results,\n                    } =\u003e {\n                        let options = SearchOptions {\n                            query: query.clone(),\n                            case_sensitive: *case_sensitive,\n                            whole_words: *whole_words,\n                            mode: if *regex_mode {\n                                SearchMode::Regex\n                            } else {\n                                SearchMode::Exact\n                            },\n                            max_results: *max_results,\n                        };\n\n                        let search_path = if let Some(p) = path {\n                            if p.is_absolute() {\n                                p.clone()\n                            } else {\n                                explorer.root_dir().join(p)\n                            }\n                        } else {\n                            explorer.root_dir()\n                        };\n\n                        match explorer.search(\u0026search_path, options) {\n                            Ok(results) =\u003e ToolResult::SearchFiles {\n                                results,\n                                query: query.clone(),\n                            },\n                            Err(e) =\u003e ToolResult::SearchFiles {\n                                results: Vec::new(),\n                                query: format!(\"Search failed: {}\", e),\n                            },\n                        }\n                    }\n\n                    Tool::ExecuteCommand {\n                        command_line,\n                        working_dir,\n                    } =\u003e {\n                        let effective_working_dir = match working_dir {\n                            Some(dir) if dir.is_absolute() =\u003e {\n                                return Ok((\n                                    String::new(),\n                                    ToolResult::ExecuteCommand {\n                                        stdout: String::new(),\n                                        stderr: String::new(),\n                                        error: Some(\n                                            \"Working directory must be relative to project root\"\n                                                .to_string(),\n                                        ),\n                                    },\n                                ));\n                            }\n                            Some(dir) =\u003e explorer.root_dir().join(dir),\n                            None =\u003e explorer.root_dir(),\n                        };\n\n                        match command_executor\n                            .execute(command_line, Some(\u0026effective_working_dir))\n                            .await\n                        {\n                            Ok(output) =\u003e ToolResult::ExecuteCommand {\n                                stdout: output.stdout,\n                                stderr: output.stderr,\n                                error: if output.success {\n                                    None\n                                } else {\n                                    Some(\"Command failed\".to_string())\n                                },\n                            },\n                            Err(e) =\u003e ToolResult::ExecuteCommand {\n                                stdout: String::new(),\n                                stderr: String::new(),\n                                error: Some(e.to_string()),\n                            },\n                        }\n                    }\n\n                    Tool::WriteFile { path, content } =\u003e {\n                        if let Some(error) = check_absolute_path(path) {\n                            return Ok((String::new(), error));\n                        }\n                        let full_path = explorer.root_dir().join(path);\n\n                        match explorer.write_file(\u0026full_path, content) {\n                            Ok(_) =\u003e ToolResult::WriteFile {\n                                path: path.clone(),\n                                content: content.clone(),\n                                error: None,\n                            },\n                            Err(e) =\u003e ToolResult::WriteFile {\n                                path: path.clone(),\n                                content: String::new(), // Empty content on error\n                                error: Some(e.to_string()),\n                            },\n                        }\n                    }\n\n                    Tool::ReplaceInFile { path, replacements } =\u003e {\n                        if let Some(error) = check_absolute_path(path) {\n                            return Ok((String::new(), error));\n                        }\n                        let full_path = explorer.root_dir().join(path);\n\n                        match explorer.apply_replacements(\u0026full_path, replacements) {\n                            Ok(new_content) =\u003e ToolResult::ReplaceInFile {\n                                path: path.clone(),\n                                content: new_content,\n                                error: None,\n                            },\n                            Err(e) =\u003e ToolResult::ReplaceInFile {\n                                path: path.clone(),\n                                content: String::new(), // Empty content on error\n                                error: Some(e.to_string()),\n                            },\n                        }\n                    }\n\n                    Tool::DeleteFiles { paths } =\u003e {\n                        // Check for absolute paths\n                        for path in paths {\n                            if let Some(error) = check_absolute_path(path) {\n                                return Ok((String::new(), error));\n                            }\n                        }\n                        let mut deleted = Vec::new();\n                        let mut failed = Vec::new();\n\n                        for path in paths {\n                            let full_path = explorer.root_dir().join(path);\n                            match explorer.delete_file(\u0026full_path) {\n                                Ok(_) =\u003e deleted.push(path.clone()),\n                                Err(e) =\u003e failed.push((path.clone(), e.to_string())),\n                            }\n                        }\n\n                        ToolResult::DeleteFiles { deleted, failed }\n                    }\n\n                    _ =\u003e unreachable!(),\n                }\n            }\n        };\n\n        // Let the handler process the result and get formatted output\n        let output = handler.handle_result(\u0026result).await?;\n        Ok((output, result))\n    }\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":13}},{"line":19,"address":[],"length":0,"stats":{"Line":26}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":2}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":1}},{"line":60,"address":[],"length":0,"stats":{"Line":1}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":5}},{"line":78,"address":[],"length":0,"stats":{"Line":5}},{"line":80,"address":[],"length":0,"stats":{"Line":5}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":10}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":2}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":100,"address":[],"length":0,"stats":{"Line":6}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":193,"address":[],"length":0,"stats":{"Line":1}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":1}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":1}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":1}},{"line":216,"address":[],"length":0,"stats":{"Line":1}},{"line":217,"address":[],"length":0,"stats":{"Line":2}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":2}},{"line":249,"address":[],"length":0,"stats":{"Line":4}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":2}},{"line":255,"address":[],"length":0,"stats":{"Line":2}},{"line":257,"address":[],"length":0,"stats":{"Line":1}},{"line":262,"address":[],"length":0,"stats":{"Line":1}},{"line":263,"address":[],"length":0,"stats":{"Line":1}},{"line":264,"address":[],"length":0,"stats":{"Line":1}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":13}},{"line":290,"address":[],"length":0,"stats":{"Line":13}}],"covered":37,"coverable":130},{"path":["/","Users","stippi","projects","code-assistant","src","tools","handlers.rs"],"content":"use crate::tools::ToolResultHandler;\nuse crate::types::{FileTreeEntry, ToolResult, WorkingMemory};\nuse crate::PathBuf;\nuse anyhow::Result;\nuse async_trait::async_trait;\n\npub struct AgentToolHandler\u003c'a\u003e {\n    working_memory: \u0026'a mut WorkingMemory,\n}\n\nimpl\u003c'a\u003e AgentToolHandler\u003c'a\u003e {\n    pub fn new(working_memory: \u0026'a mut WorkingMemory) -\u003e Self {\n        Self { working_memory }\n    }\n}\n\n#[async_trait::async_trait]\nimpl\u003c'a\u003e ToolResultHandler for AgentToolHandler\u003c'a\u003e {\n    async fn handle_result(\u0026mut self, result: \u0026ToolResult) -\u003e Result\u003cString\u003e {\n        // Update working memory if tool was successful\n        if result.is_success() {\n            match \u0026result {\n                ToolResult::ListFiles { expanded_paths, .. } =\u003e {\n                    // Update working memory file tree with each entry\n                    if let Some(file_tree) = \u0026mut self.working_memory.file_tree {\n                        for (path, entry) in expanded_paths {\n                            update_tree_entry(file_tree, path, entry.clone())?;\n                        }\n                    }\n                }\n                ToolResult::ReadFiles { loaded_files, .. } =\u003e {\n                    self.working_memory\n                        .loaded_files\n                        .extend(loaded_files.clone());\n                }\n                ToolResult::Summarize { files } =\u003e {\n                    for (path, summary) in files {\n                        self.working_memory.loaded_files.remove(path);\n                        self.working_memory\n                            .file_summaries\n                            .insert(path.clone(), summary.clone());\n                    }\n                }\n                ToolResult::ReplaceInFile { path, content, .. } =\u003e {\n                    // Update working memory if file was loaded\n                    if self.working_memory.loaded_files.contains_key(path) {\n                        self.working_memory\n                            .loaded_files\n                            .insert(path.clone(), content.clone());\n                    }\n                }\n                ToolResult::WriteFile {\n                    path,\n                    content,\n                    error: None,\n                    ..\n                } =\u003e {\n                    // Remove any existing summary since file is new/overwritten\n                    self.working_memory.file_summaries.remove(path);\n                    // Make this file part of the loaded files\n                    self.working_memory\n                        .loaded_files\n                        .insert(path.clone(), content.clone());\n                }\n                ToolResult::DeleteFiles { deleted, .. } =\u003e {\n                    for path in deleted {\n                        self.working_memory.loaded_files.remove(path);\n                        self.working_memory.file_summaries.remove(path);\n                    }\n                }\n                _ =\u003e {}\n            }\n        }\n\n        Ok(result.format_message())\n    }\n}\n\npub struct MCPToolHandler;\n\nimpl MCPToolHandler {\n    pub fn new() -\u003e Self {\n        Self\n    }\n}\n\n#[async_trait]\nimpl ToolResultHandler for MCPToolHandler {\n    async fn handle_result(\u0026mut self, result: \u0026ToolResult) -\u003e Result\u003cString\u003e {\n        match result {\n            ToolResult::ListFiles { expanded_paths, .. } =\u003e {\n                let mut output = String::new();\n                for (path, entry) in expanded_paths {\n                    output.push_str(\u0026format!(\n                        \"Contents of {}:\\n{}\\n\",\n                        path.display(),\n                        entry.to_string()\n                    ));\n                }\n                Ok(output)\n            }\n            ToolResult::ReadFiles { loaded_files, .. } =\u003e {\n                // Format detailed output with file contents\n                let mut output = String::new();\n                for (path, content) in loaded_files {\n                    output.push_str(\u0026format!(\"File: {}\\n{}\\n\", path.display(), content));\n                }\n                Ok(output)\n            }\n            // All other tools use standard message\n            _ =\u003e Ok(result.format_message()),\n        }\n    }\n}\n\npub struct ReplayToolHandler {\n    working_memory: WorkingMemory,\n}\n\nimpl ReplayToolHandler {\n    pub fn new(working_memory: WorkingMemory) -\u003e Self {\n        Self { working_memory }\n    }\n\n    pub fn into_memory(self) -\u003e WorkingMemory {\n        self.working_memory\n    }\n}\n\n#[async_trait]\nimpl ToolResultHandler for ReplayToolHandler {\n    async fn handle_result(\u0026mut self, result: \u0026ToolResult) -\u003e Result\u003cString\u003e {\n        // Only update working memory, ignore filesystem effects\n        if result.is_success() {\n            match \u0026result {\n                ToolResult::ReadFiles { loaded_files, .. } =\u003e {\n                    self.working_memory\n                        .loaded_files\n                        .extend(loaded_files.clone());\n                }\n                ToolResult::Summarize { files } =\u003e {\n                    for (path, summary) in files {\n                        self.working_memory.loaded_files.remove(path);\n                        self.working_memory\n                            .file_summaries\n                            .insert(path.clone(), summary.clone());\n                    }\n                }\n                ToolResult::ReplaceInFile {\n                    path,\n                    content,\n                    error: None,\n                    ..\n                } =\u003e {\n                    if self.working_memory.loaded_files.contains_key(path) {\n                        self.working_memory\n                            .loaded_files\n                            .insert(path.clone(), content.clone());\n                    }\n                }\n                ToolResult::WriteFile {\n                    path, error: None, ..\n                } =\u003e {\n                    // Just remove from working memory if files were loaded\n                    self.working_memory.loaded_files.remove(path);\n                    self.working_memory.file_summaries.remove(path);\n                }\n                ToolResult::ListFiles { expanded_paths, .. } =\u003e {\n                    // Update file tree with the entries\n                    if let Some(file_tree) = \u0026mut self.working_memory.file_tree {\n                        for (path, entry) in expanded_paths {\n                            update_tree_entry(file_tree, path, entry.clone())?;\n                        }\n                    }\n                }\n                _ =\u003e {}\n            }\n        }\n\n        Ok(result.format_message())\n    }\n}\n\nfn update_tree_entry(\n    tree: \u0026mut FileTreeEntry,\n    path: \u0026PathBuf,\n    new_entry: FileTreeEntry,\n) -\u003e Result\u003c()\u003e {\n    let components: Vec\u003c_\u003e = path.components().collect();\n    let mut current = tree;\n\n    for (i, component) in components.iter().enumerate() {\n        let name = component.as_os_str().to_string_lossy().to_string();\n        let is_last = i == components.len() - 1;\n\n        if is_last {\n            current.children.insert(name, new_entry.clone());\n            break;\n        }\n\n        current = current\n            .children\n            .get_mut(\u0026name)\n            .ok_or_else(|| anyhow::anyhow!(\"Path component not found: {}\", name))?;\n    }\n\n    Ok(())\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":13}},{"line":19,"address":[],"length":0,"stats":{"Line":13}},{"line":21,"address":[],"length":0,"stats":{"Line":13}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":2}},{"line":32,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":2}},{"line":34,"address":[],"length":0,"stats":{"Line":2}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":9}},{"line":75,"address":[],"length":0,"stats":{"Line":13}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}}],"covered":14,"coverable":106},{"path":["/","Users","stippi","projects","code-assistant","src","tools","mod.rs"],"content":"use crate::types::ToolResult;\nuse anyhow::Result;\n\nmod definitions;\nmod executor;\nmod handlers;\nmod parse;\nmod result;\n\npub use executor::ToolExecutor;\npub use handlers::{AgentToolHandler, MCPToolHandler, ReplayToolHandler};\npub use parse::{parse_tool_json, parse_tool_xml, TOOL_TAG_PREFIX};\n\n#[async_trait::async_trait]\npub trait ToolResultHandler: Send + Sync {\n    /// Handle a tool result, update internal state if needed, and return formatted output\n    async fn handle_result(\u0026mut self, result: \u0026ToolResult) -\u003e Result\u003cString\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","stippi","projects","code-assistant","src","tools","parse.rs"],"content":"use crate::types::FileReplacement;\nuse crate::types::Tool;\nuse anyhow::Result;\nuse std::collections::HashMap;\nuse std::path::PathBuf;\nuse tracing::trace;\n\npub const TOOL_TAG_PREFIX: \u0026str = \"tool:\";\nconst PARAM_TAG_PREFIX: \u0026str = \"param:\";\n\npub fn parse_tool_xml(xml: \u0026str) -\u003e Result\u003cTool\u003e {\n    trace!(\"Parsing XML:\\n{}\", xml);\n\n    let tool_name = xml\n        .trim()\n        .strip_prefix(\u0026format!(\"\u003c{}\", TOOL_TAG_PREFIX))\n        .and_then(|s| s.split_whitespace().next())\n        .and_then(|s| s.strip_suffix('\u003e'))\n        .ok_or_else(|| anyhow::anyhow!(\"Missing tool name\"))?\n        .to_string();\n\n    trace!(\"Found tool name: {}\", tool_name);\n\n    let mut params: HashMap\u003cString, Vec\u003cString\u003e\u003e = HashMap::new();\n    let mut current_param = String::new();\n    let mut content_start = 0;\n\n    let mut chars = xml.char_indices().peekable();\n    while let Some((i, ch)) = chars.next() {\n        if ch == '\u003c' {\n            // Check for parameter tag\n            let rest = \u0026xml[i..];\n            trace!(\"Found '\u003c', rest of string: {}\", rest);\n            if rest.starts_with(\u0026format!(\"\u003c/{}\", PARAM_TAG_PREFIX)) {\n                // Closing tag\n                let param_name = rest[format!(\"\u003c/{}\", PARAM_TAG_PREFIX).len()..] // skip the \"\u003c/param:\"\n                    .split('\u003e')\n                    .next()\n                    .ok_or_else(|| anyhow::anyhow!(\"Invalid closing tag format\"))?;\n                trace!(\"Found closing tag for: {}\", param_name);\n                if param_name == current_param {\n                    let content = \u0026xml[content_start..i];\n                    trace!(\"Found content for {}: {}\", current_param, content);\n                    params\n                        .entry(current_param.clone())\n                        .or_default()\n                        .push(content.to_string());\n                    current_param.clear();\n                }\n            } else if let Some(param_start) = rest.strip_prefix(\u0026format!(\"\u003c{}\", PARAM_TAG_PREFIX)) {\n                // Opening tag\n                if let Some(param_name) = param_start.split('\u003e').next() {\n                    current_param = param_name.to_string();\n                    content_start = i + format!(\"\u003c{}{}\u003e\", PARAM_TAG_PREFIX, param_name).len();\n                    trace!(\"Found param start: {} at {}\", current_param, content_start);\n                }\n            }\n        }\n    }\n\n    trace!(\"Final parameters: {:?}\", params);\n    parse_tool_from_params(\u0026tool_name, \u0026params)\n}\n\nfn parse_search_replace_blocks(content: \u0026str) -\u003e Result\u003cVec\u003cFileReplacement\u003e\u003e {\n    let mut replacements = Vec::new();\n    let mut lines = content.lines().peekable();\n\n    while let Some(line) = lines.next() {\n        if line.trim() == \"\u003c\u003c\u003c\u003c\u003c\u003c\u003c SEARCH\" {\n            let mut search = String::new();\n            let mut replace = String::new();\n\n            // Collect search content\n            while let Some(line) = lines.next() {\n                if line.trim() == \"=======\" {\n                    break;\n                }\n                if !search.is_empty() {\n                    search.push('\\n');\n                }\n                search.push_str(line);\n            }\n\n            // Collect replace content\n            while let Some(line) = lines.next() {\n                if line.trim() == \"\u003e\u003e\u003e\u003e\u003e\u003e\u003e REPLACE\" {\n                    break;\n                }\n                if !replace.is_empty() {\n                    replace.push('\\n');\n                }\n                replace.push_str(line);\n            }\n\n            replacements.push(FileReplacement { search, replace });\n        }\n    }\n\n    Ok(replacements)\n}\n\npub fn parse_tool_from_params(\n    tool_name: \u0026str,\n    params: \u0026HashMap\u003cString, Vec\u003cString\u003e\u003e,\n) -\u003e Result\u003cTool\u003e {\n    match tool_name {\n        \"search_files\" =\u003e Ok(Tool::SearchFiles {\n            query: params\n                .get(\"query\")\n                .ok_or_else(|| anyhow::anyhow!(\"Missing query\"))?\n                .first()\n                .ok_or_else(|| anyhow::anyhow!(\"Query parameter is empty\"))?\n                .to_string(),\n            path: params\n                .get(\"path\")\n                .and_then(|v| v.first())\n                .map(PathBuf::from),\n            case_sensitive: params\n                .get(\"case_sensitive\")\n                .map_or(false, |v| v.first().map_or(false, |s| s == \"true\")),\n            whole_words: params\n                .get(\"whole_words\")\n                .map_or(false, |v| v.first().map_or(false, |s| s == \"true\")),\n            regex_mode: params\n                .get(\"regex_mode\")\n                .map_or(false, |v| v.first().map_or(false, |s| s == \"true\")),\n            max_results: params\n                .get(\"max_results\")\n                .and_then(|v| v.first())\n                .map(|v| v.trim().parse::\u003cusize\u003e())\n                .transpose()?,\n        }),\n\n        \"list_files\" =\u003e Ok(Tool::ListFiles {\n            paths: params\n                .get(\"path\")\n                .ok_or_else(|| anyhow::anyhow!(\"Missing path parameter\"))?\n                .iter()\n                .map(|s| PathBuf::from(s.trim()))\n                .collect(),\n            max_depth: params\n                .get(\"max_depth\")\n                .and_then(|v| v.first())\n                .map(|v| v.trim().parse::\u003cusize\u003e())\n                .transpose()?,\n        }),\n\n        \"read_files\" =\u003e Ok(Tool::ReadFiles {\n            paths: params\n                .get(\"path\")\n                .ok_or_else(|| anyhow::anyhow!(\"Missing path parameter\"))?\n                .iter()\n                .map(|s| PathBuf::from(s.trim()))\n                .collect(),\n        }),\n\n        \"summarize\" =\u003e Ok(Tool::Summarize {\n            files: params\n                .get(\"file\")\n                .ok_or_else(|| anyhow::anyhow!(\"Missing file parameter\"))?\n                .iter()\n                .filter_map(|line| {\n                    let mut parts = line.splitn(2, ':');\n                    Some((\n                        PathBuf::from(parts.next()?.trim()),\n                        parts.next()?.trim().to_string(),\n                    ))\n                })\n                .collect(),\n        }),\n\n        \"replace_in_file\" =\u003e Ok(Tool::ReplaceInFile {\n            path: PathBuf::from(\n                params\n                    .get(\"path\")\n                    .and_then(|v| v.first())\n                    .ok_or_else(|| anyhow::anyhow!(\"Missing path parameter\"))?,\n            ),\n            replacements: parse_search_replace_blocks(\n                params\n                    .get(\"diff\")\n                    .and_then(|v| v.first())\n                    .ok_or_else(|| anyhow::anyhow!(\"Missing diff parameter\"))?,\n            )?,\n        }),\n\n        \"write_file\" =\u003e Ok(Tool::WriteFile {\n            path: PathBuf::from(\n                params\n                    .get(\"path\")\n                    .and_then(|v| v.first())\n                    .ok_or_else(|| anyhow::anyhow!(\"Missing path parameter\"))?,\n            ),\n            content: params\n                .get(\"content\")\n                .and_then(|v| v.first())\n                .ok_or_else(|| anyhow::anyhow!(\"Missing content parameter\"))?\n                .to_string(),\n        }),\n\n        \"delete_files\" =\u003e Ok(Tool::DeleteFiles {\n            paths: params\n                .get(\"path\")\n                .ok_or_else(|| anyhow::anyhow!(\"Missing path parameter\"))?\n                .iter()\n                .map(|s| PathBuf::from(s.trim()))\n                .collect(),\n        }),\n\n        \"ask_user\" =\u003e Ok(Tool::AskUser {\n            question: params\n                .get(\"question\")\n                .ok_or_else(|| anyhow::anyhow!(\"Missing question parameter\"))?\n                .first()\n                .ok_or_else(|| anyhow::anyhow!(\"Question parameter is empty\"))?\n                .to_string(),\n        }),\n\n        \"message_user\" =\u003e Ok(Tool::MessageUser {\n            message: params\n                .get(\"message\")\n                .ok_or_else(|| anyhow::anyhow!(\"Missing message parameter\"))?\n                .first()\n                .ok_or_else(|| anyhow::anyhow!(\"Message parameter is empty\"))?\n                .to_string(),\n        }),\n\n        \"complete_task\" =\u003e Ok(Tool::CompleteTask {\n            message: params\n                .get(\"message\")\n                .ok_or_else(|| anyhow::anyhow!(\"Missing message parameter\"))?\n                .first()\n                .ok_or_else(|| anyhow::anyhow!(\"Message parameter is empty\"))?\n                .to_string(),\n        }),\n\n        \"execute_command\" =\u003e Ok(Tool::ExecuteCommand {\n            command_line: params\n                .get(\"command_line\")\n                .ok_or_else(|| anyhow::anyhow!(\"Missing command_line parameter\"))?\n                .first()\n                .ok_or_else(|| anyhow::anyhow!(\"Command line parameter is empty\"))?\n                .to_string(),\n            working_dir: params\n                .get(\"working_dir\")\n                .and_then(|v| v.first())\n                .map(|v| PathBuf::from(v)),\n        }),\n\n        _ =\u003e Err(anyhow::anyhow!(\"Unknown tool: {}\", tool_name)),\n    }\n}\n\npub fn parse_tool_json(name: \u0026str, params: \u0026serde_json::Value) -\u003e Result\u003cTool\u003e {\n    match name {\n        \"list_projects\" =\u003e Ok(Tool::ListProjects),\n        \"open_project\" =\u003e Ok(Tool::OpenProject {\n            name: params[\"name\"]\n                .as_str()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing project name\"))?\n                .to_string(),\n        }),\n        \"execute_command\" =\u003e Ok(Tool::ExecuteCommand {\n            command_line: params[\"command_line\"]\n                .as_str()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing command_line\"))?\n                .to_string(),\n            working_dir: params\n                .get(\"working_dir\")\n                .and_then(|d| d.as_str())\n                .map(PathBuf::from),\n        }),\n        \"search_files\" =\u003e Ok(Tool::SearchFiles {\n            query: params[\"query\"]\n                .as_str()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing query\"))?\n                .to_string(),\n            path: params\n                .get(\"path\")\n                .and_then(|p| p.as_str())\n                .map(PathBuf::from),\n            case_sensitive: params\n                .get(\"case_sensitive\")\n                .and_then(|b| b.as_bool())\n                .unwrap_or(false),\n            whole_words: params\n                .get(\"whole_words\")\n                .and_then(|b| b.as_bool())\n                .unwrap_or(false),\n            regex_mode: params\n                .get(\"mode\")\n                .and_then(|m| m.as_str())\n                .map_or(false, |m| m == \"regex\"),\n            max_results: params\n                .get(\"max_results\")\n                .and_then(|n| n.as_u64())\n                .map(|n| n as usize),\n        }),\n        \"list_files\" =\u003e Ok(Tool::ListFiles {\n            paths: params[\"paths\"]\n                .as_array()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing or invalid paths array\"))?\n                .iter()\n                .map(|p| {\n                    Ok(PathBuf::from(\n                        p.as_str()\n                            .ok_or_else(|| anyhow::anyhow!(\"Invalid path in array\"))?,\n                    ))\n                })\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?,\n            max_depth: params[\"max_depth\"].as_u64().map(|d| d as usize),\n        }),\n        \"read_files\" =\u003e Ok(Tool::ReadFiles {\n            paths: params[\"paths\"]\n                .as_array()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing or invalid paths array\"))?\n                .iter()\n                .map(|p| {\n                    Ok(PathBuf::from(\n                        p.as_str()\n                            .ok_or_else(|| anyhow::anyhow!(\"Invalid path in array\"))?,\n                    ))\n                })\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?,\n        }),\n        \"summarize\" =\u003e Ok(Tool::Summarize {\n            files: params[\"files\"]\n                .as_array()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing or invalid files array\"))?\n                .iter()\n                .map(|f| {\n                    Ok((\n                        PathBuf::from(\n                            f[\"path\"]\n                                .as_str()\n                                .ok_or_else(|| anyhow::anyhow!(\"Missing path in file entry\"))?,\n                        ),\n                        f[\"summary\"]\n                            .as_str()\n                            .ok_or_else(|| anyhow::anyhow!(\"Missing summary in file entry\"))?\n                            .to_string(),\n                    ))\n                })\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?,\n        }),\n        \"replace_in_file\" =\u003e Ok(Tool::ReplaceInFile {\n            path: PathBuf::from(\n                params[\"path\"]\n                    .as_str()\n                    .ok_or_else(|| anyhow::anyhow!(\"Missing path parameter\"))?,\n            ),\n            replacements: params[\"replacements\"]\n                .as_array()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing replacements array\"))?\n                .iter()\n                .map(|r| {\n                    Ok(FileReplacement {\n                        search: r[\"search\"]\n                            .as_str()\n                            .ok_or_else(|| anyhow::anyhow!(\"Missing search content\"))?\n                            .to_string(),\n                        replace: r[\"replace\"]\n                            .as_str()\n                            .ok_or_else(|| anyhow::anyhow!(\"Missing replace content\"))?\n                            .to_string(),\n                    })\n                })\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?,\n        }),\n        \"write_file\" =\u003e Ok(Tool::WriteFile {\n            path: PathBuf::from(\n                params[\"path\"]\n                    .as_str()\n                    .ok_or_else(|| anyhow::anyhow!(\"Missing path parameter\"))?,\n            ),\n            content: params[\"content\"]\n                .as_str()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing content parameter\"))?\n                .to_string(),\n        }),\n        \"delete_files\" =\u003e Ok(Tool::DeleteFiles {\n            paths: params[\"paths\"]\n                .as_array()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing or invalid paths array\"))?\n                .iter()\n                .map(|p| {\n                    Ok(PathBuf::from(\n                        p.as_str()\n                            .ok_or_else(|| anyhow::anyhow!(\"Invalid path in array\"))?,\n                    ))\n                })\n                .collect::\u003cResult\u003cVec\u003c_\u003e\u003e\u003e()?,\n        }),\n        \"ask_user\" =\u003e Ok(Tool::AskUser {\n            question: params[\"question\"]\n                .as_str()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing question parameter\"))?\n                .to_string(),\n        }),\n        \"message_user\" =\u003e Ok(Tool::MessageUser {\n            message: params[\"message\"]\n                .as_str()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing message parameter\"))?\n                .to_string(),\n        }),\n        \"complete_task\" =\u003e Ok(Tool::CompleteTask {\n            message: params[\"message\"]\n                .as_str()\n                .ok_or_else(|| anyhow::anyhow!(\"Missing message parameter\"))?\n                .to_string(),\n        }),\n        _ =\u003e Err(anyhow::anyhow!(\"Unknown tool: {}\", name)),\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":2}},{"line":12,"address":[],"length":0,"stats":{"Line":2}},{"line":14,"address":[],"length":0,"stats":{"Line":4}},{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":4}},{"line":18,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":2}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":26,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":2}},{"line":29,"address":[],"length":0,"stats":{"Line":1038}},{"line":32,"address":[],"length":0,"stats":{"Line":31}},{"line":33,"address":[],"length":0,"stats":{"Line":31}},{"line":34,"address":[],"length":0,"stats":{"Line":31}},{"line":36,"address":[],"length":0,"stats":{"Line":12}},{"line":39,"address":[],"length":0,"stats":{"Line":12}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":6}},{"line":42,"address":[],"length":0,"stats":{"Line":6}},{"line":43,"address":[],"length":0,"stats":{"Line":6}},{"line":44,"address":[],"length":0,"stats":{"Line":6}},{"line":45,"address":[],"length":0,"stats":{"Line":6}},{"line":47,"address":[],"length":0,"stats":{"Line":6}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":50,"address":[],"length":0,"stats":{"Line":31}},{"line":52,"address":[],"length":0,"stats":{"Line":6}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":62,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":67,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":9}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":75,"address":[],"length":0,"stats":{"Line":12}},{"line":77,"address":[],"length":0,"stats":{"Line":2}},{"line":79,"address":[],"length":0,"stats":{"Line":6}},{"line":80,"address":[],"length":0,"stats":{"Line":2}},{"line":82,"address":[],"length":0,"stats":{"Line":4}},{"line":86,"address":[],"length":0,"stats":{"Line":12}},{"line":88,"address":[],"length":0,"stats":{"Line":2}},{"line":90,"address":[],"length":0,"stats":{"Line":6}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":2}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":2}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":108,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":2}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":1}},{"line":117,"address":[],"length":0,"stats":{"Line":2}},{"line":121,"address":[],"length":0,"stats":{"Line":3}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":1}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":175,"address":[],"length":0,"stats":{"Line":1}},{"line":176,"address":[],"length":0,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":3}},{"line":178,"address":[],"length":0,"stats":{"Line":2}},{"line":181,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":2}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":13}},{"line":256,"address":[],"length":0,"stats":{"Line":13}},{"line":257,"address":[],"length":0,"stats":{"Line":13}},{"line":258,"address":[],"length":0,"stats":{"Line":13}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":13}},{"line":265,"address":[],"length":0,"stats":{"Line":1}},{"line":266,"address":[],"length":0,"stats":{"Line":1}},{"line":267,"address":[],"length":0,"stats":{"Line":2}},{"line":268,"address":[],"length":0,"stats":{"Line":1}},{"line":269,"address":[],"length":0,"stats":{"Line":1}},{"line":270,"address":[],"length":0,"stats":{"Line":1}},{"line":271,"address":[],"length":0,"stats":{"Line":3}},{"line":272,"address":[],"length":0,"stats":{"Line":1}},{"line":274,"address":[],"length":0,"stats":{"Line":12}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":12}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":12}},{"line":315,"address":[],"length":0,"stats":{"Line":2}},{"line":316,"address":[],"length":0,"stats":{"Line":2}},{"line":317,"address":[],"length":0,"stats":{"Line":4}},{"line":318,"address":[],"length":0,"stats":{"Line":2}},{"line":319,"address":[],"length":0,"stats":{"Line":4}},{"line":320,"address":[],"length":0,"stats":{"Line":2}},{"line":321,"address":[],"length":0,"stats":{"Line":2}},{"line":322,"address":[],"length":0,"stats":{"Line":4}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":10}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":10}},{"line":349,"address":[],"length":0,"stats":{"Line":2}},{"line":350,"address":[],"length":0,"stats":{"Line":2}},{"line":351,"address":[],"length":0,"stats":{"Line":4}},{"line":353,"address":[],"length":0,"stats":{"Line":2}},{"line":354,"address":[],"length":0,"stats":{"Line":2}},{"line":355,"address":[],"length":0,"stats":{"Line":2}},{"line":356,"address":[],"length":0,"stats":{"Line":2}},{"line":357,"address":[],"length":0,"stats":{"Line":4}},{"line":358,"address":[],"length":0,"stats":{"Line":2}},{"line":359,"address":[],"length":0,"stats":{"Line":2}},{"line":360,"address":[],"length":0,"stats":{"Line":2}},{"line":361,"address":[],"length":0,"stats":{"Line":4}},{"line":362,"address":[],"length":0,"stats":{"Line":2}},{"line":363,"address":[],"length":0,"stats":{"Line":2}},{"line":364,"address":[],"length":0,"stats":{"Line":2}},{"line":365,"address":[],"length":0,"stats":{"Line":2}},{"line":366,"address":[],"length":0,"stats":{"Line":2}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":8}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":8}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":8}},{"line":396,"address":[],"length":0,"stats":{"Line":1}},{"line":397,"address":[],"length":0,"stats":{"Line":1}},{"line":398,"address":[],"length":0,"stats":{"Line":2}},{"line":399,"address":[],"length":0,"stats":{"Line":1}},{"line":401,"address":[],"length":0,"stats":{"Line":7}},{"line":402,"address":[],"length":0,"stats":{"Line":2}},{"line":403,"address":[],"length":0,"stats":{"Line":2}},{"line":404,"address":[],"length":0,"stats":{"Line":4}},{"line":405,"address":[],"length":0,"stats":{"Line":2}},{"line":407,"address":[],"length":0,"stats":{"Line":5}},{"line":408,"address":[],"length":0,"stats":{"Line":5}},{"line":409,"address":[],"length":0,"stats":{"Line":5}},{"line":410,"address":[],"length":0,"stats":{"Line":5}},{"line":411,"address":[],"length":0,"stats":{"Line":5}},{"line":413,"address":[],"length":0,"stats":{"Line":0}}],"covered":131,"coverable":285},{"path":["/","Users","stippi","projects","code-assistant","src","tools","result.rs"],"content":"use crate::types::ToolResult;\n\nimpl ToolResult {\n    // Format a user-facing message describing the result\n    pub fn format_message(\u0026self) -\u003e String {\n        match self {\n            ToolResult::ListProjects { projects } =\u003e {\n                if projects.is_empty() {\n                    \"No projects configured.\".to_string()\n                } else {\n                    let mut msg = String::from(\"Available projects:\\n\");\n                    for (name, project) in projects {\n                        msg.push_str(\u0026format!(\"- {}: {}\\n\", name, project.path.display()));\n                    }\n                    msg\n                }\n            }\n            ToolResult::OpenProject { name, error, .. } =\u003e {\n                if error.is_none() {\n                    format!(\"Successfully opened project '{}'\", name)\n                } else {\n                    format!(\n                        \"Failed to open project '{}': {}\",\n                        name,\n                        error.as_ref().unwrap_or(\u0026\"unknown error\".to_string())\n                    )\n                }\n            }\n            ToolResult::AbsolutePathError { path } =\u003e {\n                format!(\"Path must be relative to project root: {}\", path.display())\n            }\n            ToolResult::ReadFiles {\n                loaded_files,\n                failed_files,\n            } =\u003e {\n                let mut msg = String::new();\n                if !loaded_files.is_empty() {\n                    msg.push_str(\u0026format!(\n                        \"Successfully loaded files: {}\",\n                        loaded_files\n                            .keys()\n                            .map(|p| p.display().to_string())\n                            .collect::\u003cVec\u003c_\u003e\u003e()\n                            .join(\", \")\n                    ));\n                }\n                if !failed_files.is_empty() {\n                    if !msg.is_empty() {\n                        msg.push_str(\"\\n\");\n                    }\n                    msg.push_str(\"Failed to load: \");\n                    msg.push_str(\n                        \u0026failed_files\n                            .iter()\n                            .map(|(p, e)| format!(\"{}: {}\", p.display(), e))\n                            .collect::\u003cVec\u003c_\u003e\u003e()\n                            .join(\", \"),\n                    );\n                }\n                msg\n            }\n            ToolResult::ListFiles {\n                expanded_paths,\n                failed_paths,\n                ..\n            } =\u003e {\n                let mut msg = String::new();\n                if !expanded_paths.is_empty() {\n                    msg.push_str(\u0026format!(\"Successfully listed contents of: \"));\n                    msg.push_str(\n                        \u0026expanded_paths\n                            .iter()\n                            .map(|(path, _)| format!(\"{}\", path.display()))\n                            .collect::\u003cVec\u003c_\u003e\u003e()\n                            .join(\"; \"),\n                    );\n                }\n                if !failed_paths.is_empty() {\n                    if !msg.is_empty() {\n                        msg.push_str(\"\\n\");\n                    }\n                    msg.push_str(\"Failed listing: \");\n                    msg.push_str(\n                        \u0026failed_paths\n                            .iter()\n                            .map(|(path, err)| format!(\"{}: {}\", path, err))\n                            .collect::\u003cVec\u003c_\u003e\u003e()\n                            .join(\"; \"),\n                    );\n                }\n                msg\n            }\n            ToolResult::SearchFiles { results, query } =\u003e {\n                if results.is_empty() {\n                    format!(\"No matches found for '{}'\", query)\n                } else {\n                    let mut msg = format!(\"Found matches for '{}':\\n\", query);\n                    for result in results {\n                        msg.push_str(\u0026format!(\n                            \"{}:{}-{}:\\n\",\n                            result.file.display(),\n                            result.start_line + 1,\n                            result.start_line + result.line_content.len()\n                        ));\n                        for (i, line) in result.line_content.iter().enumerate() {\n                            let line_prefix = if result.match_lines.contains(\u0026i) {\n                                \"\u003e\"\n                            } else {\n                                \" \"\n                            };\n                            msg.push_str(\u0026format!(\"{} {}\\n\", line_prefix, line));\n                        }\n                        msg.push('\\n');\n                    }\n                    msg\n                }\n            }\n            ToolResult::ExecuteCommand {\n                stdout,\n                stderr,\n                error,\n            } =\u003e {\n                let mut msg = String::new();\n                if !stdout.is_empty() {\n                    msg.push_str(\"Output:\\n\");\n                    msg.push_str(stdout);\n                }\n                if !stderr.is_empty() {\n                    if !msg.is_empty() {\n                        msg.push_str(\"\\n\");\n                    }\n                    msg.push_str(\"Errors:\\n\");\n                    msg.push_str(stderr);\n                }\n                if error.is_some() {\n                    if !msg.is_empty() {\n                        msg.push_str(\"\\n\");\n                    }\n                    msg.push_str(\u0026format!(\"Command failed: {}\", error.as_ref().unwrap()));\n                }\n                msg\n            }\n            ToolResult::WriteFile { path, error, .. } =\u003e {\n                if error.is_some() {\n                    format!(\n                        \"Failed to write file {}: {}\",\n                        path.display(),\n                        error.as_ref().unwrap()\n                    )\n                } else {\n                    format!(\"Successfully wrote file: {}\", path.display())\n                }\n            }\n            ToolResult::ReplaceInFile { path, error, .. } =\u003e {\n                if error.is_some() {\n                    format!(\n                        \"Failed to replace in file {}: {}\",\n                        path.display(),\n                        error.as_ref().unwrap()\n                    )\n                } else {\n                    format!(\"Successfully replaced in file: {}\", path.display())\n                }\n            }\n            ToolResult::DeleteFiles { deleted, failed } =\u003e {\n                let mut msg = String::new();\n                if !deleted.is_empty() {\n                    msg.push_str(\u0026format!(\n                        \"Successfully deleted: {}\",\n                        deleted\n                            .iter()\n                            .map(|p| p.display().to_string())\n                            .collect::\u003cVec\u003c_\u003e\u003e()\n                            .join(\", \")\n                    ));\n                }\n                if !failed.is_empty() {\n                    if !msg.is_empty() {\n                        msg.push_str(\"\\n\");\n                    }\n                    msg.push_str(\"Failed to delete: \");\n                    msg.push_str(\n                        \u0026failed\n                            .iter()\n                            .map(|(p, e)| format!(\"{}: {}\", p.display(), e))\n                            .collect::\u003cVec\u003c_\u003e\u003e()\n                            .join(\", \"),\n                    );\n                }\n                msg\n            }\n            ToolResult::Summarize { files } =\u003e {\n                format!(\"Created summaries for {} files\", files.len())\n            }\n            ToolResult::AskUser { response } =\u003e response.clone(),\n            ToolResult::MessageUser { result } =\u003e result.clone(),\n            ToolResult::CompleteTask { result } =\u003e result.clone(),\n        }\n    }\n\n    pub fn is_success(\u0026self) -\u003e bool {\n        match self {\n            ToolResult::ListProjects { .. } =\u003e true,\n            ToolResult::OpenProject { error, .. } =\u003e error.is_none(),\n            ToolResult::AbsolutePathError { .. } =\u003e false,\n            ToolResult::ReadFiles {\n                loaded_files,\n                failed_files,\n            } =\u003e !loaded_files.is_empty() \u0026\u0026 failed_files.is_empty(),\n            ToolResult::ListFiles {\n                expanded_paths,\n                failed_paths,\n                ..\n            } =\u003e !expanded_paths.is_empty() \u0026\u0026 failed_paths.is_empty(),\n            ToolResult::SearchFiles { .. } =\u003e true,\n            ToolResult::ExecuteCommand { error, .. } =\u003e error.is_none(),\n            ToolResult::WriteFile { error, .. } =\u003e error.is_none(),\n            ToolResult::ReplaceInFile { error, .. } =\u003e error.is_none(),\n            ToolResult::DeleteFiles {\n                deleted, failed, ..\n            } =\u003e !deleted.is_empty() \u0026\u0026 failed.is_empty(),\n            ToolResult::Summarize { .. } =\u003e true,\n            ToolResult::AskUser { .. } =\u003e true,\n            ToolResult::MessageUser { .. } =\u003e true,\n            ToolResult::CompleteTask { .. } =\u003e true,\n        }\n    }\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":23}},{"line":6,"address":[],"length":0,"stats":{"Line":23}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}},{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":6}},{"line":35,"address":[],"length":0,"stats":{"Line":6}},{"line":36,"address":[],"length":0,"stats":{"Line":6}},{"line":37,"address":[],"length":0,"stats":{"Line":6}},{"line":38,"address":[],"length":0,"stats":{"Line":12}},{"line":39,"address":[],"length":0,"stats":{"Line":6}},{"line":40,"address":[],"length":0,"stats":{"Line":6}},{"line":41,"address":[],"length":0,"stats":{"Line":6}},{"line":42,"address":[],"length":0,"stats":{"Line":6}},{"line":43,"address":[],"length":0,"stats":{"Line":12}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":6}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":2}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":122,"address":[],"length":0,"stats":{"Line":2}},{"line":123,"address":[],"length":0,"stats":{"Line":2}},{"line":124,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[],"length":0,"stats":{"Line":2}},{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":129,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":2}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":2}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":4}},{"line":152,"address":[],"length":0,"stats":{"Line":4}},{"line":153,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":2}},{"line":156,"address":[],"length":0,"stats":{"Line":2}},{"line":159,"address":[],"length":0,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":4}},{"line":194,"address":[],"length":0,"stats":{"Line":5}},{"line":198,"address":[],"length":0,"stats":{"Line":26}},{"line":199,"address":[],"length":0,"stats":{"Line":26}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":4}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":2}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":4}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":2}},{"line":211,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":10}}],"covered":42,"coverable":132},{"path":["/","Users","stippi","projects","code-assistant","src","types.rs"],"content":"use anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Project {\n    pub path: PathBuf,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct FileTreeEntry {\n    pub name: String,\n    pub entry_type: FileSystemEntryType,\n    pub children: HashMap\u003cString, FileTreeEntry\u003e,\n    pub is_expanded: bool,\n}\n\n/// Represents the agent's working memory during execution\n#[derive(Debug, Serialize, Deserialize, Default, Clone)]\npub struct WorkingMemory {\n    /// Currently loaded file contents\n    pub loaded_files: HashMap\u003cPathBuf, String\u003e,\n    /// Summaries of previously seen files\n    pub file_summaries: HashMap\u003cPathBuf, String\u003e,\n    /// Complete file tree of the repository\n    pub file_tree: Option\u003cFileTreeEntry\u003e,\n    /// Current task description\n    pub current_task: String,\n    /// Memory of previous actions and their results\n    pub action_history: Vec\u003cActionResult\u003e,\n    /// Additional context or notes the agent has generated\n    pub notes: Vec\u003cString\u003e,\n}\n\n/// Details for a text replacement operation\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct FileReplacement {\n    /// The text to search for. Must match exactly one location in the file.\n    pub search: String,\n    /// The text to replace it with\n    pub replace: String,\n}\n\n/// Available tools the agent can use\n#[derive(Debug, Serialize, Deserialize, Clone)]\n#[serde(tag = \"tool\", content = \"params\")]\npub enum Tool {\n    /// List available projects\n    ListProjects,\n    /// Open a project by name\n    OpenProject { name: String },\n    /// Delete one or more files\n    DeleteFiles { paths: Vec\u003cPathBuf\u003e },\n    /// List contents of directories\n    ListFiles {\n        paths: Vec\u003cPathBuf\u003e,\n        // Optional depth limit, None means unlimited\n        max_depth: Option\u003cusize\u003e,\n    },\n    /// Read content of one or multiple files into working memory\n    ReadFiles { paths: Vec\u003cPathBuf\u003e },\n    /// Write content to a file\n    WriteFile { path: PathBuf, content: String },\n    /// Replace parts within a file. Each search text must match exactly once.\n    /// Returns an error if any search text matches zero or multiple times.\n    ReplaceInFile {\n        path: PathBuf,\n        replacements: Vec\u003cFileReplacement\u003e,\n    },\n    /// Replace file content with summaries in working memory\n    Summarize { files: Vec\u003c(PathBuf, String)\u003e },\n    /// Ask user a question and wait for response\n    AskUser { question: String },\n    /// Message the user\n    MessageUser { message: String },\n    /// Complete the current task\n    CompleteTask { message: String },\n    /// Execute a CLI command\n    ExecuteCommand {\n        /// The complete command line to execute\n        command_line: String,\n        /// Optional working directory for the command\n        working_dir: Option\u003cPathBuf\u003e,\n    },\n    /// Search for text in files\n    SearchFiles {\n        /// The text to search for\n        query: String,\n        /// Optional directory path to search in\n        path: Option\u003cPathBuf\u003e,\n        /// Whether the search should be case-sensitive\n        case_sensitive: bool,\n        /// Whether to match whole words only\n        whole_words: bool,\n        /// Whether to use regex mode\n        regex_mode: bool,\n        /// Maximum number of results to return\n        max_results: Option\u003cusize\u003e,\n    },\n}\n\n/// Specific results for each tool type\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub enum ToolResult {\n    ListProjects {\n        projects: HashMap\u003cString, Project\u003e,\n    },\n    OpenProject {\n        name: String,\n        path: Option\u003cPathBuf\u003e,\n        error: Option\u003cString\u003e,\n    },\n    AbsolutePathError {\n        path: PathBuf,\n    },\n    ReadFiles {\n        loaded_files: HashMap\u003cPathBuf, String\u003e,\n        failed_files: Vec\u003c(PathBuf, String)\u003e,\n    },\n    ListFiles {\n        expanded_paths: Vec\u003c(PathBuf, FileTreeEntry)\u003e,\n        failed_paths: Vec\u003c(String, String)\u003e,\n    },\n    SearchFiles {\n        results: Vec\u003cSearchResult\u003e,\n        query: String,\n    },\n    ExecuteCommand {\n        stdout: String,\n        stderr: String,\n        error: Option\u003cString\u003e,\n    },\n    WriteFile {\n        path: PathBuf,\n        content: String,\n        error: Option\u003cString\u003e,\n    },\n    ReplaceInFile {\n        path: PathBuf,\n        content: String,\n        error: Option\u003cString\u003e,\n    },\n    DeleteFiles {\n        deleted: Vec\u003cPathBuf\u003e,\n        failed: Vec\u003c(PathBuf, String)\u003e,\n    },\n    Summarize {\n        files: Vec\u003c(PathBuf, String)\u003e,\n    },\n    AskUser {\n        response: String,\n    },\n    MessageUser {\n        result: String,\n    },\n    CompleteTask {\n        result: String,\n    },\n}\n\n/// Collection of all available tool definitions\n#[derive(Debug, Clone)]\npub struct Tools;\n\n/// Tool description for LLM\n#[derive(Debug, Clone, Serialize)]\npub struct ToolDefinition {\n    pub name: String,\n    pub description: String,\n    pub parameters: serde_json::Value,\n}\n\n/// Represents the parsed response from the LLM\n#[derive(Debug, Deserialize)]\npub struct AgentAction {\n    pub tool: Tool,\n    pub reasoning: String,\n}\n\n/// Result of a tool execution\n#[derive(Clone, Debug, Deserialize, Serialize)]\npub struct ActionResult {\n    pub tool: Tool,\n    pub result: ToolResult,\n    pub reasoning: String,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct FileSystemEntry {\n    pub path: PathBuf,\n    pub name: String,\n    pub entry_type: FileSystemEntryType,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\npub enum FileSystemEntryType {\n    File,\n    Directory,\n}\n\n#[derive(Debug, Clone)]\npub enum SearchMode {\n    /// Standard text search, case-insensitive by default\n    Exact,\n    /// Regular expression search\n    Regex,\n}\n\nimpl Default for SearchMode {\n    fn default() -\u003e Self {\n        Self::Exact\n    }\n}\n\n#[derive(Debug, Clone, Default)]\npub struct SearchOptions {\n    pub query: String,\n    pub case_sensitive: bool,\n    pub whole_words: bool,\n    pub mode: SearchMode,\n    pub max_results: Option\u003cusize\u003e,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct SearchResult {\n    pub file: PathBuf,\n    pub start_line: usize, // First line in the section (including context)\n    pub line_content: Vec\u003cString\u003e, // All lines in the section\n    pub match_lines: Vec\u003cusize\u003e, // Line numbers with matches (relative to start_line)\n    pub match_ranges: Vec\u003cVec\u003c(usize, usize)\u003e\u003e, // Match positions for each line, aligned with match_lines\n}\n\npub trait CodeExplorer: Send + Sync {\n    fn root_dir(\u0026self) -\u003e PathBuf;\n    /// Reads the content of a file\n    fn read_file(\u0026self, path: \u0026PathBuf) -\u003e Result\u003cString\u003e;\n    /// Write the content of a file\n    fn write_file(\u0026self, path: \u0026PathBuf, content: \u0026String) -\u003e Result\u003c()\u003e;\n    fn delete_file(\u0026self, path: \u0026PathBuf) -\u003e Result\u003c()\u003e;\n    fn create_initial_tree(\u0026mut self, max_depth: usize) -\u003e Result\u003cFileTreeEntry\u003e;\n    fn list_files(\u0026mut self, path: \u0026PathBuf, max_depth: Option\u003cusize\u003e) -\u003e Result\u003cFileTreeEntry\u003e;\n    /// Applies FileReplacements to a file\n    fn apply_replacements(\u0026self, path: \u0026Path, replacements: \u0026[FileReplacement]) -\u003e Result\u003cString\u003e;\n    /// Search for text in files with advanced options\n    fn search(\u0026self, path: \u0026Path, options: SearchOptions) -\u003e Result\u003cVec\u003cSearchResult\u003e\u003e;\n}\n","traces":[{"line":208,"address":[],"length":0,"stats":{"Line":12}},{"line":209,"address":[],"length":0,"stats":{"Line":12}}],"covered":2,"coverable":2},{"path":["/","Users","stippi","projects","code-assistant","src","ui","mod.rs"],"content":"pub mod terminal;\nuse async_trait::async_trait;\nuse thiserror::Error;\n\n#[derive(Debug, Clone)]\npub enum UIMessage {\n    // System actions that the agent takes\n    Action(String),\n    // Questions to the user that need a response\n    Question(String),\n    // LLM's reasoning about its next action\n    Reasoning(String),\n}\n\n#[derive(Error, Debug)]\npub enum UIError {\n    #[error(\"IO error: {0}\")]\n    IOError(#[from] std::io::Error),\n    // #[error(\"Input cancelled\")]\n    // Cancelled,\n    // #[error(\"Other UI error: {0}\")]\n    // Other(String),\n}\n\n#[async_trait]\npub trait UserInterface: Send + Sync {\n    /// Display a message to the user\n    async fn display(\u0026self, message: UIMessage) -\u003e Result\u003c(), UIError\u003e;\n\n    /// Get input from the user\n    async fn get_input(\u0026self, prompt: \u0026str) -\u003e Result\u003cString, UIError\u003e;\n\n    /// Display streaming output synchronously\n    fn display_streaming(\u0026self, text: \u0026str) -\u003e Result\u003c(), UIError\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","stippi","projects","code-assistant","src","ui","terminal.rs"],"content":"use super::{UIError, UIMessage, UserInterface};\nuse async_trait::async_trait;\nuse std::io::{self, Write};\nuse tokio::io::{AsyncBufReadExt, BufReader};\n\npub struct TerminalUI;\n\nimpl TerminalUI {\n    pub fn new() -\u003e Self {\n        Self\n    }\n\n    async fn write_line(\u0026self, s: \u0026str) -\u003e Result\u003c(), UIError\u003e {\n        let mut stdout = io::stdout().lock();\n        writeln!(stdout, \"{}\", s)?;\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl UserInterface for TerminalUI {\n    async fn display(\u0026self, message: UIMessage) -\u003e Result\u003c(), UIError\u003e {\n        match message {\n            UIMessage::Action(msg) =\u003e self.write_line(\u0026msg).await?,\n            UIMessage::Question(msg) =\u003e self.write_line(\u0026format!(\"{}\\n\u003e \", msg)).await?,\n            UIMessage::Reasoning(msg) =\u003e {\n                self.write_line(\"\").await?;\n                self.write_line(\"Reasoning:\").await?;\n                self.write_line(\u0026format!(\"  {}\", msg)).await?;\n                self.write_line(\"\").await?;\n            }\n        }\n        Ok(())\n    }\n\n    async fn get_input(\u0026self, prompt: \u0026str) -\u003e Result\u003cString, UIError\u003e {\n        print!(\"{}\", prompt);\n        io::stdout().flush()?;\n\n        let mut line = String::new();\n        let stdin = tokio::io::stdin();\n        let mut reader = BufReader::new(stdin);\n        reader.read_line(\u0026mut line).await?;\n\n        Ok(line.trim().to_string())\n    }\n\n    fn display_streaming(\u0026self, text: \u0026str) -\u003e Result\u003c(), UIError\u003e {\n        let mut stdout = io::stdout().lock();\n        write!(stdout, \"{}\", text)?;\n        stdout.flush()?;\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0}},{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":29},{"path":["/","Users","stippi","projects","code-assistant","src","utils","command.rs"],"content":"use anyhow::Result;\nuse std::path::PathBuf;\n\npub struct CommandOutput {\n    pub success: bool,\n    pub stdout: String,\n    pub stderr: String,\n}\n\n#[async_trait::async_trait]\npub trait CommandExecutor: Send + Sync {\n    async fn execute(\n        \u0026self,\n        command_line: \u0026str,\n        working_dir: Option\u003c\u0026PathBuf\u003e,\n    ) -\u003e Result\u003cCommandOutput\u003e;\n}\n\npub struct DefaultCommandExecutor;\n\n#[async_trait::async_trait]\nimpl CommandExecutor for DefaultCommandExecutor {\n    async fn execute(\n        \u0026self,\n        command_line: \u0026str,\n        working_dir: Option\u003c\u0026PathBuf\u003e,\n    ) -\u003e Result\u003cCommandOutput\u003e {\n        // Validate working_dir first\n        if let Some(dir) = working_dir {\n            if !dir.exists() {\n                return Err(anyhow::anyhow!(\n                    \"Working directory does not exist: {}\",\n                    dir.display()\n                ));\n            }\n            if !dir.is_dir() {\n                return Err(anyhow::anyhow!(\n                    \"Path is not a directory: {}\",\n                    dir.display()\n                ));\n            }\n        }\n        // Create shell command using login shell or fallback\n        #[cfg(target_family = \"unix\")]\n        let shell = std::env::var(\"SHELL\").unwrap_or_else(|_| \"/bin/bash\".to_string());\n        #[cfg(target_family = \"unix\")]\n        let mut cmd = std::process::Command::new(shell);\n        #[cfg(target_family = \"unix\")]\n        cmd.args([\"-c\", command_line]);\n\n        #[cfg(target_family = \"windows\")]\n        let mut cmd = std::process::Command::new(\"cmd\");\n        #[cfg(target_family = \"windows\")]\n        cmd.args([\"/C\", command_line]);\n\n        if let Some(dir) = working_dir {\n            cmd.current_dir(dir);\n        }\n        let output = cmd.output()?;\n\n        Ok(CommandOutput {\n            success: output.status.success(),\n            stdout: String::from_utf8_lossy(\u0026output.stdout).into_owned(),\n            stderr: String::from_utf8_lossy(\u0026output.stderr).into_owned(),\n        })\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":19},{"path":["/","Users","stippi","projects","code-assistant","src","utils","file_updater.rs"],"content":"use crate::types::FileReplacement;\n\npub fn apply_replacements(\n    content: \u0026str,\n    replacements: \u0026[FileReplacement],\n) -\u003e Result\u003cString, anyhow::Error\u003e {\n    let mut result = content.to_string();\n\n    for replacement in replacements {\n        // Count occurrences to ensure uniqueness\n        let matches: Vec\u003c_\u003e = result.match_indices(\u0026replacement.search).collect();\n\n        match matches.len() {\n            0 =\u003e anyhow::bail!(\n                \"Could not find search content:\\n{}\\nin file content\",\n                replacement.search\n            ),\n            1 =\u003e {\n                let (pos, _) = matches[0];\n                result.replace_range(\n                    pos..pos + replacement.search.len(),\n                    \u0026replacement.replace\n                );\n            },\n            _ =\u003e anyhow::bail!(\n                \"Found {} occurrences of search content:\\n```\\n{}\\n```\\nSearch text must match exactly one location. Try enlarging the section to replace.\",\n                matches.len(),\n                replacement.search\n            ),\n        }\n    }\n\n    Ok(result)\n}\n\n#[test]\nfn test_apply_replacements() -\u003e Result\u003c(), anyhow::Error\u003e {\n    let test_cases = vec![\n        // Basic replacement\n        (\n            \"Hello World\\nThis is a test\\nGoodbye\",\n            vec![FileReplacement {\n                search: \"Hello World\".to_string(),\n                replace: \"Hi there\".to_string(),\n            }],\n            Ok(\"Hi there\\nThis is a test\\nGoodbye\"),\n        ),\n        // Multiple unique replacements\n        (\n            \"function test() {\\n  console.log('test');\\n}\",\n            vec![\n                FileReplacement {\n                    search: \"console.log('test');\".to_string(),\n                    replace: \"return 42;\".to_string(),\n                },\n                FileReplacement {\n                    search: \"function test()\".to_string(),\n                    replace: \"function answer()\".to_string(),\n                },\n            ],\n            Ok(\"function answer() {\\n  return 42;\\n}\"),\n        ),\n        // Test error with duplicate content\n        (\n            \"test\\ntest\\ntest\",\n            vec![FileReplacement {\n                search: \"test\".to_string(),\n                replace: \"replaced\".to_string(),\n            }],\n            Err(\"Found 3 occurrences of search content\"), // Partial string match is fine for the test\n        ),\n        // Test error with not found content\n        (\n            \"test content\",\n            vec![FileReplacement {\n                search: \"not found\".to_string(),\n                replace: \"anything\".to_string(),\n            }],\n            Err(\"Could not find search content\"), // Partial string match is fine for the test\n        ),\n    ];\n\n    for (input, replacements, expected) in test_cases {\n        let result = apply_replacements(input, \u0026replacements);\n        match (result, expected) {\n            (Ok(result), Ok(expected)) =\u003e assert_eq!(result, expected),\n            (Err(e), Err(expected)) =\u003e assert!(e.to_string().contains(expected)),\n            _ =\u003e panic!(\"Test case result did not match expected outcome\"),\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":3,"address":[],"length":0,"stats":{"Line":9}},{"line":7,"address":[],"length":0,"stats":{"Line":9}},{"line":9,"address":[],"length":0,"stats":{"Line":29}},{"line":14,"address":[],"length":0,"stats":{"Line":2}},{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":18,"address":[],"length":0,"stats":{"Line":8}},{"line":19,"address":[],"length":0,"stats":{"Line":8}},{"line":20,"address":[],"length":0,"stats":{"Line":8}},{"line":21,"address":[],"length":0,"stats":{"Line":8}},{"line":22,"address":[],"length":0,"stats":{"Line":8}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":27,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":2}},{"line":33,"address":[],"length":0,"stats":{"Line":5}}],"covered":14,"coverable":14},{"path":["/","Users","stippi","projects","code-assistant","src","utils","mod.rs"],"content":"mod command;\nmod file_updater;\n\n#[allow(unused_imports)]\npub use command::{CommandExecutor, CommandOutput, DefaultCommandExecutor};\npub use file_updater::apply_replacements;\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>